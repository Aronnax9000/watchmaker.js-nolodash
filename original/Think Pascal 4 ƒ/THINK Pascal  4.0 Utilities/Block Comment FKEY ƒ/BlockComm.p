{									BlockComm.p											}{						Sourcefile for Block Comment FKEY								}{		    Copyright © 1989 Symantec Corporation.  All rights reserved.			}{	;	Author		:	Clement Wang														}{	;	Revised by:	Greg Howe														}{	;																						}{	;	Abstract	:																		}{	;	--------																			}{	;	This FKEY works by copying Text from the Clipboard into a Handle,			}{	;	adding/removing Block comments and then copying the result back			}{	;	into the Clipboard.  If the restrictions below are observed, Block			}{	;	commenting will work even if the line to be block commented out			}{	;	has comments in it.  Any level of block commenting is allowed.				}{	;	Block Uncommenting a line that has no Block Comments is harmless.		}{	;	The FKEY takes advantage of a couple of features of							}{	;	the THINK Pascal Pretty Printer: (1) Any number of Open comments		}{	;	are allowed on a line, the first comments out the rest of the line, (2) only 	}{	;	one	 close comment on a line is allowed and it must precede the line's 		}{	;	carriage return.																	}{	;	RESTRICTIONS :																	}{	;	-------------																	}{	;	This FKEY does not recognize the pairs (* and *){	;	as comments.  This FKEY does not recognize a close comment inside	 a 		}{	;	quoted string when block commenting.  In these cases, block comments are	}{	;	not properly done.																}{	;	HOW TO BUILD:																	}{	;	-------------																	}{	;	An FKEY Code Resource file has already been built, but if you want do it 	}{	;	yourself, simply open the BlockComm.Build.¹ project and choose 			}{	;	Build Code Resource from the Project menu . 									}{	;	HOW TO INSTALL:																}{	;	---------------																	}{	;	You have to use ResEdit to install FKEYs.   You COPY the FKEY resource 	}{	;	from the built CODE Resource File and PASTE it into either your System 	}{	;	File or the THINK Pascal	Application.  											}{	;	CAUTION:  Misuse of ResEdit can DAMAGE your files BEYOND REPAIR!!!		}{	;	Therefore, use ResEdit ONLY on COPIES of files.								}{	;	Here are the steps: (1) Launch ResEdit, (2) Open the file that the FKEY		}{	;	code resource is in, 																}{	;	(3)  COPY	the FKEY Resource, (4) Open the file in which you want to 		}{	;	install the resource, (5) PASTE, (6) Close all the files (BE SURE TO CLICK	}{	;	 YES TO SAVE CHANGES.)														}{	;	HOW TO USE:																		}{	;	-----------																		}{	;	This FKEY, when installed, is activated by pressing Command-Shift-0.		}{	;	(See the Macintosh Owner's Manual for information about other 			}{	;	Command-Shift Keys.)															}{	;	To Block Comment Text (1) COPY the lines you want to block comment.	  	}{	;	Be sure the last line includes the carriage return (otherwise the FKEY will	}{	;	 not block comment the text).  (2) Press Command-SHIFT-0, (3) PASTE 	}{	;	the contents back from the clipboard.  Block Uncomment Text is the same, }{	;	except use CAPS LOCK Command-SHIFT-0.									}{	;	Handy hint:  If you open the Clipboard window, you can see the effect of 	}{	;	block commenting and uncommenting.											}{	;	ERROR HANDLING:																}{	;	---------------																	}{	;	-- One Beep indicates a use error (e.g. no text in clipboard, missing a	 	}{	;	carriage return in the last line, mismatched Block Close or Open string 	}{	;	constants, etc.																	}{	;	-- Three beeps indicates a recoverable system error (e.g. not enough 		}{	;	memory).																			}unit BlockCommentFKEY;interface	{ A code resource must have no global variables.  All shared variables are }	{ local to procedure MAIN, and shared among its sub procedures }	procedure main;	{ a code resource must have a procedure called MAIN }implementation	const{ Very efficient code is generated if these comment strings are }{exactly 2 or 4 bytes }		OpenCommentConst = '{¥';		CloseCommentConst = '¥}';		NestedCommentConst = '¥]';	type		IndexType = 1..10000;{ PACs are better than STRINGS, especially if they are 4 bytes long }		PACType = packed array[IndexType] of char;		PACPtrType = ^PACType;		SmallPACType = packed array[1..2] of char;	procedure main;		label			0, 9998, 9999;	{ 9998 = Exit for User Errors, 9999 = Exit for System Errors }		var			aHandle: handle;					{ Handle to Text from Scrap }			thePACPtr: PACPtrType;			{ Same as PACPtr in argument, }											{ use PACPtr to avoid static link }											{ overhead }			ResultCode: longint;			Offset: longint;			theScrapLength: longint;			OpenComment, CloseComment, NestedComment: SmallPACType;			theKeyMap: KeyMap;{ -------- all the code for Block Uncommenting -------- }		function Compare (PACPtr: PACPtrType; index: integer; s: SmallPACType): boolean;			var				i: integer;		begin			if index >= 1 then		{ index can be < 1 if the first line in the }								{buffer is too short }				begin					Compare := True;					for i := 1 to length(s) do						if PACPtr^[index - 1 + i] <> s[i] then							Compare := False				end			else				Compare := False;		end;		function BlockUncomment (PACPtr: PACPtrType;		{ Ptr to Text from Scrap }										ScrapLength: longint; OpenComment, CloseComment, NestedComment: SmallPACType): longint;			var				StartBlockComment: boolean;	{ True if beginning has open block comment }				EndBlockComment: boolean;		{ True if ending has close block comment }				Sour: integer;					{ Source Index for PACPtr }				Dest: integer;						{ Destination Index for PACPtr }				StartPos: integer;				{ Start of Line Index for PACPtr }				EndPos: integer;					{ End of Line Index for PACPtr }				i, j: integer;				NumberOfCR: integer;			{ Carriage Return counters }		begin	{ Scan Buffer to make sure that the block comments match }			StartPos := 1;			for i := 1 to ScrapLength do				if PACPtr^[i] = chr($0D) then		{ At end of line, scan backwards }					begin						EndPos := i;						StartBlockComment := Compare(PACPtr, StartPos, OpenComment);						EndBlockComment := Compare(PACPtr, EndPos - length(CloseCommentConst), CloseComment) or Compare(PACPtr, EndPos - length(NestedCommentConst) - 1, NestedComment);						if (StartBlockComment and not EndBlockComment) or (StartBlockComment and not EndBlockComment) then							goto 9998;			{ Buffer not in proper format - mismatched }									{open and close/nested comment }						if StartBlockComment and EndBlockComment and (EndPos - StartPos < length(OpenCommentConst) + length(CloseCommentConst)) then							goto 9998;			{ Special Bad case of  (¥)  which looks like }									{properly matched, but isn't }						StartPos := i + 1;					end;	{ Remove One Level of Block Commenting From Text }			Sour := 1;			Dest := 1;			StartPos := 1;			while Sour <= ScrapLength do				begin					if StartPos = Sour then						begin		{ At Beginning of Line }							StartBlockComment := Compare(PACPtr, StartPos, OpenComment);							if StartBlockComment then		{ Skip Open Block Comment chars }								Sour := Sour + length(OpenCommentConst)							else								begin									if PACPtr^[sour] = chr($0D) then	{ -- At Beginning AND End of Line }										StartPos := Sour + 1;				{ the Start of the Next Line is }															{after this CR character }									PACPtr^[Dest] := PACPtr^[Sour];	{ Just copy the bytes }									Dest := Dest + 1;									Sour := Sour + 1;								end						end					else			{ Not At Beginning of Line }						begin							if PACPtr^[sour] = chr($0D) then								begin		{ At End of Line }									if StartBlockComment then										if Compare(PACPtr, sour - length(CloseCommentConst), CloseComment) then						{ Strip out Close Block Comment }											Dest := Dest - length(CloseCommentConst)										else											begin		{ Strip out Nested Block Comment }												Dest := Dest - length(NestedCommentConst) - 1;												PACPtr^[Dest] := '}';	{ but put in the close Comment }												Dest := Dest + 1;											end;									StartPos := Sour + 1;			{ the Start of the Next Line is }													{after this CR character }								end;		{ At End of Line }				{ Move the source byte to destination byte }							PACPtr^[Dest] := PACPtr^[Sour];							Dest := Dest + 1;							Sour := Sour + 1;						end;			{ Not At Beginning of Line }				end;	{ WHILE }			BlockUncomment := Dest - 1;		{ Return new length of Scrap }		end;{ -------- all the code for Block Commenting -------- }		function BlockComment (PACPtr: PACPtrType;		{ Ptr to Text from Scrap }										ScrapLength: longint; OpenComment, CloseComment, NestedComment: SmallPACType): longint;			var				theChar: char;				Sour: integer;				{ Source Index for PACPtr }				Dest: integer;					{ Destination Index for PACPtr }				SizeToGrow: Longint;		{ How much to Grow Handle when }										{adding comments }				i: longint;				NumberOfCR: integer;		{ Number of Carriage Returns in the Scrap }				NumberOfClose: integer;		{ Number of Close Brackets in the Scrap }				PrevCharIsClose: boolean;	{ Flag = whether previous char is a close bracket }			procedure insertcomment (comment: SmallPACType);				var					i: integer;			begin				for i := length(comment) downto 1 do					begin						PACPtr^[Dest] := comment[i];						Dest := Dest - 1;					end;			end;		begin			NumberOfCR := 0;			NumberOfClose := 0;			PrevCharIsClose := false;	{ Scan Text and see how many OpenComment & CloseComments are needed }			for i := 1 to ScrapLength do				begin					if PACPtr^[i] = '}' then						begin							PrevCharIsClose := true;						end					else if PACPtr^[i] = chr($0D) then						begin							NumberOfCR := NumberOfCR + 1;							if PrevCharIsClose then								NumberOfClose := NumberOfClose + 1;							PrevCharIsClose := false;						end					else						PrevCharIsClose := false;				end;	{ This calculation does NOT assume that the length of all the string }	{constants are the same, though it could. }			SizeToGrow := ScrapLength + NumberOfCR * length(OpenCommentConst) + (NumberOfCR - NumberOfClose) * length(CloseCommentConst) + NumberOfClose * length(NestedCommentConst);			HUnlock(aHandle);			SetHandleSize(aHandle, SizeToGrow);			if MemError <> noErr then				goto 9999;			HLock(aHandle);			PACPtr := PACPtrType(aHandle^);	{ Add One Level of Block Commenting To Text }			Dest := SizeToGrow;	{ Index into end of Handle where }								{chars will be moved to }			Sour := ScrapLength;	{ Index into end of scrap text }			while Sour >= 1 do				begin					theChar := PACPtr^[Sour];					PACPtr^[Dest] := theChar;					Dest := Dest - 1;					Sour := Sour - 1;					if theChar = chr($0D) then	{ --At End of line }						begin							if Sour = 0 then			{ At End of line AND beginning of buffer }								begin									insertcomment(CloseComment);									insertcomment(OpenComment);								end							else								begin									if PACPtr^[Sour] = '}' then										begin										{ At End of line AND }																{Close Brace at end of line }											PACPtr^[Dest] := PACPtr^[Sour];											Dest := Dest - 1;											Sour := Sour - 1;											insertcomment(NestedComment);										end									else								{ At End of line AND }													{no close brace at end of line }										begin											insertcomment(CloseComment);											if PACPtr^[Sour] = chr($0D) then	{ At End of line AND }																{beginning of line }												insertcomment(OpenComment);										end;								end;						end					else if Sour = 0 then							{ --At Beginning of Buffer }						begin							insertcomment(OpenComment);						end					else if PACPtr^[sour] = chr($0D) then		{ --At Beginning of Line }						begin							insertcomment(OpenComment);						end				end;			BlockComment := SizeToGrow;		end; { --------- Main Procedure --------- }	begin{ Initialize - common code for Block Commenting and Uncommenting }		aHandle := nil;		theScrapLength := GetScrap(nil, 'TEXT', offset);		if theScrapLength <= 0 then			goto 9998;		{ User Error - Nothing in Clipboard }		aHandle := NewHandle(theScrapLength);		if aHandle = nil then			goto 9999;		{ System Error - couldn't allocate memory }		theScrapLength := GetScrap(aHandle, 'TEXT', offset);		HLock(aHandle);		thePACPtr := PACPtrType(aHandle^);		if thePACPtr^[theScrapLength] <> chr($0D) then			begin 			{ ERROR: Scrap Text must end in a newline }				goto 9998;	{ User Error - Last Character isn't a newline }			end;{ Find out if the CAPS LOCK key is down to determine whether to Block }{or Unblock comment }{ In a real application, the Event Manager should be used. }{ Note: COMMAND-SHIFT-OPTION-0 would have made a better combination than }{ CAPS LOCK-COMMENT-SHIFT-OPTION-0, except that the former doesn't execute }{ the FKEY code. }		GetKeys(theKeyMap);			{ Test for Caps Lock key down }		if theKeyMap[57] then			theScrapLength := BlockUnComment(thePACPtr, theScrapLength, OpenCommentConst, CloseCommentConst, NestedCommentConst)		else			theScrapLength := BlockComment(thePACPtr, theScrapLength, OpenCommentConst, CloseCommentConst, NestedCommentConst);	{ Copy Text in aHandle Back to Scrap }		ResultCode := ZeroScrap;		if ResultCode <> noErr then			goto 9999;		{ System Error }{ DON'T USE thePACPtr because BlockComment may have moved the text }		ResultCode := PutScrap(theScrapLength, 'TEXT', pointer(aHandle^));		if ResultCode = noErr then			goto 0;		{ Exit without Error }9999:		{ System Error EXIT - three beeps }		SysBeep(10);		SysBeep(10);9998:		{ User Error EXIT - one beep  }		SysBeep(10);0:			{ Cleanup }		if aHandle <> nil then		{ ALWAYS check to see if a Handle }									{is NIL before disposing it }			begin				DisposHandle(aHandle);			end;	end;	{ main }end.	{ unit }