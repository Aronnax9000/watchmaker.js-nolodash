unit MethTableUtils;interface	{	Initialize this unit: order the method tables.	}	procedure InitMethTableUtils;	{	Given a class name, instantiate an object of that class. Return NIL if unknown class name or failed allocation	}	function NewByName (className: Str255): LongInt;		{ Creates an object of the given class name }	function ClassName (obj: univ LongInt): Str255;implementation{--------------------------------------------------------------------------------------------------}	const		NoClass = 0;	type{$IFC OPTION(FARCODE)}		ClassID = NoClass..$7FFFFFFF;{$ELSEC}		ClassID = NoClass..32766;{$ENDC}		PClassID = ^ClassID;		HClassID = ^PClassID;		HClassIdTable = ^PClassIdTable;		PClassIdTable = ^ClassIdTable;		ClassIdTable = array[1..16000] of ClassID; { Actually variable size }{--------------------------------------------------------------------------------------------------}	var		pNoOfOrderedClasses: INTEGER;		pOrderedClassIds: HClassIdTable;		pClassTable: Handle; 							{handle to class table}		pTObjectClassID: ClassID; 					{ClassID of the Root class}	function GetClassID (obj: univ Handle): ClassID;{ Given an object, return the object's ClassID. }	begin		GetClassID := HClassID(obj)^^;	end;	procedure UpperCaseName (var s: Str255);		var			i: Integer;	begin		for i := 1 to Length(s) do			s[i] := Chr(BAND(Ord(s[i]), $DF));	end;	function %_GetA5: LongInt;	inline		$2E8D;{--------------------------------------------------------------------------------------------------}	procedure GetClassNameFromID (class: ClassID; var clName: Str255);{ Given an object id, return the object's name.  ??? add error checking ??? }		var			classPtr: Ptr;	begin		if (class = NoClass) | ODD(class) then			clName := ''		else			begin{$IFC NOT Option(FarCode)}				classPtr := Ptr(LongIntPtr(class + %_GetA5 + 2)^);				clName := StringPtr(Ord(classPtr) + 8 + IntegerPtr(Ord(classPtr) + 6)^ * 4)^;{$ELSEC}				classPtr := Pointer(LongIntPtr(class + 2)^);				clName := StringPtr(Ord4(classPtr) + 12 + IntegerPtr(Ord4(classPtr) + 10)^ * 8)^;{$ENDC}			end;	end;{--------------------------------------------------------------------------------------------------}	function GetClassIDFromName (clName: Str255): ClassID;{ Given an object name, return its id. }		var			high, low, index: INTEGER;			nameFromTable: Str255;			compareResult: INTEGER;			id: ClassID;	begin		UpperCaseName(clName);		if pNoOfOrderedClasses > 0 then			begin				low := 1;				high := pNoOfOrderedClasses;				repeat					index := BSR(low + high, 1);				{ (low + high) DIV 2 }					id := pOrderedClassIds^^[index];					GetClassNameFromID(id, nameFromTable);					UpperCaseName(nameFromTable);					compareResult := RelString(clName, nameFromTable, TRUE, TRUE);					if compareResult = 0 then						begin							GetClassIDFromName := id;							EXIT(GetClassIDFromName);						end;					if compareResult < 0 then						high := index - 1					else						low := index + 1;				until low > high;			end;		GetClassIDFromName := NoClass;	end;{--------------------------------------------------------------------------------------------------}	function GetClassSizeFromID (class: ClassID): Size;{ Given an object id, return the class's instantiation size. }	begin{$IFC Not Option(FarCode)}		GetClassSizeFromID := IntegerPtr(LongIntPtr(class + %_GetA5 + 2)^ + 4)^;{$ELSEC}		GetClassSizeFromID := IntegerPtr(LongIntPtr(class + 2)^ + 8)^;{$ENDC}	end;{--------------------------------------------------------------------------------------------------}	procedure OrderClassIdsByName;		var			aClassName: Str255;			nameFromTable: Str255;			high, low, index: INTEGER;			id: ClassID;			tableSize, tableCount: INTEGER;	begin		pNoOfOrderedClasses := 0;{ pClassTable is a handle to the %_MethTables segment, which contains Class Info Procs laid}{ out sequentially, plus the %_InitObj routine which is just an RTS.  We can go through all}{ jump table entries for the segment and if the routine is *not* an RTS, we know it is a}{ Class Info Proc - the name is at the end of the method list.}		tableSize := IntegerPtr(Ord(pClassTable^) + 2)^; 		{# of jump table entries in %_MethTables segment}{$IFC Not Option(FarCode)}		id := 34 + IntegerPtr(pClassTable^)^;					{offset to first jump table entry in %_MethTables segment}{$ELSEC}		id := 34 + (Ord4(IntegerPtr(pClassTable^)^) * 8);{$ENDC}		pOrderedClassIds := HClassIdTable(NewHandle(tableSize * Sizeof(ClassID)));		{FailNIL(pOrderedClassIds);}		for tableCount := 1 to tableSize do			begin			{ make sure this is a real Class Info Proc and not the %_InitObj routine }				if IntegerPtr(LongIntPtr(%_GetA5 + 2 + id)^)^ <> $4E75 then					begin{$IFC Not Option(FarCode)}						GetClassNameFromID(ClassID(id), aClassName);{$ELSEC}						GetClassNameFromID(ClassID(id + %_GetA5), aClassName);{$ENDC}						if pNoOfOrderedClasses = 0 then							index := 1						else							begin								low := 1;								high := pNoOfOrderedClasses;								repeat									index := BSR(low + high, 1);		{ (low + high) DIV 2 }									GetClassNameFromID(pOrderedClassIds^^[index], nameFromTable);									UpperCaseName(nameFromTable);									if aClassName < nameFromTable then										high := index - 1									else										begin											low := index + 1;											index := index + 1;										end;								until low > high;							end;						if index <= pNoOfOrderedClasses then							BlockMove(@pOrderedClassIds^^[index], @pOrderedClassIds^^[index + 1], (pNoOfOrderedClasses - index + 1) * sizeof(ClassID));						pOrderedClassIds^^[index] := id;{$IFC Option(FarCode)}						pOrderedClassIDs^^[index] := pOrderedClassIDs^^[index] + %_GetA5;{$ENDC}						pNoOfOrderedClasses := pNoOfOrderedClasses + 1;					end;			{ go on to next class ID (jump table entry offset + 2) }				id := id + 8;			end;	end;{ This routine is only present to force the Segment Loader to load the %_MethTables.}{ It had better be the only non-Class Info Proc in that segment!}	procedure %_InitObj;	external;{ Essential one time initialization for this unit }	procedure InitMethTableUtils;	begin	{ Force the %_MethTables segment to be loaded and locked }		%_InitObj;	{ Obtain the handle to the Class Info Procs }		pClassTable := GetNamedResource('CODE', '%_MethTables');	{	Sort the class IDs so that we can efficiently search them later.	}		OrderClassIdsByName;	end;	function MakeNewInstance (class: classID): Handle;		var			itsSize: INTEGER;			obj: Handle;	begin		MakeNewInstance := nil;		if class <> 0 then			begin				obj := NewHandleClear(GetClassSizeFromId(class));				if obj <> nil then			{ Install class ID into object }					HClassID(obj)^^ := class;				MakeNewInstance := obj;			end;	end;{--------------------------------------------------------------------------------------------------}	function NewByName (className: Str255): LongInt;{ Creates an object of the given class name }	begin		NewByName := Ord4(MakeNewInstance(GetClassIDFromName(className)));	end;	function ClassName (obj: univ LongInt): Str255;		var			s: Str255;	begin		if (obj = 0) or Odd(obj) then			s := ''		else			GetClassNameFromID(HClassId(obj)^^, s);		ClassName := s;	end;end. {UObject.p}