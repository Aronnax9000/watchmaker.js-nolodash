{	This file has been processed by The THINK Pascal Source Converter, v1.1.	}{}{Created: Sunday, January 6, 1991 at 11:16 PM}{    Slots.p}{    Pascal Interface to the Macintosh Libraries}{}{        Copyright Apple Computer, Inc.    1986-1990}{        All rights reserved}{}unit Slots;interface	const		fCardIsChanged = 1;                                 {Card is Changed field in StatusFlags field of sInfoArray}		fCkForSame = 0;                                     {For SearchSRT. Flag to check for SAME sResource in the table. }		fCkForNext = 1;                                     {For SearchSRT. Flag to check for NEXT sResource in the table. }		fWarmStart = 2;                                     {If this bit is set then warm start else cold start.}		stateNil = 0;                                       {State}		stateSDMInit = 1;                                   {:Slot declaration manager Init}		statePRAMInit = 2;                                  {:sPRAM record init}		statePInit = 3;                                     {:Primary init}		stateSInit = 4;                                     {:Secondary init}{ flags for spParamData }		fall = 0;                                           { bit 0: set=search enabled/disabled sRsrc's }		foneslot = 1;                                       {       1: set=search sRsrc's in given slot only }		fnext = 2;                                          {       2: set=search for next sRsrc }	type		SQElemPtr = ^SlotIntQElement;		SlotIntQElement = record				sqLink: Ptr;                                    {ptr to next element}				sqType: INTEGER;                                {queue type ID for validity}				sqPrio: INTEGER;                                {priority}				sqAddr: ProcPtr;                                {interrupt service routine}				sqParm: LONGINT;                                {optional A1 parameter}			end;		SpBlockPtr = ^SpBlock;		SpBlock = packed record				spResult: LONGINT;                              {FUNCTION Result}				spsPointer: Ptr;                                {structure pointer}				spSize: LONGINT;                                {size of structure}				spOffsetData: LONGINT;                          {offset/data field used by sOffsetData}				spIOFileName: Ptr;                              {ptr to IOFile name for sDisDrvrName}				spsExecPBlk: Ptr;                               {pointer to sExec parameter block.}				spParamData: LONGINT;                           {misc parameter data (formerly spStackPtr).}				spMisc: LONGINT;                                {misc field for SDM.}				spReserved: LONGINT;                            {reserved for future expansion}				spIOReserved: INTEGER;                          {Reserved field of Slot Resource Table}				spRefNum: INTEGER;                              {RefNum}				spCategory: INTEGER;                            {sType: Category}				spCType: INTEGER;                               {Type}				spDrvrSW: INTEGER;                              {DrvrSW}				spDrvrHW: INTEGER;                              {DrvrHW}				spTBMask: SignedByte;                           {type bit mask bits 0..3 mask words 0..3}				spSlot: SignedByte;                             {slot number}				spID: SignedByte;                               {structure ID}				spExtDev: SignedByte;                           {ID of the external device}				spHwDev: SignedByte;                            {Id of the hardware device.}				spByteLanes: SignedByte;                        {bytelanes from card ROM format block}				spFlags: SignedByte;                            {standard flags}				spKey: SignedByte;                              {Internal use only}			end;		SInfoRecPtr = ^SInfoRecord;		SInfoRecord = packed record				siDirPtr: Ptr;                                  {Pointer to directory}				siInitStatusA: INTEGER;                         {initialization E}				siInitStatusV: INTEGER;                         {status returned by vendor init code}				siState: SignedByte;                            {initialization state}				siCPUByteLanes: SignedByte;                     {0=[d0..d7] 1=[d8..d15]}				siTopOfROM: SignedByte;                         {Top of ROM= $FssFFFFx: x is TopOfROM}				siStatusFlags: SignedByte;                      {bit 0 - card is changed}				siTOConst: INTEGER;                             {Time Out C for BusErr}				siReserved: packed array[0..1] of SignedByte;  {reserved}				siROMAddr: Ptr;                                 { addr of top of ROM }				siSlot: CHAR;                                   { slot number }				siPadding: packed array[0..2] of SignedByte;   { reserved }			end;		SDMRecord = packed record				sdBEVSave: ProcPtr;                             {Save old BusErr vector}				sdBusErrProc: ProcPtr;                          {Go here to determine if it is a BusErr}				sdErrorEntry: ProcPtr;                          {Go here if BusErrProc finds real BusErr}				sdReserved: LONGINT;                            {Reserved}			end;		FHeaderRecPtr = ^FHeaderRec;		FHeaderRec = packed record				fhDirOffset: LONGINT;                           {offset to directory}				fhLength: LONGINT;                              {length of ROM}				fhCRC: LONGINT;                                 {CRC}				fhROMRev: SignedByte;                           {revision of ROM}				fhFormat: SignedByte;                           {format - 2}				fhTstPat: LONGINT;                              {test pattern}				fhReserved: SignedByte;                         {reserved}				fhByteLanes: SignedByte;                        {ByteLanes}			end;		SEBlock = packed record				seSlot: SignedByte;                             {Slot number.}				sesRsrcId: SignedByte;                          {sResource Id.}				seStatus: INTEGER;                              {Status of code executed by sExec.}				seFlags: SignedByte;                            {Flags}				seFiller0: SignedByte;                          {Filler, must be SignedByte to align on odd boundry}				seFiller1: SignedByte;                          {Filler}				seFiller2: SignedByte;                          {Filler}				seResult: LONGINT;                              {Result of sLoad.}				seIOFileName: LONGINT;                          {Pointer to IOFile name.}				seDevice: SignedByte;                           {Which device to read from.}				sePartition: SignedByte;                        {The partition.}				seOSType: SignedByte;                           {Type of OS.}				seReserved: SignedByte;                         {Reserved field.}				seRefNum: SignedByte;                           {RefNum of the driver.}				seNumDevices: SignedByte;                       { Number of devices to load.}				seBootState: SignedByte;                        {State of StartBoot code.}			end;{  Principle  }	function SReadByte (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7000, $A06E, $3E80;	function SReadWord (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7001, $A06E, $3E80;	function SReadLong (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7002, $A06E, $3E80;	function SGetCString (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7003, $A06E, $3E80;	function SGetBlock (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7005, $A06E, $3E80;	function SFindStruct (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7006, $A06E, $3E80;	function SReadStruct (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7007, $A06E, $3E80;{  Special  }	function SReadInfo (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7010, $A06E, $3E80;	function SReadPRAMRec (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7011, $A06E, $3E80;	function SPutPRAMRec (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7012, $A06E, $3E80;	function SReadFHeader (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7013, $A06E, $3E80;	function SNextSRsrc (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7014, $A06E, $3E80;	function SNextTypeSRsrc (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7015, $A06E, $3E80;	function SRsrcInfo (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7016, $A06E, $3E80;	function SCkCardStat (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7018, $A06E, $3E80;	function SReadDrvrName (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7019, $A06E, $3E80;	function SFindDevBase (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $701B, $A06E, $3E80;	function SFindBigDevBase (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $701C, $A06E, $3E80;{  Advanced  }	function InitSDeclMgr (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7020, $A06E, $3E80;	function SPrimaryInit (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7021, $A06E, $3E80;	function SCardChanged (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7022, $A06E, $3E80;	function SExec (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7023, $A06E, $3E80;	function SOffsetData (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7024, $A06E, $3E80;	function SInitPRAMRecs (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7025, $A06E, $3E80;	function SReadPBSize (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7026, $A06E, $3E80;	function SCalcStep (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7028, $A06E, $3E80;	function SInitSRsrcTable (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7029, $A06E, $3E80;	function SSearchSRT (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $702A, $A06E, $3E80;	function SUpdateSRT (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $702B, $A06E, $3E80;	function SCalcSPointer (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $702C, $A06E, $3E80;	function SGetDriver (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $702D, $A06E, $3E80;	function SPtrToSlot (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $702E, $A06E, $3E80;	function SFindSInfoRecPtr (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $702F, $A06E, $3E80;	function SFindSRsrcPtr (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7030, $A06E, $3E80;	function SDeleteSRTRec (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7031, $A06E, $3E80;	function OpenSlot (paramBlock: ParmBlkPtr; async: BOOLEAN): OSErr;	function OpenSlotSync (paramBlock: ParmBlkPtr): OSErr;	inline		$205F, $A200, $3E80;	function OpenSlotAsync (paramBlock: ParmBlkPtr): OSErr;	inline		$205F, $A600, $3E80;{  Device Manager Slot Support  }	function SIntInstall (sIntQElemPtr: SQElemPtr; theSlot: INTEGER): OSErr;	inline		$301F, $205F, $A075, $3E80;	function SIntRemove (sIntQElemPtr: SQElemPtr; theSlot: INTEGER): OSErr;	inline		$301F, $205F, $A076, $3E80;	function SVersion (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7008, $A06E, $3E80;	function SetSRsrcState (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $7009, $A06E, $3E80;	function InsertSRTRec (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $700A, $A06E, $3E80;	function SGetSRsrc (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $700B, $A06E, $3E80;	function SGetTypeSRsrc (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $700C, $A06E, $3E80;	function SGetSRsrcPtr (spBlkPtr: SpBlockPtr): OSErr;	inline		$205F, $701D, $A06E, $3E80;    { UsingSlots }implementationend.