{ The Code Profiler gives you statistics about the execution behavior of your programs.			}{ This tool measures the time spent in each routine, as well as the number of statements 		}{ executed in each routine .															 					}{ To use the profiler, turn on "Profile" in the Compile Options dialog. THINK Pascal will then		}{ automatically generate calls to initialize and terminate the profiler in your main program,		}{ and will recompile all Pascal source files with calls to the profiler at appropriate points.		}{ In typical use, the automatic profiler support is sufficient.  However, for larger programs		}{ and for finer control over profiling statistics, the calls available from this interface are		}{ provided.																								}{ To use these calls, add the "Profile.p" file to your project. Also, any unit						}{ that makes calls to the profiler or modifies the %_PTrace variable (see below) will need to	}{ include the "Profiler" unit in its USES-clause.														}{ At program startup time, the profiler is initialized to track two hundred different routines,	}{ and sixty-four levels of activation.																	}{ You can save memory, or allocate room for more procedures, by using "InitProfiler" instead	}{ of "InitProfile". Each activation requires 14 bytes of memory, and each procedure record		}{ requires 94 bytes of memory.																			}{ When your program terminates, DumpProfile is called to print the profiling statistics out to 	}{ the Text window. You can call DumpProfile at any time; also, you can call DumpProfileToFile	}{ to write the profiler statistics to a file in the same folder as the project document.				}{ The %_PTrace global variable is used to selectively control profiling for specific routines.		}{ Whenever %_PTrace is TRUE, the profiler will track procedure entries and exits. By setting	}{ %_PTrace to FALSE, all procedures called SUBSEQUENT to the changing of %_PTrace will not	}{ be profiled. By setting %_PTrace to TRUE again, all procedures called SUBSEQUENT to turning }{ %_PTrace back on will be profiled.																	}unit Profiler;interface	procedure InitProfile;	{ This routine must be called first to initialize the profiler.  It causes the 					}	{ profiler to start gathering execution statistics.  All subsequent routine calls in 			}	{ your program will be measured. 																}	{ This routine is called automatically at program startup; you should not need to call it	}	{ again.																							}	procedure DumpProfile;	{ This routine causes the profiler to dump the current information about your program	}	{ to the Text Window.																			}	procedure DumpProfileToFile (fileName: Str255);	{	This routine causes the profiler to dump the current profiler statistics to the file		}	{	specified by "fileName", in the default volume (usually the same directory as the		}	{	running project, unless the program has done a SetVol). If the file already exists,		}	{	it will be deleted and overwritten.															}	procedure ResetProfile;	{ This routine reinitializes all the statistical information. }	procedure TerminateProfile;	{ This routine de-installs the profiler from the executing program.	 						}	{ TerminateProfile is called automatically at program termination; you should not need	}	{ to call it unless you wish to prematurely turn off the profiler.								}	function InitProfiler (maxProcedures, maxActivations: Integer): Boolean;	{	"InitProfiler" is a more flexible form of "InitProfile"; it will enable the profiler to	}	{	measure an arbitrary (up to 32,768) number of routines. InitProfiler will return		}	{	TRUE if the initialization completed successfully, FALSE if not.							}{$Push}{$J+}	var		%_PTrace: Boolean;{$Pop}implementation	{	All of the above routines are externally defined in Runtime.Lib.							}end.