{	This file has been processed by The THINK Pascal Source Converter, v1.1.	}{}{Created: Friday, January 11, 1991 at 3:01 PM}{    AppleEvents.p}{    Pascal Interface to the Macintosh Libraries}{}{        Copyright Apple Computer, Inc.    1989-1990}{        All rights reserved}{    }{}unit AppleEvents;interface	uses		AppleTalk, Processes, PPCToolbox, EPPC, Notification;	const		typeBoolean = 'bool';		typeChar = 'TEXT';		typeSMInt = 'shor';		typeInteger = 'long';		typeSMFloat = 'sing';		typeFloat = 'doub';		typeLongInteger = 'long';		typeShortInteger = 'shor';		typeLongFloat = 'doub';		typeShortFloat = 'sing';		typeExtended = 'exte';		typeComp = 'comp';		typeMagnitude = 'magn';		typeAEList = 'list';		typeAERecord = 'reco';		typeTrue = 'true';		typeFalse = 'fals';		typeAlias = 'alis';		typeEnumerated = 'enum';		typeType = 'type';		typeAppParameters = 'appa';		typeProperty = 'prop';		typeFSS = 'fss ';		typeKeyword = 'keyw';		typeSectionH = 'sect';		typeWildCard = '****';		typeApplSignature = 'sign';		typeSessionID = 'ssid';		typeTargetID = 'targ';		typeProcessSerialNumber = 'psn ';		typeNull = 'null';                  {the type of null/nonexistent data}		kCoreEventClass = 'aevt';		kAEOpenApplication = 'oapp';		kAEOpenDocuments = 'odoc';		kAEPrintDocuments = 'pdoc';		kAEQuitApplication = 'quit';		kAECreatorType = 'crea';		kAEQuitAll = 'quia';		kAEShutDown = 'shut';		kAERestart = 'rest';		kAEApplicationDied = 'obit';		keyProcessSerialNumber = 'psn ';		keyErrorNumber = 'errn';		keyErrorString = 'errs';		kAEAnswer = 'ansr';		keyDirectObject = '----';{ keyword used in install special handler }		keyPreDispatch = 'phac';            { PreHandler Accessor Call }		keySelectProc = 'selh';             { More selector Call }{ keywords used in attributes }		keyTransactionIDAttr = 'tran';		keyReturnIDAttr = 'rtid';		keyEventClassAttr = 'evcl';		keyEventIDAttr = 'evid';		keyAddressAttr = 'addr';		keyOptionalKeywordAttr = 'optk';		keyTimeoutAttr = 'timo';		keyInteractLevelAttr = 'inte';      {this attribute is read only will be set in AESend}		keyEventSourceAttr = 'esrc';        { this attribute is read only }		keyMissedKeywordAttr = 'miss';      { this attribute is read only }{ constants for use in AESendMode }		kAENoReply = $00000001;             { Sender doesn't want a reply to event }		kAEQueueReply = $00000002;          { Sender wants a reply but won't wait }		kAEWaitReply = $00000003;           { Sender wants a reply and will be waiting }		kAENeverInteract = $00000010;       { Server should not interact with user }		kAECanInteract = $00000020;         { Server may try to interact with user }		kAEAlwaysInteract = $00000030;      { Server should always interact with user where appropriate }		kAECanSwitchLayer = $00000040;      { Interaction may switch layer }		kAEDontReconnect = $00000080;       { don't reconnect if there is a sessClosedErr from PPCToolbox }		kAEWantReceipt = nReturnReceipt;    { Send wants a receipt of message }{ constants to be used in AESendPriority }		kAENormalPriority = $00000000;      { Post message at the end of event queue }		kAEHighPriority = nAttnMsg;         { Post message at the front of the event queue }{ special constants in generating events }		kAnyTransactionID = 0;              { no transaction is in use }		kAutoGenerateReturnID = -1;         { AECreateAppleEvent will generate a session-unique ID }{ constant for use AESend }		kAEDefaultTimeout = -1;             { timeout value determined by AEM }		kNoTimeOut = -2;                    { wait until reply comes back, however long it takes }{ dispatch parameter to AEResumeTheCurrentEvent takes a pointer to a dispatch}{table, or one of these two constants}		kAENoDispatch = 0;		kAEUseStandardDispatch = -1;{ Error messages in response to reading and writing event contents }		errAECoercionFail = -1700;		errAEDescNotFound = -1701;		errAECorruptData = -1702;		errAEWrongDataType = -1703;		errAENotAEDesc = -1704;		errAEBadListItem = -1705;           { Specified list item does not exist }		errAENewerVersion = -1706;          { Need newer version of AppleEvent Manager }		errAENotAppleEvent = -1707;         { The event is not in AppleEvent format }{ Error messages in response to sending/receiving a message }		errAEEventNotHandled = -1708;       { The AppleEvent was not handled by any handler }		errAEReplyNotValid = -1709;         { AEResetTimer was passed an invalid reply parameter }		errAEUnknownSendMode = -1710;       { Mode wasn't NoReply, WaitReply, or QueueReply;     or Interaction level is unknown }		errAEWaitCanceled = -1711;          { In AESend, User cancelled out of wait loop for  reply or receipt }		errAETimeout = -1712;               { AppleEvent timed out }		errAENoUserInteraction = -1713;     { no user interaction allowed }		errAENotASpecialFunction = -1714;   { there is no special function with this keyword }		errAEParamMissed = -1715;           { a required parameter was not accessed }		errAEUnknownAddressType = -1716;    { The target address type is not known }		errAEHandlerNotFound = -1717;       { No handler in the dispatch tables fits the parameters to}{                                              AEGetEventHandler or AEGetCoercionHandler}		errAEReplyNotArrived = -1718;       { the contents of the reply you are accessing have not arrived yet }		errAEIllegalIndex = -1719;          { Index is out of range in a put operation }	type		AEKeyword = packed array[1..4] of CHAR;		AEEventClass = packed array[1..4] of CHAR;		AEEventID = packed array[1..4] of CHAR;		DescType = ResType;{ tagged data, the standard AppleEvent data type }		AEDesc = record				descriptorType: DescType;				dataHandle: Handle;			end;		AEAddressDesc = AEDesc;             { an AEDesc which contains addressing data }		AEDescList = AEDesc;                { a list of AEDesc is a special kind of AEDesc }		AERecord = AEDescList;              { AERecord is a list of keyworded AEDesc }		AppleEvent = AERecord;              { an AERecord that contains an AppleEvent }		AESendMode = LONGINT;               { Type of parameter to AESend }		AESendPriority = INTEGER;           { Type of priority param of AESend }{ type of param to AEGetInteractionAllowed and AESetInteractionAllowed }		AEInteractAllowed = (kAEInteractWithSelf, kAEInteractWithLocal, kAEInteractWithAll);{ Return param to AEGetTheCurrentEvent, and kAEEventSource attribute }		AEEventSource = (kAEUnknownSource, kAEDirectCall, kAESameProcess, kAELocalProcess, kAERemoteProcess);{ types for AppleEvent Array support }{}{ Basic data type of attibutes & parameters}		AEKeyDesc = record				descKey: AEKeyword;				descContent: AEDesc;			end;		AEArrayType = (kAEDataArray, kAEPackedArray, kAEHandleArray, kAEDescArray, kAEKeyDescArray);{ Array routines support these different types of elements}		AEArrayData = record				case AEArrayType of					kAEDataArray: (							AEDataArray: array[0..0] of Integer					);					kAEPackedArray: (							AEPackedArray: packed array[0..0] of Char					);					kAEHandleArray: (							AEHandleArray: array[0..0] of Handle					);					kAEDescArray: (							AEDescArray: array[0..0] of AEDesc					);					kAEKeyDescArray: (							AEKeyDescArray: array[0..0] of AEKeyDesc					);			end;		AEArrayDataPointer = ^AEArrayData;		EventHandlerProcPtr = ProcPtr;		IdleProcPtr = ProcPtr;		EventFilterProcPtr = ProcPtr;{   *********************************************************************}{The following calls apply to any AEDesc. Every result descriptor is created for you,}{so you will be responsible for memory management of the descriptors so created.}{Purgeable descriptor data is not supported: the AEM does not call LoadResource.}	function AECreateDesc (typeCode: DescType; dataPtr: Ptr; dataSize: Size; var result: AEDesc): OSErr;	inline		$303C, $0825, $A816;	function AECoercePtr (typeCode: DescType; dataPtr: Ptr; dataSize: Size; toType: DescType; var result: AEDesc): OSErr;	inline		$303C, $0A02, $A816;	function AECoerceDesc (theAEDesc: AEDesc; toType: DescType; var result: AEDesc): OSErr;	inline		$303C, $0603, $A816;	function AEDisposeDesc (var theAEDesc: AEDesc): OSErr;	inline		$303C, $0204, $A816;	function AEDuplicateDesc (theAEDesc: AEDesc; var result: AEDesc): OSErr;	inline		$303C, $0405, $A816;{ *********************************************************************}{ The following calls apply to AEDescList.}{  Since AEDescList is a subtype of AEDesc, the calls in the previous}{  section can also be used for AEDescList. All list and array indices are 1-based.}{  If the data was greater than maximumSize in the routines below, then actualSize will}{  be greater than maximumSize, but only maximumSize bytes will actually be retrieved.}	function AECreateList (factoringPtr: Ptr; factoredSize: Size; isRecord: BOOLEAN; var resultList: AEDescList): OSErr;	inline		$303C, $0706, $A816;	function AECountItems (theAEDescList: AEDescList; var theCount: LONGINT): OSErr;	inline		$303C, $0407, $A816;	function AEPutPtr (theAEDescList: AEDescList; index: LONGINT; typeCode: DescType; dataPtr: Ptr; dataSize: Size): OSErr;	inline		$303C, $0A08, $A816;	function AEPutDesc (theAEDescList: AEDescList; index: LONGINT; theAEDesc: AEDesc): OSErr;	inline		$303C, $0609, $A816;	function AEGetNthPtr (theAEDescList: AEDescList; index: LONGINT; desiredType: DescType; var theAEKeyword: AEKeyword; var typeCode: DescType; dataPtr: Ptr; maximumSize: Size; var actualSize: Size): OSErr;	inline		$303C, $100A, $A816;	function AEGetNthDesc (theAEDescList: AEDescList; index: LONGINT; desiredType: DescType; var theAEKeyword: AEKeyword; var result: AEDesc): OSErr;	inline		$303C, $0A0B, $A816;	function AESizeOfNthItem (theAEDescList: AEDescList; index: LONGINT; var typeCode: DescType; var dataSize: Size): OSErr;	inline		$303C, $082A, $A816;	function AEGetArray (theAEDescList: AEDescList; arrayType: AEArrayType; arrayPtr: AEArrayDataPointer; maximumSize: Size; var itemType: DescType; var itemSize: Size; var itemCount: LONGINT): OSErr;	inline		$303C, $0D0C, $A816;	function AEPutArray (theAEDescList: AEDescList; arrayType: AEArrayType; arrayPtr: AEArrayDataPointer; itemType: DescType; itemSize: Size; itemCount: LONGINT): OSErr;	inline		$303C, $0B0D, $A816;	function AEDeleteItem (theAEDescList: AEDescList; index: LONGINT): OSErr;	inline		$303C, $040E, $A816;{ *********************************************************************}{The following calls apply to AERecord.}{  Since AERecord is a subtype of AEDescList, the calls in the previous}{  sections can also be used for AERecord}{  an AERecord can be created by using AECreateList with isRecord set to true}	function AEPutKeyPtr (theAERecord: AERecord; theAEKeyword: AEKeyword; typeCode: DescType; dataPtr: Ptr; dataSize: Size): OSErr;	inline		$303C, $0A0F, $A816;	function AEPutKeyDesc (theAERecord: AERecord; theAEKeyword: AEKeyword; theAEDesc: AEDesc): OSErr;	inline		$303C, $0610, $A816;	function AEGetKeyPtr (theAERecord: AERecord; theAEKeyword: AEKeyword; desiredType: DescType; var typeCode: DescType; dataPtr: Ptr; maximumSize: Size; var actualSize: Size): OSErr;	inline		$303C, $0E11, $A816;	function AEGetKeyDesc (theAERecord: AERecord; theAEKeyword: AEKeyword; desiredType: DescType; var result: AEDesc): OSErr;	inline		$303C, $0812, $A816;	function AESizeOfKeyDesc (theAERecord: AERecord; theAEKeyword: AEKeyword; var typeCode: DescType; var dataSize: Size): OSErr;	inline		$303C, $0829, $A816;	function AEDeleteKeyDesc (theAERecord: AERecord; theAEKeyword: AEKeyword): OSErr;	inline		$303C, $0413, $A816;{ }{    *********************************************************************}{    The following calls are used to pack and unpack parameters from records of}{    type AppleEvent. Since AppleEvent is a subtype of AERecord, the calls in the previous}{    sections can also be used for variables of type AppleEvent. The next six calls}{    are in fact identical to the six calls for AERecord.}{}	function AEPutParamPtr (theAppleEvent: AppleEvent; theAEKeyword: AEKeyword; typeCode: DescType; dataPtr: Ptr; dataSize: Size): OSErr;	inline		$303C, $0A0F, $A816;	function AEPutParamDesc (theAppleEvent: AppleEvent; theAEKeyword: AEKeyword; theAEDesc: AEDesc): OSErr;	inline		$303C, $0610, $A816;	function AEGetParamPtr (theAppleEvent: AppleEvent; theAEKeyword: AEKeyword; desiredType: DescType; var typeCode: DescType; dataPtr: Ptr; maximumSize: Size; var actualSize: Size): OSErr;	inline		$303C, $0E11, $A816;	function AEGetParamDesc (theAppleEvent: AppleEvent; theAEKeyword: AEKeyword; desiredType: DescType; var result: AEDesc): OSErr;	inline		$303C, $0812, $A816;	function AESizeOfParam (theAppleEvent: AppleEvent; theAEKeyword: AEKeyword; var typeCode: DescType; var dataSize: Size): OSErr;	inline		$303C, $0829, $A816;	function AEDeleteParam (theAppleEvent: AppleEvent; theAEKeyword: AEKeyword): OSErr;	inline		$303C, $0413, $A816;{ *********************************************************************}{The following calls also apply to type AppleEvent.  Message attributes are far more restricted, and}{can only be accessed through the following 5 calls. The various list and record routines cannot be used}{to access the attributes of an event.}	function AEGetAttributePtr (theAppleEvent: AppleEvent; theAEKeyword: AEKeyword; desiredType: DescType; var typeCode: DescType; dataPtr: Ptr; maximumSize: Size; var actualSize: Size): OSErr;	inline		$303C, $0E15, $A816;	function AEGetAttributeDesc (theAppleEvent: AppleEvent; theAEKeyword: AEKeyword; desiredType: DescType; var result: AEDesc): OSErr;	inline		$303C, $0826, $A816;	function AESizeOfAttribute (theAppleEvent: AppleEvent; theAEKeyword: AEKeyword; var typeCode: DescType; var dataSize: Size): OSErr;	inline		$303C, $0828, $A816;	function AEPutAttributePtr (theAppleEvent: AppleEvent; theAEKeyword: AEKeyword; typeCode: DescType; dataPtr: Ptr; dataSize: Size): OSErr;	inline		$303C, $0A16, $A816;	function AEPutAttributeDesc (theAppleEvent: AppleEvent; theAEKeyword: AEKeyword; theAEDesc: AEDesc): OSErr;	inline		$303C, $0627, $A816;{ *********************************************************************}{ The next four calls are basic routines used to create, send, and process AppleEvents.}	function AECreateAppleEvent (theAEEventClass: AEEventClass; theAEEventID: AEEventID; target: AEAddressDesc; returnID: INTEGER; transactionID: LONGINT; var result: AppleEvent): OSErr;	inline		$303C, $0B14, $A816;	function AESend (theAppleEvent: AppleEvent; var reply: AppleEvent; sendMode: AESendMode; sendPriority: AESendPriority; timeOutInTicks: LONGINT; idleProc: IdleProcPtr; filterProc: EventFilterProcPtr): OSErr;	inline		$303C, $0D17, $A816;	function AEProcessAppleEvent (theEventRecord: EventRecord): OSErr;	inline		$303C, $021B, $A816;{ During event processing, an event handler may realize that it is likely}{to exceed the client's timeout limit. Passing the reply to this}{routine causes a wait event to be generated to ask the client for more time.}	function AEResetTimer (reply: AppleEvent): OSErr;	inline		$303C, $0219, $A816;{   *********************************************************************}{The following four calls are available for applications which need more sophisticated control}{over when and how events are processed. Applications which implement multi-session servers or }{which implement their own internal event queueing will probably be the major clients of these}{routines.  }{}{ Can be called from within a handler to prevent the AEM from disposing of}{the AppleEvent when the handler returns. Can be used to asynchronously process the }{event (as in MacApp).}	function AESuspendTheCurrentEvent (theAppleEvent: AppleEvent): OSErr;	inline		$303C, $022B, $A816;{ }{     Tells the AppleEvent manager that processing is either about to resume or has}{    been completed on a previously suspended event. The procPtr passed in as the}{    dispatcher parameter will be called to attempt to redispatch the event. Several}{    constants for the dispatcher parameter allow special behavior. They are:}{    - kAEUseStandardDispatch means redispatch as if the event was just received, using the}{        standard AppleEvent Dispatcher.}{    - kAENoDispatch means ignore the parameter.}{        Use this in the case where no redispatch is needed, and the event has been handled.}{    - non nil means call the routine which dispatcher points to.}{}	function AEResumeTheCurrentEvent (theAppleEvent: AppleEvent; reply: AppleEvent; dispatcher: EventHandlerProcPtr; handlerRefcon: LONGINT): OSErr;	inline		$303C, $0818, $A816;{ Allows application to examine the currently executing event }	function AEGetTheCurrentEvent (var theAppleEvent: AppleEvent): OSErr;	inline		$303C, $021A, $A816;{ Set the current event to the parameter }	function AESetTheCurrentEvent (theAppleEvent: AppleEvent): OSErr;	inline		$303C, $022C, $A816;{ }{    *********************************************************************}{     The following three calls are used to allow applications to behave courteously }{    when a user interaction such as a dialog box is needed. }{}	function AEGetInteractionAllowed (var level: AEInteractAllowed): OSErr;	inline		$303C, $021D, $A816;	function AESetInteractionAllowed (level: AEInteractAllowed): OSErr;	inline		$303C, $011E, $A816;	function AEInteractWithUser (timeOutInTicks: LONGINT; nmReqPtr: NMRecPtr; idleProc: IdleProcPtr): OSErr;	inline		$303C, $061C, $A816;{  *********************************************************************}{ These calls are used to set up and modify the event dispatch table}{ Add an AppleEvent Handler  }	function AEInstallEventHandler (theAEEventClass: AEEventClass; theAEEventID: AEEventID; handler: EventHandlerProcPtr; handlerRefcon: LONGINT; isSysHandler: BOOLEAN): OSErr;	inline		$303C, $091F, $A816;{  Remove an AppleEvent Handler  }	function AERemoveEventHandler (theAEEventClass: AEEventClass; theAEEventID: AEEventID; handler: EventHandlerProcPtr; isSysHandler: BOOLEAN): OSErr;	inline		$303C, $0720, $A816;{  Get the corresponding AppleEvent Handler  }	function AEGetEventHandler (theAEEventClass: AEEventClass; theAEEventID: AEEventID; var handler: EventHandlerProcPtr; var handlerRefcon: LONGINT; isSysHandler: BOOLEAN): OSErr;	inline		$303C, $0921, $A816;{  *********************************************************************}{ These calls are used to set up and modify the coercion dispatch table}	function AEInstallCoercionHandler (fromType: DescType; toType: DescType; handler: ProcPtr; handlerRefcon: LONGINT; fromTypeIsDesc: BOOLEAN; isSysHandler: BOOLEAN): OSErr;	inline		$303C, $0A22, $A816;{  Remove a Coercion Handler  }	function AERemoveCoercionHandler (fromType: DescType; toType: DescType; handler: ProcPtr; isSysHandler: BOOLEAN): OSErr;	inline		$303C, $0723, $A816;{  Get the corresponding Coercion Handler  }	function AEGetCoercionHandler (fromType: DescType; toType: DescType; var handler: ProcPtr; var handlerRefcon: LONGINT; var fromTypeIsDesc: BOOLEAN; isSysHandler: BOOLEAN): OSErr;	inline		$303C, $0B24, $A816;{ }{      *********************************************************************}{    These calls are used to set up and modify special hooks into the AppleEvent Manager.}{}{    Install the special handler named by the Keyword}	function AEInstallSpecialHandler (functionClass: AEKeyword; handler: ProcPtr; isSysHandler: BOOLEAN): OSErr;	inline		$303C, $0500, $A816;{  Remove the special handler named by the Keyword  }	function AERemoveSpecialHandler (functionClass: AEKeyword; handler: ProcPtr; isSysHandler: BOOLEAN): OSErr;	inline		$303C, $0501, $A816;{  Get the special handler named by the Keyword  }	function AEGetSpecialHandler (functionClass: AEKeyword; var handler: ProcPtr; isSysHandler: BOOLEAN): OSErr;	inline		$303C, $052D, $A816;    { UsingAppleEvents }implementationend.