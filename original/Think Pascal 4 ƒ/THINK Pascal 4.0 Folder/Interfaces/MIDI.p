{	This file has been processed by The THINK Pascal Source Converter, v1.1.	}{}{Created: Tuesday, January 8, 1991 at 10:53 AM}{    MIDI.p}{    Pascal Interface to the Macintosh Libraries}{}{            Copyright © 1988-1990, Apple Computer, Inc.}{            All Rights Reserved}{}unit MIDI;interface	const		midiToolNum = 4;                {tool number of MIDI Manager for SndDispVersion call}		midiMaxNameLen = 31;            {maximum number of characters in port and client names}{ Time formats }		midiFormatMSec = 0;             {milliseconds}		midiFormatBeats = 1;            {beats}		midiFormat24fpsBit = 2;         {24 frames/sec.}		midiFormat25fpsBit = 3;         {25 frames/sec.}		midiFormat30fpsDBit = 4;        {30 frames/sec. drop-frame}		midiFormat30fpsBit = 5;         {30 frames/sec.}		midiFormat24fpsQF = 6;          {24 frames/sec. longInt format }		midiFormat25fpsQF = 7;          {25 frames/sec. longInt format }		midiFormat30fpsDQF = 8;         {30 frames/sec. drop-frame longInt format }		midiFormat30fpsQF = 9;          {30 frames/sec. longInt format }		midiInternalSync = 0;           {internal sync}		midiExternalSync = 1;           {external sync}{ Port types}		midiPortTypeTime = 0;           {time port}		midiPortTypeInput = 1;          {input port}		midiPortTypeOutput = 2;         {output port}		midiPortTypeTimeInv = 3;        {invisible time port}{ OffsetTimes  }		midiGetEverything = $7FFFFFFF;  {get all packets, regardless of time stamps}		midiGetNothing = $80000000;     {get no packets, regardless of time stamps}		midiGetCurrent = $00000000;     {get current packets only}{    MIDI data and messages are passed in MIDIPacket records (see below).}{    The first byte of every MIDIPacket contains a set of flags}{   }{    bits 0-1    00 = new MIDIPacket, not continued}{                     01 = begining of continued MIDIPacket}{                     10 = end of continued MIDIPacket}{                    11 = continuation}{    bits 2-3     reserved}{  }{    bits 4-6      000 = packet contains MIDI data}{   }{                     001 = packet contains MIDI Manager message}{   }{    bit 7              0 = MIDIPacket has valid stamp}{                        1 = stamp with current clock}		midiContMask = $03;		midiNoCont = $00;		midiStartCont = $01;		midiMidCont = $03;		midiEndCont = $02;		midiTypeMask = $70;		midiMsgType = $00;		midiMgrType = $10;		midiTimeStampMask = $80;		midiTimeStampCurrent = $80;		midiTimeStampValid = $00;{    MIDI Manager MIDIPacket command words (the first word in the data field}{    for midiMgrType messages)}		midiOverflowErr = $0001;		midiSCCErr = $0002;		midiPacketErr = $0003;		midiMaxErr = $00FF;             {all command words less than this value  are error indicators}{ Valid results to be returned by readHooks }		midiKeepPacket = 0;		midiMorePacket = 1;		midiNoMorePacket = 2;{ Errors: }		midiNoClientErr = -250;         {no client with that ID found}		midiNoPortErr = -251;           {no port with that ID found}		midiTooManyPortsErr = -252;     {too many ports already installed in the system}		midiTooManyConsErr = -253;      {too many connections made}		midiVConnectErr = -254;         {pending virtual connection created}		midiVConnectMade = -255;        {pending virtual connection resolved}		midiVConnectRmvd = -256;        {pending virtual connection removed}		midiNoConErr = -257;            {no connection exists between specified ports}		midiWriteErr = -258;            {MIDIWritePacket couldn't write to all connected ports}		midiNameLenErr = -259;          {name supplied is longer than 31 characters}		midiDupIDErr = -260;            {duplicate client ID}		midiInvalidCmdErr = -261;       {command not supported for port type}{     Driver calls: }		midiOpenDriver = 1;		midiCloseDriver = 2;	type		MIDIPacketPtr = ^MIDIPacket;		MIDIPacket = packed record				flags: Byte;				len: Byte;				tStamp: LONGINT;				data: packed array[0..248] of Byte;			end;		MIDIClkInfo = record				sync: INTEGER;              {synchronization external/internal}				curTime: LONGINT;           {current value of port's clock}				format: INTEGER;            {time code format}			end;		MIDIIDRec = record				clientID: OSType;				portID: OSType;			end;		MIDIPortInfoPtr = ^MIDIPortInfo;		MIDIPortInfoHdl = ^MIDIPortInfoPtr;		MIDIPortInfo = record				portType: INTEGER;          {type of port}				timeBase: MIDIIDRec;        {MIDIIDRec for time base}				numConnects: INTEGER;       {number of connections}				cList: array[1..100] of MIDIIDRec;			end;		MIDIPortParamsPtr = ^MIDIPortParams;		MIDIPortParams = record				portID: OSType;             {ID of port, unique within client}				portType: INTEGER;          {Type of port - input, output, time, etc.}				timeBase: INTEGER;          {refnum of time base, 0 if none}				offsetTime: LONGINT;        {offset for current time stamps}				readHook: Ptr;              {routine to call when input data is valid}				refCon: LONGINT;            {refcon for port (for client use)}				initClock: MIDIClkInfo;     {initial settings for a time base}				name: Str255;               {name of the port, This is a real live string, not a ptr.}			end;		MIDIIDListPtr = ^MIDIIDList;		MIDIIDListHdl = ^MIDIIDListPtr;		MIDIIDList = record				numIDs: INTEGER;				list: array[1..100] of OSType;			end;{}{     Prototype Declarations for readHook and timeProc}{    }{     FUNCTION myReadHook(myPacket: MIDIPacketPtr; myRefCon: LONGINT) : INTEGER;}{     PROCEDURE myTimeProc(curTime: LONGINT; myRefCon: LONGINT);}{}	function SndDispVersion (toolnum: INTEGER): LONGINT;	function MIDISignIn (clientID: OSType; refCon: LONGINT; icon: Handle; name: Str255): OSErr;	inline		$203C, $0004, midiToolNum, $A800;	procedure MIDISignOut (clientID: OSType);	inline		$203C, $0008, midiToolNum, $A800;	function MIDIGetClients: MIDIIDListHdl;	inline		$203C, $000C, midiToolNum, $A800;	procedure MIDIGetClientName (clientID: OSType; var name: Str255);	inline		$203C, $0010, midiToolNum, $A800;	procedure MIDISetClientName (clientID: OSType; name: Str255);	inline		$203C, $0014, midiToolNum, $A800;	function MIDIGetPorts (clientID: OSType): MIDIIDListHdl;	inline		$203C, $0018, midiToolNum, $A800;	function MIDIAddPort (clientID: OSType; BufSize: INTEGER; var refnum: INTEGER; init: MIDIPortParamsPtr): OSErr;	inline		$203C, $001C, midiToolNum, $A800;	function MIDIGetPortInfo (clientID: OSType; portID: OSType): MIDIPortInfoHdl;	inline		$203C, $0020, midiToolNum, $A800;	function MIDIConnectData (srcClID: OSType; srcPortID: OSType; dstClID: OSType; dstPortID: OSType): OSErr;	inline		$203C, $0024, midiToolNum, $A800;	function MIDIUnConnectData (srcClID: OSType; srcPortID: OSType; dstClID: OSType; dstPortID: OSType): OSErr;	inline		$203C, $0028, midiToolNum, $A800;	function MIDIConnectTime (srcClID: OSType; srcPortID: OSType; dstClID: OSType; dstPortID: OSType): OSErr;	inline		$203C, $002C, midiToolNum, $A800;	function MIDIUnConnectTime (srcClID: OSType; srcPortID: OSType; dstClID: OSType; dstPortID: OSType): OSErr;	inline		$203C, $0030, midiToolNum, $A800;	procedure MIDIFlush (refnum: INTEGER);	inline		$203C, $0034, midiToolNum, $A800;	function MIDIGetReadHook (refnum: INTEGER): ProcPtr;	inline		$203C, $0038, midiToolNum, $A800;	procedure MIDISetReadHook (refnum: INTEGER; hook: ProcPtr);	inline		$203C, $003C, midiToolNum, $A800;	procedure MIDIGetPortName (clientID: OSType; portID: OSType; var name: Str255);	inline		$203C, $0040, midiToolNum, $A800;	procedure MIDISetPortName (clientID: OSType; portID: OSType; name: Str255);	inline		$203C, $0044, midiToolNum, $A800;	procedure MIDIWakeUp (refnum: INTEGER; time: LONGINT; period: LONGINT; timeProc: ProcPtr);	inline		$203C, $0048, midiToolNum, $A800;	procedure MIDIRemovePort (refnum: INTEGER);	inline		$203C, $004C, midiToolNum, $A800;	function MIDIGetSync (refnum: INTEGER): INTEGER;	inline		$203C, $0050, midiToolNum, $A800;	procedure MIDISetSync (refnum: INTEGER; sync: INTEGER);	inline		$203C, $0054, midiToolNum, $A800;	function MIDIGetCurTime (refnum: INTEGER): LONGINT;	inline		$203C, $0058, midiToolNum, $A800;	procedure MIDISetCurTime (refnum: INTEGER; time: LONGINT);	inline		$203C, $005C, midiToolNum, $A800;	procedure MIDIStartTime (refnum: INTEGER);	inline		$203C, $0060, midiToolNum, $A800;	procedure MIDIStopTime (refnum: INTEGER);	inline		$203C, $0064, midiToolNum, $A800;	procedure MIDIPoll (refnum: INTEGER; offsetTime: LONGINT);	inline		$203C, $0068, midiToolNum, $A800;	function MIDIWritePacket (refnum: INTEGER; packet: MIDIPacketPtr): OSErr;	inline		$203C, $006C, midiToolNum, $A800;	function MIDIWorldChanged (clientID: OSType): BOOLEAN;	inline		$203C, $0070, midiToolNum, $A800;	function MIDIGetOffsetTime (refnum: INTEGER): LONGINT;	inline		$203C, $0074, midiToolNum, $A800;	procedure MIDISetOffsetTime (refnum: INTEGER; offsetTime: LONGINT);	inline		$203C, $0078, midiToolNum, $A800;	function MIDIConvertTime (srcFormat: INTEGER; dstFormat: INTEGER; time: LONGINT): LONGINT;	inline		$203C, $007C, midiToolNum, $A800;	function MIDIGetRefCon (refnum: INTEGER): LONGINT;	inline		$203C, $0080, midiToolNum, $A800;	procedure MIDISetRefCon (refnum: INTEGER; refCon: LONGINT);	inline		$203C, $0084, midiToolNum, $A800;	function MIDIGetClRefCon (clientID: OSType): LONGINT;	inline		$203C, $0088, midiToolNum, $A800;	procedure MIDISetClRefCon (clientID: OSType; refCon: LONGINT);	inline		$203C, $008C, midiToolNum, $A800;	function MIDIGetTCFormat (refnum: INTEGER): INTEGER;	inline		$203C, $0090, midiToolNum, $A800;	procedure MIDISetTCFormat (refnum: INTEGER; format: INTEGER);	inline		$203C, $0094, midiToolNum, $A800;	procedure MIDISetRunRate (refnum: INTEGER; rate: INTEGER; time: LONGINT);	inline		$203C, $0098, midiToolNum, $A800;	function MIDIGetClientIcon (clientID: OSType): Handle;	inline		$203C, $009C, midiToolNum, $A800;    { UsingMIDI }implementationend.