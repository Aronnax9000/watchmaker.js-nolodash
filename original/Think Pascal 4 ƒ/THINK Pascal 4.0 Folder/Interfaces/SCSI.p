{	This file has been processed by The THINK Pascal Source Converter, v1.1.	}{}{Created: Sunday, January 6, 1991 at 11:14 PM}{    SCSI.p}{    Pascal Interface to the Macintosh Libraries}{}{        Copyright Apple Computer, Inc.    1986-1990}{        All rights reserved}{}unit SCSI;interface	const		scInc = 1;		scNoInc = 2;		scAdd = 3;		scMove = 4;		scLoop = 5;		scNop = 6;		scStop = 7;		scComp = 8;		scCommErr = 2;                                  {communications error, operation timeout}		scArbNBErr = 3;                                 {arbitration timeout waiting for not BSY}		scBadParmsErr = 4;                              {bad parameter or TIB opcode}		scPhaseErr = 5;                                 {SCSI bus not in correct phase for attempted operation}		scCompareErr = 6;                               {data compare error}		scMgrBusyErr = 7;                               {SCSI Manager busy }		scSequenceErr = 8;                              {attempted operation is out of sequence}		scBusTOErr = 9;                                 {CPU bus timeout}		scComplPhaseErr = 10;                           {SCSI bus wasn't in Status phase}		sbSIGWord = $4552;		pMapSIG = $504D;	type		Block0 = packed record				sbSig: INTEGER;                             {unique value for SCSI block 0}				sbBlkSize: INTEGER;                         {block size of device}				sbBlkCount: LONGINT;                        {number of blocks on device}				sbDevType: INTEGER;                         {device type}				sbDevId: INTEGER;                           {device id}				sbData: LONGINT;                            {not used}				sbDrvrCount: INTEGER;                       {driver descriptor count}				ddBlock: LONGINT;                           {1st driver's starting block}				ddSize: INTEGER;                            {size of 1st driver (512-byte blks)}				ddType: INTEGER;                            {system type (1 for Mac+)}				ddPad: array[0..242] of INTEGER;           {ARRAY[0..242] OF INTEGER; not used}			end;		Partition = packed record				pmSig: INTEGER;                             {unique value for map entry blk}				pmSigPad: INTEGER;                          {currently unused}				pmMapBlkCnt: LONGINT;                       {# of blks in partition map}				pmPyPartStart: LONGINT;                     {physical start blk of partition}				pmPartBlkCnt: LONGINT;                      {# of blks in this partition}				pmPartName: packed array[0..31] of CHAR;   {ASCII partition name}				pmParType: packed array[0..31] of CHAR;    {ASCII partition type}				pmLgDataStart: LONGINT;                     {log. # of partition's 1st data blk}				pmDataCnt: LONGINT;                         {# of blks in partition's data area}				pmPartStatus: LONGINT;                      {bit field for partition status}				pmLgBootStart: LONGINT;                     {log. blk of partition's boot code}				pmBootSize: LONGINT;                        {number of bytes in boot code}				pmBootAddr: LONGINT;                        {memory load address of boot code}				pmBootAddr2: LONGINT;                       {currently unused}				pmBootEntry: LONGINT;                       {entry point of boot code}				pmBootEntry2: LONGINT;                      {currently unused}				pmBootCksum: LONGINT;                       {checksum of boot code}				pmProcessor: packed array[0..15] of CHAR;  {ASCII for the processor type}				pmPad: array[0..187] of INTEGER;           {512 bytes long currently unused}			end;		SCSIInstr = record				scOpcode: INTEGER;				scParam1: LONGINT;				scParam2: LONGINT;			end;	function SCSIReset: OSErr;	inline		$4267, $A815;	function SCSIGet: OSErr;	inline		$3F3C, $0001, $A815;	function SCSISelect (targetID: INTEGER): OSErr;	inline		$3F3C, $0002, $A815;	function SCSICmd (buffer: Ptr; count: INTEGER): OSErr;	inline		$3F3C, $0003, $A815;	function SCSIRead (tibPtr: Ptr): OSErr;	inline		$3F3C, $0005, $A815;	function SCSIRBlind (tibPtr: Ptr): OSErr;	inline		$3F3C, $0008, $A815;	function SCSIWrite (tibPtr: Ptr): OSErr;	inline		$3F3C, $0006, $A815;	function SCSIWBlind (tibPtr: Ptr): OSErr;	inline		$3F3C, $0009, $A815;	function SCSIComplete (var stat: INTEGER; var message: INTEGER; wait: LONGINT): OSErr;	inline		$3F3C, $0004, $A815;	function SCSIStat: INTEGER;	inline		$3F3C, $000A, $A815;	function SCSISelAtn (targetID: INTEGER): OSErr;	inline		$3F3C, $000B, $A815;	function SCSIMsgIn (var message: INTEGER): OSErr;	inline		$3F3C, $000C, $A815;	function SCSIMsgOut (message: INTEGER): OSErr;	inline		$3F3C, $000D, $A815;    { UsingSCSI }implementationend.