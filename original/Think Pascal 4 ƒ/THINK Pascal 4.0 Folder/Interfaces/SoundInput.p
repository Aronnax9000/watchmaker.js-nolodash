{	This file has been processed by The THINK Pascal Source Converter, v1.1.	}{}{Created: Wednesday, June 27, 1990 at 6:42 PM}{    SoundInput.p}{    Pascal Interface to the Macintosh Libraries}{}{        Copyright Apple Computer, Inc. 1989-1990}{        All rights reserved}{}unit SoundInput;interface	const		siDeviceIsConnected = 1;				{ input device is connected and ready for input }		siDeviceNotConnected = 0;				{ input device is not connected }		siDontKnowIfConnected = -1;				{ can't tell if input device is connected }		siReadPermission = 0;				{ permission passed to SPBOpenDevice }		siWritePermission = 1;				{ permission passed to SPBOpenDevice }{ Info Selectors for Sound Input Drivers }		siDeviceConnected = 'dcon';			{ input device connection status }		siAGCOnOff = 'agc ';			{ automatic gain control state }		siPlayThruOnOff = 'plth';			{ playthrough state }		siTwosComplementOnOff = 'twos';			{ two's complement state }		siLevelMeterOnOff = 'lmet';			{ level meter state }		siRecordingQuality = 'qual';			{ recording quality }		siVoxRecordInfo = 'voxr';			{ VOX record parameters }		siVoxStopInfo = 'voxs';			{ VOX stop parameters }		siNumberChannels = 'chan';			{ current number of channels }		siSampleSize = 'ssiz';			{ current sample size }		siSampleRate = 'srat';			{ current sample rate }		siCompressionType = 'comp';			{ current compression type }		siCompressionFactor = 'cmfa';			{ current compression factor }		siCompressionHeader = 'cmhd';			{ return compression header }		siDeviceName = 'name';			{ input device name }		siDeviceIcon = 'icon';			{ input device icon }		siDeviceBufferInfo = 'dbin';			{ size of interrupt buffer }		siSampleSizeAvailable = 'ssav';			{ sample sizes available }		siSampleRateAvailable = 'srav';			{ sample rates available }		siCompressionAvailable = 'cmav';			{ compression types available }		siChannelAvailable = 'chav';			{ number of channels available }		siAsync = 'asyn';			{ asynchronous capability }		siOptionsDialog = 'optd';			{ display options dialog }		siContinuous = 'cont';			{ continous recording }		siActiveChannels = 'chac';			{ active channels }		siActiveLevels = 'lmac';			{ active meter levels }		siInitializeDriver = 'init';			{ reserved for internal use only }		siCloseDriver = 'clos';			{ reserved for internal use only }		siPauseRecording = 'paus';			{ reserved for internal use only }		siUserInterruptProc = 'user';			{ reserved for internal use only }{ Qualities }		siBestQuality = 'best';		siBetterQuality = 'betr';		siGoodQuality = 'good';	type		SPBPtr = ^SPB;		SPB = record				inRefNum: LONGINT;			{ reference number of sound input device }				count: LONGINT;			{ number of bytes to record }				milliseconds: LONGINT;			{ number of milliseconds to record }				bufferLength: LONGINT;			{ length of buffer in bytes }				bufferPtr: Ptr;				{ buffer to store sound data in }				completionRoutine: ProcPtr;			{ completion routine }				interruptRoutine: ProcPtr;			{ interrupt routine }				userLong: LONGINT;			{ user-defined field }				error: OSErr;				{ error }				unused1: LONGINT;			{ reserved - must be zero }			end;	function SPBVersion: NumVersion;	inline		$203C, $0000, $0014, $A800;	function SndRecord (filterProc: ModalFilterProcPtr; corner: Point; quality: OSType; var sndHandle: Handle): OSErr;	inline		$203C, $0804, $0014, $A800;	function SndRecordToFile (filterProc: ModalFilterProcPtr; corner: Point; quality: OSType; fRefNum: INTEGER): OSErr;	inline		$203C, $0708, $0014, $A800;	function SPBSignInDevice (deviceRefNum: INTEGER; deviceName: Str255): OSErr;	inline		$203C, $030C, $0014, $A800;	function SPBSignOutDevice (deviceRefNum: INTEGER): OSErr;	inline		$203C, $0110, $0014, $A800;	function SPBGetIndexedDevice (count: INTEGER; var deviceName: Str255; var deviceIconHandle: Handle): OSErr;	inline		$203C, $0514, $0014, $A800;	function SPBOpenDevice (deviceName: Str255; permission: INTEGER; var inRefNum: LONGINT): OSErr;	inline		$203C, $0518, $0014, $A800;	function SPBCloseDevice (inRefNum: LONGINT): OSErr;	inline		$203C, $021C, $0014, $A800;	function SPBRecord (inParamPtr: SPBPtr; asynchFlag: BOOLEAN): OSErr;	inline		$203C, $0320, $0014, $A800;	function SPBRecordToFile (fRefNum: INTEGER; inParamPtr: SPBPtr; asynchFlag: BOOLEAN): OSErr;	inline		$203C, $0424, $0014, $A800;	function SPBPauseRecording (inRefNum: LONGINT): OSErr;	inline		$203C, $0228, $0014, $A800;	function SPBResumeRecording (inRefNum: LONGINT): OSErr;	inline		$203C, $022C, $0014, $A800;	function SPBStopRecording (inRefNum: LONGINT): OSErr;	inline		$203C, $0230, $0014, $A800;	function SPBGetRecordingStatus (inRefNum: LONGINT; var recordingStatus: INTEGER; var meterLevel: INTEGER; var totalSamplesToRecord: LONGINT; var numberOfSamplesRecorded: LONGINT; var totalMsecsToRecord: LONGINT; var numberOfMsecsRecorded: LONGINT): OSErr;	inline		$203C, $0E34, $0014, $A800;	function SPBGetDeviceInfo (inRefNum: LONGINT; infoType: OSType; infoData: Ptr): OSErr;	inline		$203C, $0638, $0014, $A800;	function SPBSetDeviceInfo (inRefNum: LONGINT; infoType: OSType; infoData: Ptr): OSErr;	inline		$203C, $063C, $0014, $A800;	function SPBMillisecondsToBytes (inRefNum: LONGINT; var milliseconds: LONGINT): OSErr;	inline		$203C, $0440, $0014, $A800;	function SPBBytesToMilliseconds (inRefNum: LONGINT; var byteCount: LONGINT): OSErr;	inline		$203C, $0444, $0014, $A800;	function SetupSndHeader (sndHandle: Handle; numChannels: INTEGER; sampleRate: Fixed; sampleSize: INTEGER; compressionType: OSType; baseNote: INTEGER; numBytes: LONGINT; var headerLen: INTEGER): OSErr;	inline		$203C, $0D48, $0014, $A800;	function SetupAIFFHeader (fRefNum: INTEGER; numChannels: INTEGER; sampleRate: Fixed; sampleSize: INTEGER; compressionType: OSType; numBytes: LONGINT; numFrames: LONGINT): OSErr;	inline		$203C, $0B4C, $0014, $A800;    { UsingSoundInput }implementationend.