UNIT Miscellaneous;{******************************************************}{*												v1.1 Sept 1993														 *}{*																															 *}{*		Changed Message procs to use Alerts																 *}{*		Removed PictMessage (never called), change Message calls to DisplayError	 *}{*		Added positioning to alerts and dialogs															 *}{*		Alert now uses STR# for closing, quitting, etc		  										 *}{*		Added several functions, for EOF and checking system (see below)					 *}{*     Validated the rect after RestoreOffscreen to prevent drawing twice				 *}{******************************************************}INTERFACEUSES	Globals, sane;CONST	MaxResources = 154;PROCEDURE ImportPICT;PROCEDURE MirrorBits (SourceBitmap: BitMap; RectOfInterest: Rect; VAR DestBitMap: BitMap);FUNCTION FossilsExist: Boolean;PROCEDURE DireMessage (string1ID, string2ID: Integer; VAR Verdict: Integer; YesNo: Boolean);PROCEDURE MemoryMessage (ID: Integer; InMessage: Str255; VAR Verdict: Integer); { 27291 for Fewer album screens, 27295 for Careful}PROCEDURE SimpleMessage (ID: Integer; VAR Verdict: Integer);PROCEDURE HelpMessage (StrID: Integer);PROCEDURE ArrayDialog (VAR WDetails, DDetails, TDetails: MarchingOrders; VAR Verdict: integer);FUNCTION LayoutDialog (VAR HoldConstant, RowChap, ColChap: MarchingOrders; VAR NRows, NCols: Integer): boolean;FUNCTION GenesDialog: Boolean;PROCEDURE SyringeMessage;PROCEDURE Pause (Message: Str255);PROCEDURE SetItemState (Mndx, Indx: Integer; Flag: Boolean);FUNCTION RandInt (Max: Integer): Integer;FUNCTION Odd (i: Integer): Boolean;FUNCTION RandSwell (Indgene: Swelltype): SwellType;PROCEDURE EraseInnerRect (box: Rect);PROCEDURE FrameOuterRect (box: Rect);PROCEDURE FrameInnerRect (box: Rect);PROCEDURE StoreOffScreen (box: Rect; VAR Snapshot: BitMap);PROCEDURE RestoreOffScreen (box: Rect; Snapshot: BitMap);PROCEDURE CleanUp;PROCEDURE MakeOffScreen (box: Rect; VAR Snapshot: BitMap; VAR Burst: Boolean);PROCEDURE DrawInt (i: Integer);PROCEDURE Drawi (i: Integer);PROCEDURE DrawReal (r: real);PROCEDURE RealToString (r: real; VAR theString: str255);PROCEDURE Grow (VAR Box: Rect; d: Integer);PROCEDURE BoxesOnly;PROCEDURE OwnEditMenu;FUNCTION DawkFilter (param: ParmBlkPtr): Boolean;PROCEDURE SmallMenus;PROCEDURE LargeMenus;PROCEDURE BigFuncBox (Box: Rect; VAR Outbox: Rect);PROCEDURE SmallFuncBox (Box: Rect; VAR Outbox: Rect; BoxSize: Integer);PROCEDURE FuncBox (Box: Rect; VAR Outbox: Rect; BoxSize: Integer);PROCEDURE Poop (n: Integer);PROCEDURE StartDocuments (DocumentCount: Integer);FUNCTION TwoToThe (n: integer): integer;{*****  Procedures added for v1.1 ********}										{ Operating System utilities }FUNCTION TrapAvailable (theTrap: integer): Boolean;FUNCTION WNEIsImplemented: Boolean;FUNCTION TempMemCallsAvailable: Boolean;PROCEDURE DeleteOldFile (volRefNum: Integer; dirID: LongInt; fileName: Str255);										{ Dialog Manager utilities		}PROCEDURE PositionDialog (theType: ResType; theID: integer);PROCEDURE FindDlogPosition (theType: ResType; theID: integer; VAR corner: Point);FUNCTION IsEOF (refNum: Integer; howClose: LongInt): Boolean;FUNCTION FileSize (refNum: Integer): LongInt;		{returns the number of bytes in the file. Same as}{	the toolbox function GetEOF, except this returns the size instead of an error code. It has this name to emulate the }{   Turbo routine, except this returns bytes (since we don't use pascal type-files now).}FUNCTION snail: person;FUNCTION Turritella: person;FUNCTION Bivalve: person;FUNCTION Ammonite: person;FUNCTION Nautilus: person;FUNCTION Brachiopod: person;FUNCTION Cone: person;FUNCTION Whelk: person;FUNCTION Scallop: person;FUNCTION Eloise: person;FUNCTION Gallaghers: person;FUNCTION Rapa: person;FUNCTION Lightning: person;FUNCTION Sundial: person;FUNCTION Fig: person;FUNCTION Tun: person;FUNCTION RazorShell: person;FUNCTION JapaneseWonder: person;IMPLEMENTATIONUSES	Script, SysEqu, Traps;{*	Operating System utilities	*}{****************************************************}{ TrapAvailable}{}{ 	Check whether a certain trap exists on this machine.  }{ this function uses the new approved method as per IM-VI}{	p. 3-8												}{}{****************************************************}FUNCTION snail: person;	VAR		theShell: person;	BEGIN		WITH theShell DO			BEGIN				WOpening := 1.66;				DDisplacement := 0;				SShape := 1.2;				TTranslation := 2;				Coarsegraininess := 4;				reach := 5;				GeneratingCurve := 0;				Handedness := 1;				TranslationGradient := 1;			END;		snail := theShell;	END;FUNCTION Turritella: person;	VAR		theShell: person;	BEGIN		WITH theShell DO			BEGIN				WOpening := 1.30;				DDisplacement := 0;				SShape := 1;				TTranslation := 8.2;				Coarsegraininess := 8;				reach := 10;				GeneratingCurve := 0;				Handedness := 1;				TranslationGradient := 1;			END;		Turritella := theShell;	END;FUNCTION Bivalve: person;	VAR		theShell: person;	BEGIN		WITH theShell DO			BEGIN				WOpening := 1000;				DDisplacement := 0;				SShape := 1.2;				TTranslation := 0.5;				MutProb := 50;				Coarsegraininess := 2;				reach := 1;				GeneratingCurve := 0;				Handedness := 1;				TranslationGradient := 1;			END;		Bivalve := theShell;	END;FUNCTION Ammonite: person;	VAR		theShell: person;	BEGIN		WITH theShell DO			BEGIN				WOpening := 2;				DDisplacement := 0;				SShape := 1;				TTranslation := 0;				Coarsegraininess := 8;				reach := 3;				GeneratingCurve := 0;				Handedness := 1;				TranslationGradient := 1;			END;		Ammonite := theShell;	END;FUNCTION Nautilus: person;	VAR		theShell: person;	BEGIN		WITH theShell DO			BEGIN				WOpening := 3.4;				DDisplacement := 0;				SShape := 1.2;				TTranslation := 0;				Coarsegraininess := 8;				reach := 3;				GeneratingCurve := 0;				Handedness := 1;				TranslationGradient := 1;			END;		Nautilus := theShell;	END;FUNCTION Brachiopod: person;	VAR		theShell: person;	BEGIN		WITH theShell DO			BEGIN				WOpening := 10000;				DDisplacement := 0;				SShape := 1;				TTranslation := 0;				Coarsegraininess := 2;				reach := 3;				GeneratingCurve := 0;				Handedness := 1;				TranslationGradient := 1;			END;		Brachiopod := theShell;	END;FUNCTION Cone: person;	VAR		theShell: person;	BEGIN		WITH theShell DO			BEGIN				WOpening := 1.66;				DDisplacement := 0;				SShape := 3;				TTranslation := 3.5;				Coarsegraininess := 2;				reach := 3;				GeneratingCurve := 128;				Handedness := 1;				TranslationGradient := 1;			END;		Cone := theShell;	END;FUNCTION Whelk: person;	VAR		theShell: person;	BEGIN		WITH theShell DO			BEGIN				WOpening := 1.7;				DDisplacement := 0;				SShape := 2;				TTranslation := 4;				Coarsegraininess := 2;				reach := 6;				GeneratingCurve := 128;				Handedness := 1;				TranslationGradient := 1;			END;		Whelk := theShell;	END;FUNCTION Scallop: person;	VAR		theShell: person;	BEGIN		WITH theShell DO			BEGIN				WOpening := 10000;				DDisplacement := 0;				SShape := 1;				TTranslation := 0;				Coarsegraininess := 2;				reach := 3;				GeneratingCurve := 148;				Handedness := 1;				TranslationGradient := 1;			END;		Scallop := theShell;	END;FUNCTION Eloise: person;	VAR		theShell: person;	BEGIN		WITH theShell DO			BEGIN				WOpening := 1.4;				DDisplacement := 0;				SShape := 1.7;				TTranslation := 3.5;				Coarsegraininess := 4;				reach := 6;				GeneratingCurve := 146;				Handedness := 1;				TranslationGradient := 1;			END;		Eloise := theShell;	END;FUNCTION Gallaghers: person;	VAR		theShell: person;	BEGIN		WITH theShell DO			BEGIN				WOpening := 1.66;				DDisplacement := 0;				SShape := 1.8;				TTranslation := 5;				Coarsegraininess := 4;				reach := 6;				GeneratingCurve := 136;				Handedness := -1;				TranslationGradient := 1;			END;		Gallaghers := theShell;	END;FUNCTION Rapa: person;	VAR		theShell: person;	BEGIN		WITH theShell DO			BEGIN				WOpening := 1.66;				DDisplacement := 0;				SShape := 2;				TTranslation := 2.2;				Coarsegraininess := 4;				reach := 9;				GeneratingCurve := 132;				Handedness := 1;				TranslationGradient := 1;			END;		Rapa := theShell;	END;FUNCTION Lightning: person;	VAR		theShell: person;	BEGIN		WITH theShell DO			BEGIN				WOpening := 1.66;				DDisplacement := 0;				SShape := 3.5;				TTranslation := 4;				Coarsegraininess := 4;				reach := 6;				GeneratingCurve := 150;				Handedness := -1;				TranslationGradient := 0.9;			END;		Lightning := theShell;	END;FUNCTION Sundial: person;	VAR		theShell: person;	BEGIN		WITH theShell DO			BEGIN				WOpening := 1.384;				DDisplacement := 0.261;				SShape := 0.618;				TTranslation := 1.055;				Coarsegraininess := 2;				reach := 10;				GeneratingCurve := 152;				Handedness := 1;				TranslationGradient := 1;			END;		Sundial := theShell;	END;FUNCTION Fig: person;	VAR		theShell: person;	BEGIN		WITH theShell DO			BEGIN				WOpening := 2;				DDisplacement := 0;				SShape := 3;				TTranslation := 3.5;				Coarsegraininess := 2;				reach := 8;				GeneratingCurve := 134;				Handedness := 1;				TranslationGradient := 0.95;			END;		Fig := theShell;	END;FUNCTION Tun: person;	VAR		theShell: person;	BEGIN		WITH theShell DO			BEGIN				WOpening := 2;				DDisplacement := 0;				SShape := 2;				TTranslation := 2.8;				Coarsegraininess := 2;				reach := 8;				GeneratingCurve := 134;				Handedness := 1;				TranslationGradient := 1;			END;		Tun := theShell;	END;FUNCTION RazorShell: person;	VAR		theShell: person;	BEGIN		WITH theShell DO			BEGIN				WOpening := 1000;				DDisplacement := 0;				SShape := 8;				TTranslation := 6;				MutProb := 50;				Coarsegraininess := 2;				reach := 1;				GeneratingCurve := 138;				Handedness := 1;				TranslationGradient := 1;			END;		RazorShell := theShell;	END;FUNCTION JapaneseWonder: person;	VAR		theShell: person;	BEGIN		WITH theShell DO			BEGIN				WOpening := 1.7;				DDisplacement := 0;				SShape := 1.3;				TTranslation := 4.2;				MutProb := 50;				Coarsegraininess := 2;				reach := 8;				GeneratingCurve := 130;				Handedness := 1;				TranslationGradient := 1;			END;		JapaneseWonder := theShell;	END;PROCEDURE RealToString (r: real; VAR theString: str255);	VAR		f: DecForm;		s: DecStr;	BEGIN		f.style := FixedDecimal;		f.digits := 2;		Num2Str(f, r, s);		theString := str255(s);	END;FUNCTION StringToReal (s: str255): real;	BEGIN		StringToReal := Str2Num(DecStr(s));	END;FUNCTION TwoToThe (n: integer): integer;	VAR		t: integer;	BEGIN		CASE n OF			0: 				t := 1;			1: 				t := 2;			2: 				t := 4;			3: 				t := 8;			4: 				t := 16;			5: 				t := 32;			6: 				t := 64;			7: 				t := 128;			8: 				t := 256;			9: 				t := 512;			10: 				t := 1024;			11: 				t := 2048;			12: 				t := 4096;			OTHERWISE				t := 8192		END; {cases}		TwoToThe := t	END; {TwoToThe}FUNCTION TrapAvailable (theTrap: Integer): Boolean;	VAR		tType: TrapType;		numToolBoxTraps: Integer;	BEGIN 		(* first determine the trap type *)		IF BAND(theTrap, $0800) > 0 THEN			tType := ToolTrap		ELSE			tType := OSTrap; 		(* next find out how may traps there are *)		IF NGetTrapAddress(_InitGraf, ToolTrap) = NGetTrapAddress($AA6E, ToolTrap) THEN			numToolBoxTraps := $200		ELSE			numToolBoxTraps := $400; 		(* check if trap number is too big for current trap table *)		IF tType = ToolTrap THEN			BEGIN				theTrap := BAND(theTrap, $07FF);				IF theTrap >= numToolBoxTraps THEN					theTrap := _Unimplemented;			END; 		(* the trap is implemented if its address is different 	*) 		(* from the unimplemented trap's address				*)		TrapAvailable := NGetTrapAddress(theTrap, tType) <> NGetTrapAddress(_Unimplemented, ToolTrap);	END;{****************************************************}{ WNEIsImplemented}{}{ 	See if WaitNextEvent is implemented }{}{****************************************************}FUNCTION WNEIsImplemented: Boolean;	CONST		_WaitNextEvent = $A860;					{ WaitNextEvent trap					}	VAR		theWorld: SysEnvRec;						{ System environment				}		errCode: OSErr;	BEGIN		errCode := SysEnvirons(1, theWorld);		{ Check environment					}		IF theWorld.machineType < 0 THEN 			{ Old ROMs, definitely not present	}			WNEIsImplemented := FALSE		ELSE											{ Check for WNE trap					}			WNEIsImplemented := TrapAvailable(_WaitNextEvent)	END;{****************************************************}{ TempMemCallsAvailable}{}{ 	Check whether the MultiFinder temporary memory calls are available}{}{****************************************************}FUNCTION TempMemCallsAvailable: Boolean;	CONST		_OSDispatch = $A88F;						{ Temporary MF memory calls		}	BEGIN						{ Check for the OSDispatch trap	}		TempMemCallsAvailable := TrapAvailable(_OSDispatch);	END;{*	Dialog Manager utilities	*}{****************************************************}{ PositionDialog}{}{		Center the bounding box of a dialog or alert in the upper third}{		of the screen.  This is the preferred location according to the}{		Human Interface Guidelines.}{}{****************************************************}PROCEDURE PositionDialog (theType: ResType; theID: integer);	VAR		theRect: Rect;		theRectPtr: RectPtr;		{ Ptr to bounding box of dialog	}		theTemplate: Handle;		{ Handle to resource template	}		left,							{ Left side of centered rect		}		top: integer;				{ Top side of centered rect		}	BEGIN		{ The first field of the resource template for DLOG's and ALRT's 	}		{ is its bounding box.  Get a pointer to this rectangle.  This   			}		{ handle dereferencing is safe since the remaining statements in 	}		{ this function do not move memory (assignment and simple math). 	}		theTemplate := GetResource(theType, theID);		IF resError <> noErr THEN			Exit(PositionDialog);	{If we fail to load it, forget about positioning}		theRectPtr := RectPtr(theTemplate^);		theRect := theRectPtr^;		IF (theRect.left >= theRect.right) OR (theRect.top >= theRect.bottom) THEN			Exit(PositionDialog); {Position Dialog is creating problems that I don't understand.  RD}{e.g. theRect can have a left bigger than its right}		{ Center horizontally on screen	}		left := (screenBits.bounds.right - (theRect.right - theRect.left)) DIV 2;		{ Leave twice as much space as above	 }		top := (screenBits.bounds.bottom - (theRect.bottom - theRect.top)) DIV 3;		{ Don't put rect under menu bar	}		IF top < GetMBarHeight + 7 THEN			top := GetMBarHeight + 7;		theRect.right := theRect.right + left - theRect.left;		theRect.left := left;		theRect.bottom := theRect.bottom + top - theRect.top;		theRect.top := top;		theRectPtr^ := theRect;	END;{****************************************************}{ FindDLOGPosition}{}{ 		Return the coordinates of the top left corner of a dialog or alert}{ 		which centers the box in the upper third of the main screen. This is}{ 		the preferred location according to the Human Interface Guidelines.}{}{****************************************************}PROCEDURE FindDlogPosition (theType: ResType; theID: integer; VAR corner: Point);	TYPE		RectPtr = ^Rect;		RectHandle = ^RectPtr;	VAR		theRect: Rect;		{ Bounding box of dialog				}		left, top: integer;	{ Left, top side of centered rect		}	BEGIN		{ The first field of the resource template for DLOG's and ALRT's 	}		{ is its bounding box.  Access this rectangle.  This   					}		{ handle dereferencing is safe since the remaining statements in 	}		{ this function do not move memory (assignment and simple math). 	}		theRect := RectHandle(GetResource(theType, theID))^^;		{ Center horizontally on screen	}		corner.h := (screenBits.bounds.right - (theRect.right - theRect.left)) DIV 2;		{ Leave twice as much space as above	 }		corner.v := (screenBits.bounds.bottom - (theRect.bottom - theRect.top)) DIV 3;		{ Don't put rect under menu bar	}		IF corner.v < GetMBarHeight + 7 THEN			corner.v := GetMBarHeight + 7;	END;FUNCTION PICTFilter (param: ParmBlkPtr): Boolean;	VAR		Wanted: Boolean;	BEGIN		Wanted := (param^.ioFlFndrInfo.fdCreator = 'SCRN');		PICTFilter := Wanted	END;PROCEDURE ImportPICT;	VAR		PICTFileNum: Integer;		j: Integer;		ErrorCode, readErr: OSErr;		TheBiomorph: Person;		MyReply: SFReply;		myFileTypes: SFTypeList;		MyPoint: Point;		VRefNum: Integer;		dirID, procID: LongInt;		bytesToRead: LongInt;		thePict: PicHandle;	BEGIN		FindDlogPosition('DLOG', sfGetDialogID, MyPoint);			{Calculate the position on screen}		MyFileTypes[0] := 'PICT';		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		SFGetFile(MyPoint, '', @PICTFilter, -1, myFileTypes, NIL, MyReply);		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		IF (MyReply.good) THEN			BEGIN				PICTFileNum := OpenResFile(MyReply.fName);				thePict := GetPicture(0);				bytestoread := sizeof(thePict^^);				DrawPicture(thePict, thePict^^.PicFrame);			END	END;PROCEDURE DeleteOldFile (volRefNum: Integer; dirID: LongInt; fileName: Str255);{If there was a crash, the fossil file may be present but busy. We need to convince the }{finder that it is okay to delete it}	VAR		info: CInfoPBRec;		info2: ParamBlockRec;		err: OSErr;	BEGIN		WITH info DO			BEGIN				ioCompletion := NIL;				ioNamePtr := @fileName;				ioDirID := dirID;				ioVRefNum := volRefNum;				ioFDirIndex := 0;				err := PBGetCatInfo(@info, FALSE);				IF err = noErr THEN		{if it exists}					BEGIN						IF ioFRefNum <> 0 THEN   {File has been left open}							BEGIN								info2.ioCompletion := NIL;								info2.ioRefNum := ioFRefNum;								err := PBClose(@info2, FALSE);							END;						err := HDelete(volRefNum, dirID, fileName);					END;{if}			END;{with}	END;{DeleteOldFile}FUNCTION IsEOF (refNum: Integer; howClose: LongInt): Boolean;{Acts like Pascal's eof() function, but in addition you can specify how close to the end of the file}{you are allowed to be (takes care of truncated files)}	VAR		err: OSErr;		eof, positionNow: LongInt;	BEGIN		IsEOF := TRUE;		err := GetFPos(refNum, positionNow);		err := GetEOF(refNum, eof);		IF err <> noErr THEN			Exit(IsEOF);		{If something went wrong, we should stop reading}		IsEOF := (eof - positionNow) < howClose	END;FUNCTION FileSize (refNum: Integer): LongInt;	VAR		err: OSErr;		numBytes: LongInt;	BEGIN		err := GetEOF(refnum, numBytes);		IF err <> noErr THEN			numBytes := 0;	{Problem with the file, should signal an exception here.}		FileSize := numBytes;	END;{***** End of v1.1 additions*****}FUNCTION FossilsExist: Boolean;{replace, but not precisely mimic, Turbo's built-in function}	VAR		Err: OSErr;		filePos: LongInt;	BEGIN		Err := GetFPos(slides, FilePos);		FossilsExist := FilePos > 0	END; {FossilsExist}PROCEDURE DireMessage (string1ID, string2ID: Integer; VAR Verdict: Integer; YesNo: Boolean);{v1.1 changed DLOGs to ALRTs.}{}	VAR		theItem: Integer;		MessagePtr: DialogPtr;		string1, string2: Str255;	BEGIN		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		GetIndString(string1, kAlertStringsID, string1ID);		GetIndString(string2, kAlertStringsID, string2ID);		ParamText(string1, string2, '', '');		IF YesNo THEN			BEGIN				IF gSystem.systemVersion < $0700 THEN		{added v1.1}					PositionDialog('ALRT', 151);					{Save changes alert. YesNo?}				theItem := CautionAlert(151, NIL);			END		ELSE			BEGIN				IF gSystem.systemVersion < $0700 THEN		{added v1.1}					PositionDialog('ALRT', 17089);				theItem := CautionAlert(17089, NIL);			END; { get dialog box}		Verdict := theItem;		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		FlushEvents(EveryEvent, 0);		ValidRect(Prect);	END; { of proc DireMessage }PROCEDURE MemoryMessage (ID: Integer; InMessage: Str255; VAR Verdict: Integer); {27291 for Fewer album screens, 27295 for Careful}{*** Change this to handle appropriate type alerts with strings from STR# ***}{ v1.1 changed to alerts, position correctly on screen,}{ ID 4405 (got to quit) message changed to DisplayError call}	VAR		theItem: Integer;		MessagePtr: DialogPtr;	BEGIN		SetCursor(CursList[CrossCursor]^^);		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		IF (ID = 27295) THEN			InMessage := '';		ParamText('', InMessage, '', '');		IF gSystem.systemVersion < $0700 THEN		{added v1.1}			PositionDialog('ALRT', ID);		theItem := CautionAlert(ID, NIL);		Verdict := theItem;		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		FlushEvents(EveryEvent, 0);		ValidRect(Prect);	END; {MemoryMessage}PROCEDURE SimpleMessage (ID: Integer; VAR Verdict: Integer);{v1.1 redesigned the alert slightly and made it a Caution Alert. This procedure}{seems to be always called with the same string ID. If more are added, the alert}{may need to be made less specific}	VAR		S: Stringhandle;	BEGIN		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		S := GetString(ID);		ParamText(S^^, '', '', '');		IF gSystem.systemVersion < $0700 THEN		{added v1.1}			PositionDialog('ALRT', 17089);		verdict := CautionAlert(17089, NIL);	{changed v1.1}		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		FlushEvents(EveryEvent, 0);		ValidRect(Prect);	END; {SimpleMessage}PROCEDURE HelpMessage (StrID: Integer);	VAR		HelpPtr: dialogPtr;		theItem, v: Integer;		S1, S2, S3, S4: Str255;	BEGIN		GetIndString(S1, StrID, 1);		GetIndString(S2, StrID, 2);		GetIndString(S3, StrID, 3);		GetIndString(S4, StrID, 4);		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		ParamText(S1, S2, S3, S4);		IF gSystem.systemVersion < $0700 THEN		{added v1.1}			PositionDialog('DLOG', 2000);		HelpPtr := GetNewDialog(2000, NIL, Pointer(-1));		ModalDialog(NIL, theItem);             { put dialog box up; get result }		DisposDialog(HelpPtr);               { get rid of dialog box         }  {ReStoreOffScreen(MainPtr^.PortRect,MyBitMap);}		FlushEvents(EveryEvent, 0);		ValidRect(Prect);	END; { of proc HelpMessage }FUNCTION stripped (s: str255): str255;{removes  spaces after number, for StringToNum}	VAR		j, n: integer;	BEGIN		n := length(s);		j := pos(' ', s);		IF j = 0 THEN			stripped := s		ELSE			BEGIN				delete(s, j, 1);				stripped := stripped(s)			END;	END; {stripped}FUNCTION LayoutDialog (VAR HoldConstant, RowChap, ColChap: MarchingOrders; VAR NRows, NCols: Integer): boolean;	CONST		LayoutDLogID = 135;	TYPE		placetype = (row, col);	VAR		theDialog: dialogPtr;		theItem, v: Integer;		S1, S2, S3, S4: Str255;		tempRect: Rect;   												{Temporary rectangle}		DType: Integer;    												{Type of dialog item}		Index: Integer;     												{For looping}		DItem: Handle;     												{Handle to the dialog item}		CItem, CTempItem, PItem: controlhandle; 							{Control handle}		sTemp: Str255;   												{Get text entered, temp holding}		itemHit: Integer;  												{Get selection}		temp: Integer; 													{Get selection, temp holding}		ExitCondition: Boolean;		SmallPicture: PicHandle;		SavePort: WindowPtr;		rChap, cChap, hChap, WChap, DChap, TChap: MarchingOrders;	PROCEDURE Deposit (contents: integer; DITLNo: integer);		BEGIN			GetDItem(theDialog, DITLNo, DType, DItem, tempRect);{Get item handle}			NumToString(contents, sTemp);			SetIText(DItem, sTemp);		END;	PROCEDURE DepositString (contents: str255; DITLNo: integer);		BEGIN			GetDItem(theDialog, DITLNo, DType, DItem, tempRect);{Get item handle}			SetIText(DItem, contents);		END;	PROCEDURE Advance (place: placetype; VAR theChap: MarchingOrders);		VAR			s: str255;			theTill: real;			outchap: MarchingOrders;		BEGIN			WITH theChap DO				CASE kind OF					Wop: 						BEGIN							outChap := DChap;							s := 'D';							theTill := 1 + DDetails.till / DDetails.by;						END;					Dis: 						BEGIN							outChap := TChap;							s := 'T';							theTill := 1 + TDetails.till / TDetails.by;						END;					Trans: 						BEGIN							outChap := WChap;							s := 'W';							theTill := WDetails.till;						END;				END; {cases}			theChap := outChap;			CASE place OF				row: 					BEGIN						DepositString(s, 10);						Deposit(round(theTill), 12);					END;				col: 					BEGIN						DepositString(s, 9);						Deposit(round(theTill), 8);					END;			END; {cases}		END; {advance}	PROCEDURE RefreshDialogue;		BEGIN     												{Start of Refresh dialog}			DChap := HoldConstant;			WChap := RowChap;			TChap := colChap;			hChap := HoldConstant;			rChap := rowChap;			cChap := colChap;			advance(row, rchap);			advance(row, rchap);			advance(row, rchap);			advance(col, cChap);			advance(col, cChap);			advance(col, cChap);			DepositString('D', 14);		END; {RefreshDialog}   															{End of procedure}	PROCEDURE ExitDialogue;		VAR			tempRect: Rect;   												{Temporary rectangle}			DType: Integer;    												{Type of dialog item}			Index: Integer;     												{For looping}			DItem: Handle;     												{Handle to the dialog item}			CItem, CTempItem: controlhandle; 							{Control handle}			sTemp: Str255;   												{Get text entered, temp holding}			itemHit: Integer;  												{Get selection}			temp: Integer; 													{Get selection, temp holding}			LI: LongInt;		FUNCTION fetch (DITLNo: integer): integer;			VAR				f: LongInt;			BEGIN				GetDItem(theDialog, DITLNo, DType, DItem, tempRect);{Get item handle}				GetIText(DItem, sTemp);    							{Get the text entered}				sTemp := stripped(sTemp);				StringToNum(sTemp, f);				fetch := f;			END;		BEGIN			rowChap := rChap;			colChap := cChap;			NRows := fetch(12);			NCols := Fetch(8);			CASE rowChap.kind OF				Wop: 					CASE colChap.kind OF						Dis: 							HoldConstant.Kind := Trans;						Trans: 							HoldConstant.Kind := Dis;					END;				Dis: 					CASE colChap.kind OF						Wop: 							HoldConstant.Kind := Trans;						Trans: 							HoldConstant.Kind := Wop;					END;				Trans: 					CASE colChap.kind OF						Wop: 							HoldConstant.Kind := Dis;						Dis: 							HoldConstant.Kind := Wop;					END;			END; {cases}		END; {ExitDialogue}	BEGIN {Main LayoutDialog}		IF gSystem.systemVersion < $0700 THEN		{added v1.1}			PositionDialog('DLOG', LayoutDLogID);		theDialog := GetNewDialog(LayoutDLogID, NIL, Pointer(-1));		RefreshDialogue;		ExitCondition := false;		REPEAT			ModalDialog(NIL, ItemHit);             { put dialog box up; get result }			ExitCondition := (ItemHit = 1) OR (ItemHit = 2);			IF ItemHit = 5 THEN				Advance(col, cChap);			IF ItemHit = 6 THEN				Advance(row, rChap);			IF cChap.kind = rChap.kind THEN				DepositString('', 14)			ELSE				BEGIN					CASE rChap.kind OF						Wop: 							CASE cChap.kind OF								Dis: 									DepositString('T', 14);								Trans: 									DepositString('D', 14);							END; {cases}						Dis: 							CASE cChap.kind OF								Wop: 									DepositString('T', 14);								Trans: 									DepositString('W', 14);							END; {cases}						Trans: 							CASE cChap.kind OF								Wop: 									DepositString('D', 14);								Dis: 									DepositString('W', 14);							END; {cases}					END; {cases}				END;			IF (ItemHit = 1) AND (cChap.kind = rChap.kind) THEN				BEGIN					ExitCondition := false;				END;		UNTIL ExitCondition;		IF ItemHit = 1 THEN			ExitDialogue;		DisposDialog(theDialog);               { get rid of dialog box         }		FlushEvents(EveryEvent, 0);		LayoutDialog := (ItemHit = 1);	END; {LayoutDialog}FUNCTION GenesDialog: Boolean;	VAR		GenesDlogPtr: dialogPtr;		theItem, v: Integer;		S1, S2, S3, S4: Str255;		tempRect: Rect;   												{Temporary rectangle}		DType: Integer;    												{Type of dialog item}		Index: Integer;     												{For looping}		DItem: Handle;     												{Handle to the dialog item}		CItem, CTempItem, PItem: controlhandle; 							{Control handle}		sTemp: Str255;   												{Get text entered, temp holding}		itemHit: Integer;  												{Get selection}		temp: Integer; 													{Get selection, temp holding}		ExitDialog: Boolean;		SmallPicture: PicHandle;		SavePort: WindowPtr;		GenCurve: integer;	PROCEDURE D_Refresh_Timing_Dialogue (theDialog: DialogPtr);		VAR			tempRect: Rect;   												{Temporary rectangle}			DType: Integer;    												{Type of dialog item}			Index: Integer;     												{For looping}			DItem: Handle;     												{Handle to the dialog item}			CItem, CTempItem: controlhandle; 							{Control handle}			sTemp: Str255;   												{Get text entered, temp holding}			itemHit: Integer;  												{Get selection}			temp: Integer; 													{Get selection, temp holding}			SavePort: WindowPtr;			SmallPicture: PicHandle;		BEGIN     												{Start of Refresh dialog}			WITH child[special] DO				BEGIN					GetDItem(theDialog, 3, DType, DItem, tempRect);{Get item handle}					RealToString(WOpening, sTemp);					SetIText(DItem, sTemp);					GetDItem(theDialog, 4, DType, DItem, tempRect);{Get item handle}					RealToString(DDisplacement, sTemp);					SetIText(DItem, sTemp);					GetDItem(theDialog, 5, DType, DItem, tempRect);{Get item handle}					RealToString(SShape, sTemp);					SetIText(DItem, sTemp);					GetDItem(theDialog, 6, DType, DItem, tempRect);{Get item handle}					RealToString(TTranslation, sTemp);					SetIText(DItem, sTemp);					GetDItem(theDialog, 8, DType, DItem, tempRect);{Get item handle}					NumToString(CoarseGraininess, sTemp);					SetIText(DItem, sTemp);					GetDItem(theDialog, 9, DType, DItem, tempRect);{Get item handle}					NumToString(reach, sTemp);					SetIText(DItem, sTemp);					GetDItem(theDialog, 10, DType, DItem, tempRect);{Get item handle}					RealToString(TranslationGradient, sTemp);					SetIText(DItem, sTemp);					GetDItem(theDialog, 21, DType, DItem, tempRect);{Get item handle}					RealToString(MutProb, sTemp);					SetIText(DItem, sTemp);					IF GeneratingCurve > 0 THEN						SmallPicture := GetPicture(GeneratingCurve);					GetDItem(theDialog, 25, DType, DItem, temprect);					GetPort(SavePort);					SetPort(theDialog);					EraseRect(Temprect);					IF GeneratingCurve > 0 THEN						DrawPicture(SmallPicture, temprect)					ELSE						FrameOval(temprect);					SetPort(SavePort);					GetDItem(theDialog, 27, DType, DItem, tempRect);{Get item handle}					NumToString(Threshold, sTemp);					SetIText(DItem, sTemp);{Now set radio buttons appropriately}					GetDitem(theDialog, 18, Dtype, DItem, temprect);					CItem := Pointer(DItem);					IF Handedness = -1 THEN						SetCtlValue(Citem, 1)					ELSE						SetCtlValue(Citem, 0);					GetDitem(theDialog, 19, Dtype, DItem, temprect);					CItem := Pointer(DItem);					IF Handedness = 1 THEN						SetCtlValue(Citem, 1)					ELSE						SetCtlValue(Citem, 0);				END;		END;   															{End of procedure}	PROCEDURE D_Exit_Timing_Dialogue (theDialog: DialogPtr; GenCurve: integer);		VAR			tempRect: Rect;   												{Temporary rectangle}			DType: Integer;    												{Type of dialog item}			Index: Integer;     												{For looping}			DItem: Handle;     												{Handle to the dialog item}			CItem, CTempItem: controlhandle; 							{Control handle}			sTemp: Str255;   												{Get text entered, temp holding}			itemHit: Integer;  												{Get selection}			temp: Integer; 													{Get selection, temp holding}			LI: LongInt;		BEGIN     												{Start of Exit dialog}			WITH child[special] DO				BEGIN					GetDItem(theDialog, 3, DType, DItem, tempRect);{Get item handle}					GetIText(DItem, sTemp);    							{Get the text entered}					sTemp := stripped(sTemp);					WOpening := StringToReal(sTemp);					GetDItem(theDialog, 4, DType, DItem, tempRect);{Get item handle}					GetIText(DItem, sTemp);    							{Get the text entered}					sTemp := stripped(sTemp);					DDisplacement := StringToReal(sTemp);					IF DDisplacement > 1 THEN						DDisplacement := 1;					IF DDisplacement < 0 THEN						DDisplacement := 0;					GetDItem(theDialog, 5, DType, DItem, tempRect);{Get item handle}					GetIText(DItem, sTemp);    							{Get the text entered}					sTemp := stripped(sTemp);					SShape := StringToReal(sTemp);					GetDItem(theDialog, 6, DType, DItem, tempRect);{Get item handle}					GetIText(DItem, sTemp);    							{Get the text entered}					sTemp := stripped(sTemp);					TTranslation := StringToReal(sTemp);					GetDItem(theDialog, 8, DType, DItem, tempRect);{Get item handle}					GetIText(DItem, sTemp);    							{Get the text entered}					sTemp := stripped(sTemp);					CoarseGraininess := round(StringToReal(sTemp));					GetDItem(theDialog, 9, DType, DItem, tempRect);{Get item handle}					GetIText(DItem, sTemp);    							{Get the text entered}					sTemp := stripped(sTemp);					reach := round(StringToReal(sTemp));					GeneratingCurve := Gencurve;					IF GeneratingCurve < 128 THEN						GeneratingCurve := 0;					GetDItem(theDialog, 10, DType, DItem, tempRect);{Get item handle}					GetIText(DItem, sTemp);    							{Get the text entered}					sTemp := stripped(sTemp);					TranslationGradient := StringToReal(sTemp);{IF TranslationGradient < 0 THEN}{TranslationGradient := 0;}					GetDItem(theDialog, 21, DType, DItem, tempRect);{Get item handle}					GetIText(DItem, sTemp);    							{Get the text entered}					sTemp := stripped(sTemp);					MutProb := StringToReal(sTemp);					IF MutProb <= 0 THEN						MutProb := 0;					IF MutProb >= 100 THEN						MutProb := 100;					GetDItem(theDialog, 27, DType, DItem, tempRect);{Get item handle}					GetIText(DItem, sTemp);    							{Get the text entered}					sTemp := stripped(sTemp);					Threshold := round(StringToReal(sTemp));{Now register state of radio buttons}					GetDitem(theDialog, 18, Dtype, DItem, temprect);					CItem := Pointer(DItem);					IF GetCtlValue(CItem) = 1 THEN						Handedness := -1					ELSE						Handedness := 1; {Only need to look at one radio button as the other must be opposite}				END;		END; 													{End of procedure}	PROCEDURE DrawTheIcon;		BEGIN			SmallPicture := GetPicture(GenCurve);			GetDItem(GenesDLogPtr, 25, DType, DItem, temprect);			GetPort(SavePort);			SetPort(GenesDLogPtr);			EraseRect(Temprect);			IF GenCurve = 0 THEN				FrameOval(TempRect)			ELSE				DrawPicture(SmallPicture, temprect);			SetPort(SavePort);		END;	BEGIN		IF gSystem.systemVersion < $0700 THEN		{added v1.1}			PositionDialog('DLOG', GenesDLogID);		GenesDlogPtr := GetNewDialog(GenesDLogID, NIL, Pointer(-1));		D_Refresh_Timing_Dialogue(GenesDLogPtr);		ExitDialog := false;		GenCurve := child[special].GeneratingCurve;		REPEAT			ModalDialog(NIL, ItemHit);             { put dialog box up; get result }{Have we hit OK or a Radio Button?}			IF (ItemHit = 1) OR (ItemHit = 24) THEN {OK or Cancel}				ExitDialog := true;			IF ItemHit = 29 THEN {increase Generating Curve}				BEGIN					IF GenCurve = 0 THEN						GenCurve := 126; {2 less than 128}					GenCurve := Gencurve + 2; {advance to next non-mirrored PICT ID}					IF GenCurve > MaxResources THEN						GenCurve := 0;					DrawTheIcon;				END;			IF ItemHit = 28 THEN {decrease Generating Curve}				BEGIN					IF GenCurve = 0 THEN						GenCurve := MaxResources + 2; {2 more than 128}					GenCurve := Gencurve - 2; {advance to next non-mirrored PICT ID}					IF GenCurve < 128 THEN						GenCurve := 0;					DrawTheIcon;				END;			GetDItem(GenesDLogPtr, ItemHit, DType, DItem, temprect);			CItem := Pointer(DItem);			IF ItemHit = 18 THEN {left-handed}				BEGIN					SetCtlValue(CItem, 1);					GetDItem(GenesDLogPtr, 19, DType, DItem, temprect);					CItem := Pointer(DItem);					SetCtlValue(CItem, 0);				END;			IF ItemHit = 19 THEN {right-handed}				BEGIN					SetCtlValue(CItem, 1);					GetDItem(GenesDLogPtr, 18, DType, DItem, temprect);					CItem := Pointer(DItem);					SetCtlValue(CItem, 0);				END;		UNTIL ExitDialog;		IF ItemHit = 1 THEN			D_Exit_Timing_Dialogue(GenesDLogPtr, Gencurve);		DisposDialog(GenesDlogPtr);               { get rid of dialog box         }		FlushEvents(EveryEvent, 0);		GenesDialog := ItemHit = 1;	END; {GenesDialog}PROCEDURE SyringeMessage;{v1.1 Changed to alert, and set the first two alert stages to simple beeps}	VAR		SyrPtr: dialogPtr;		theItem: Integer;	BEGIN		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		IF gSystem.systemVersion < $0700 THEN		{added v1.1}			PositionDialog('ALRT', 30130);		theItem := Alert(30130, NIL);		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		FlushEvents(EveryEvent, 0);		ValidRect(Prect);	END; { of proc SyringeMessage }PROCEDURE ArrayDialog (VAR WDetails, DDetails, TDetails: MarchingOrders; VAR Verdict: integer);	CONST		ArrayDLogID = 134;	VAR		theDialog: dialogPtr;		theItem, v: Integer;		S1, S2, S3, S4: Str255;		tempRect: Rect;   												{Temporary rectangle}		DType: Integer;    												{Type of dialog item}		Index: Integer;     												{For looping}		DItem: Handle;     												{Handle to the dialog item}		CItem, CTempItem, PItem: controlhandle; 							{Control handle}		sTemp: Str255;   												{Get text entered, temp holding}		itemHit: Integer;  												{Get selection}		temp: Integer; 													{Get selection, temp holding}		ExitDialog: Boolean;		SmallPicture: PicHandle;		SavePort: WindowPtr;		GenCurve: integer;	PROCEDURE RefreshDialogue;		VAR			tempRect: Rect;   												{Temporary rectangle}			DType: Integer;    												{Type of dialog item}			Index: Integer;     												{For looping}			DItem: Handle;     												{Handle to the dialog item}			CItem, CTempItem: controlhandle; 							{Control handle}			sTemp: Str255;   												{Get text entered, temp holding}			itemHit: Integer;  												{Get selection}			temp: Integer; 													{Get selection, temp holding}			SavePort: WindowPtr;			SmallPicture: PicHandle;		PROCEDURE Deposit (contents: real; DITLNo: integer);			BEGIN				GetDItem(theDialog, DITLNo, DType, DItem, tempRect);{Get item handle}				RealToString(contents, sTemp);				SetIText(DItem, sTemp);			END;		BEGIN     												{Start of Refresh dialog}			WITH WDetails DO				BEGIN					deposit(start, 3);					deposit(till, 4);					deposit(by, 5);				END;			WITH DDetails DO				BEGIN					deposit(start, 9);					deposit(till, 10);					deposit(by, 11);				END;			WITH TDetails DO				BEGIN					deposit(start, 15);					deposit(till, 16);					deposit(by, 17);				END;		END; {RefreshDialogue}   															{End of procedure}	PROCEDURE ExitDialogue;		VAR			tempRect: Rect;   												{Temporary rectangle}			DType: Integer;    												{Type of dialog item}			Index: Integer;     												{For looping}			DItem: Handle;     												{Handle to the dialog item}			CItem, CTempItem: controlhandle; 							{Control handle}			sTemp: Str255;   												{Get text entered, temp holding}			itemHit: Integer;  												{Get selection}			temp: Integer; 													{Get selection, temp holding}			LI: LongInt;		FUNCTION fetch (DITLNo: integer): real;			BEGIN				GetDItem(theDialog, DITLNo, DType, DItem, tempRect);{Get item handle}				GetIText(DItem, sTemp);    							{Get the text entered}				sTemp := stripped(sTemp);				Fetch := StringToReal(sTemp);			END;		BEGIN     												{Start of Exit dialog}			WITH WDetails DO				BEGIN					start := fetch(3);					till := fetch(4);					by := fetch(5);					kind := Wop;				END;			WITH DDetails DO				BEGIN					start := fetch(9);					till := fetch(10);					by := fetch(11);					kind := Dis;				END;			WITH TDetails DO				BEGIN					start := fetch(15);					till := fetch(16);					by := fetch(17);					kind := Trans;				END;		END; {ExitDialogue} 													{End of procedure}	BEGIN		IF gSystem.systemVersion < $0700 THEN		{added v1.1}			PositionDialog('DLOG', ArrayDLogID);		theDialog := GetNewDialog(ArrayDLogID, NIL, Pointer(-1));		RefreshDialogue;		REPEAT			ModalDialog(NIL, ItemHit);             { put dialog box up; get result }		UNTIL (ItemHit = 1) OR (ItemHit = 2) OR (ItemHit = 21);		IF ItemHit <= 2 THEN			ExitDialogue;		DisposDialog(theDialog);               { get rid of dialog box         }		FlushEvents(EveryEvent, 0);		Verdict := ItemHit;	END; {ArrayDialog}PROCEDURE Pause (Message: Str255);	BEGIN		IF Button THEN			REPEAT			UNTIL NOT Button; {Gotoxy(5,5); Writeln(message);}		REPEAT		UNTIL Button	END;PROCEDURE SetItemState (Mndx, Indx: Integer; Flag: Boolean);{}{    purpose         if true, enables item Indx of menu Mndx; else disables}{    last update     22 Aug 86}{}	BEGIN		IF Flag THEN			EnableItem(MenuList[Mndx], Indx)		ELSE			DisableItem(MenuList[Mndx], Indx)	END; { of proc SetItemState }FUNCTION RandInt (Max: Integer): Integer;	BEGIN		randint := 1 + (abs(random) MOD max);	END; {randint}FUNCTION Odd (i: Integer): Boolean;	BEGIN		Odd := 2 * (i DIV 2) <> i	END;FUNCTION RandSwell (Indgene: Swelltype): SwellType;	VAR		r: 1..3;	BEGIN		CASE Indgene OF			Shrink: 				Randswell := Same;			Same: 				IF randint(2) = 1 THEN					Randswell := Shrink				ELSE					Randswell := Swell;			Swell: 				RandSwell := Same		END {Cases}	END; {RandSwell}PROCEDURE EraseInnerRect (box: Rect);	VAR		InnerRect: Rect;	BEGIN		WITH InnerRect DO			BEGIN				left := box.left + 1;				right := box.right - 1;				top := box.top + 1;				bottom := box.bottom - 1			END;		EraseRect(InnerRect)	END; {EraseInnerRect}PROCEDURE FrameOuterRect (box: Rect);	VAR		OuterRect: Rect;	BEGIN		WITH OuterRect DO			BEGIN				left := box.left - 1;				right := box.right + 1;				top := box.top - 1;				bottom := box.bottom + 1			END;		FrameRect(OuterRect)	END; {FrameOuterRect}PROCEDURE FrameInnerRect (box: Rect);	VAR		InnerRect: Rect;	BEGIN		WITH InnerRect DO			BEGIN				left := box.left + 1;				right := box.right - 1;				top := box.top + 1;				bottom := box.bottom - 1			END;		FrameRect(InnerRect)	END; {FrameInnerRect}PROCEDURE StoreOffScreen (box: Rect; VAR Snapshot: BitMap);	BEGIN		IF FrontWindow = MainPtr THEN			CopyBits(MainPtr^.PortBits, Snapshot, box, box, srcCopy, NIL);	END; {StoreOffScreen}PROCEDURE RestoreOffScreen (box: Rect; Snapshot: BitMap);	BEGIN {IF FrontWindow=MainPtr THEN}		CopyBits(Snapshot, MainPtr^.PortBits, box, box, srcCopy, NIL);		ValidRect(box);			{**v1.1 since we have redrawn it already, }{we can stop the update event which would cause the window to be redrawn twice}	END; {RestoreOffScreen}PROCEDURE CleanUp;{}{    purpose         to do whatever's needed before returning to Finder}{}	VAR		err: OSErr;	BEGIN		err := FSClose(Slides);		err := HDelete(volRefNum, dirID, fileName);	END; { of proc CleanUp }PROCEDURE MakeOffScreen (box: Rect; VAR Snapshot: BitMap; VAR Burst: Boolean);{From system 6 onwards we can use GWorlds instead of writing our own here - Alun}	VAR		bitsRowBytes, height: Integer;		ZeroRect: Rect;		tempPtr: Ptr;		SizeNeeded: LONGINT;	BEGIN		WITH box DO			BEGIN				height := bottom - top;				bitsRowBytes := (((right - left - 1) DIV 16) + 1) * 2;			END;		WITH ZeroRect DO			BEGIN				left := 0;				right := box.right - box.left;				top := 0;				bottom := height			END;		SizeNeeded := LONGINT(bitsRowBytes) * LONGINT(height);		IF (Memavail - SizeNeeded) < SafetyValve THEN			Burst := TRUE		ELSE			BEGIN				tempPtr := NewPtr(SizeNeeded);				IF MemError <> noErr THEN					BEGIN						Sysbeep(1);						ExitToShell;					END;   {No memory available}				Snapshot.baseaddr := tempPtr;				Snapshot.bounds := zerorect;				Snapshot.rowBytes := bitsRowBytes;				Burst := FALSE;			END;	END;{MakeOffScreen}PROCEDURE MirrorBits (SourceBitmap: BitMap; RectOfInterest: Rect; VAR DestBitMap: BitMap);{Delivers a BitMap whose RectOfInterest is the left-right mirror image of the same rect in SourceBitmap}{Assumes that the two bitmaps have already had space assigned to them and have the same dimensions but different pointers}	VAR		row, ColBit, ReverseColbit, nrows, RowOffset: integer;		BitsAcross: Longint;{needs to be Longint because of BitTst}		SourceBit: Boolean;		SrcRowBaseAddr, DstRowBaseAddr: Ptr;	BEGIN		WITH SourceBitMap DO			BEGIN				NRows := RectOfInterest.bottom - RectOfInterest.top;				BitsAcross := RectOfInterest.right - RectOfInterest.left;				FOR row := 1 TO NRows DO					BEGIN						RowOffset := rowbytes * (row - 1);						SrcRowBaseAddr := Ptr(Longint(BaseAddr) + RowOffset);						DstRowBaseAddr := Ptr(Longint(DestBitMap.BaseAddr) + RowOffset);						FOR colbit := 0 TO BitsAcross DO							BEGIN								ReverseColBit := BitsAcross - ColBit - 1;								SourceBit := BitTst(SrcRowBaseAddr, ColBit);								IF SourceBit THEN									BitSet(DstRowBaseAddr, ReverseColBit)								ELSE									BitClr(DstRowBaseAddr, ReverseColBit);							END;					END;			END	END; {MirrorBits}PROCEDURE DrawInt (i: Integer);	PROCEDURE Drawi (i: Integer);		VAR			l, r: Integer;		BEGIN			IF i <= 9 THEN				drawchar(chr(ord('0') + i))			ELSE				BEGIN					l := i DIV 10;					r := i - 10 * l;					drawi(l);					drawi(r);				END;		END; {drawi}	BEGIN {drawint proper}		IF i < 0 THEN			BEGIN				drawchar('-');				i := abs(i);			END		ELSE			Drawchar('+');		drawi(i);	END; {drawint}PROCEDURE DrawNumber (n: LongInt);	VAR		s: str255;	BEGIN		NumToString(n, s);		Drawstring(s);	END;PROCEDURE DrawReal (r: real);	VAR		numerator, remainder, den1, den2: LongInt;		theString: str255;	BEGIN		IF r < 0 THEN			BEGIN				DrawString('-');				r := -r			END;		numerator := trunc(r);		DrawNumber(numerator);		remainder := round(100 * (r - numerator));		Drawstring('.');		IF remainder < 10 THEN			BEGIN				den1 := 0;				den2 := remainder			END		ELSE			BEGIN				den1 := remainder DIV 10;				den2 := remainder - 10 * den1			END;		DrawNumber(den1);		DrawNumber(den2);	END;PROCEDURE Grow (VAR Box: Rect; d: Integer);	BEGIN		WITH box DO			BEGIN				left := left - d;				right := right + d;				top := top - d;				bottom := bottom + d;			END;	END; {grow}PROCEDURE BoxesOnly;	VAR		j: Integer;	BEGIN		FOR j := 1 TO NBoxes DO			FrameRect(box[j]);		theMode := preliminary;	END; {BoxesOnly}{PROCEDURE DrawNum(n:Integer);}{VAR s,c:CHAR;}{BEGIN IF n<0 THEN s:='-' ELSE s:='+';}{n:=abs(n); c:=chr(n+48);}{DrawChar(s); DrawChar(c)}{END} {DrawNum;} {This is where frillsegment used to begin}PROCEDURE OwnEditMenu;	BEGIN		SetItemState(EM, 1, FALSE);		SetItemState(EM, 2, FALSE);		SetItemState(EM, 3, FALSE);		SetItemState(EM, 4, (Special > 0) AND ((TheMode = Highlighting) OR (TheMode = Albuming)));		SetItemState(EM, 5, FALSE);		SetItemState(EM, 6, FALSE);	END; {OwnEditMenu}FUNCTION DawkFilter (param: ParmBlkPtr): Boolean;	VAR		Wanted: Boolean;	BEGIN		Wanted := (param^.ioFlFndrInfo.fdCreator = 'SNAW') AND (param^.ioFlFndrInfo.fdType <> 'APPL') AND (param^.ioFlFndrInfo.fdType <> 'FOSS');		DawkFilter := NOT Wanted	END;PROCEDURE SmallMenus;	VAR		Indx: Integer;	BEGIN		ClearMenuBar;		InsertMenu(MenuList[AM], 0);			 {This was commented out - Alun}		InsertMenu(SpecialBreedMenu, 0);		InsertMenu(MenuList[HM], 0);		DrawMenuBar;                   { draw updated menu bar to screen   }	END; {SmallMenus}PROCEDURE LargeMenus;	VAR		indx: Integer;	BEGIN		ClearMenuBar;		FOR Indx := 1 TO MenuCnt DO       { place menus in menu bar           }			InsertMenu(MenuList[Indx], 0);		OwnEditMenu;		DrawMenuBar;                   { draw updated menu bar to screen   }	END; {LargeMenus}PROCEDURE BigFuncBox (Box: Rect; VAR Outbox: Rect);	BEGIN		Outbox := box;		WITH Box DO			BEGIN				IF Bottom - Top > Right - Left THEN					BEGIN						Outbox.right := (Right + Left + Bottom - Top) DIV 2;						Outbox.left := outbox.right - (bottom - top)					END				ELSE					BEGIN						Outbox.bottom := (Top + Bottom + Right - Left) DIV 2;						Outbox.Top := Outbox.bottom - (right - left)					END			END;	END; {FuncBox}PROCEDURE SmallFuncBox (Box: Rect; VAR Outbox: Rect; BoxSize: Integer);	BEGIN		Outbox := box;		WITH Box DO			BEGIN				Outbox.Right := (Left + Right + BoxSize) DIV 2;				Outbox.left := Outbox.right - BoxSize;				Outbox.bottom := (top + bottom + Boxsize) DIV 2;				Outbox.top := Outbox.bottom - Boxsize			END;	END; {SmallFuncBox}PROCEDURE FuncBox (Box: Rect; VAR Outbox: Rect; BoxSize: Integer);	BEGIN		WITH Box DO			IF ((Right - Left) > BoxSize) OR ((Bottom - Top) > Boxsize) THEN				BigFuncBox(Box, Outbox)			ELSE				SmallFuncBox(Box, Outbox, Boxsize);		WITH Outbox DO			BEGIN				right := right + 1;				bottom := bottom + 1;			END;	END;PROCEDURE Poop (n: Integer);	VAR		j: Integer;	BEGIN {FOR j:=1 TO N DO Sysbeep(1)}	END; {poop}PROCEDURE StartDocuments (DocumentCount: Integer);{v1.1 The original procedure would fail if you double click on a colour biomorph file,}{because those files have the same creator signiture but different file formats.}{Added check of file format - Alun}	VAR		j, k, volume, PersFile: Integer;		theFile: AppFile;		errorCode: OSErr;		dirID, procID, bytesToRead: LongInt;	BEGIN		j := 0;		FOR k := 1 TO DocumentCount DO			BEGIN				GetAppFiles(k, theFile);				WITH theFile DO					IF (fType = 'APPL') | NOT ((fType = 'RAUP') | (fType = 'RALB')) THEN						SysBeep(1)					ELSE						BEGIN							errorCode := GetWDInfo(vRefNum, volume, dirID, procID);							errorCode := HOpen(volume, dirID, fName, fsRdPerm, persFile);							IF errorCode <> noErr THEN								SysBeep(1)							ELSE								BEGIN									WHILE NOT ((IsEOF(PersFile, SizeOfPerson)) OR (j >= MaxAlbum)) DO										BEGIN											j := succ(j);											bytesToRead := SizeOfPerson;											errorCode := FSRead(persFile, bytesToRead, @ThisMenagerie.Member[j]);											IF errorCode <> noErr THEN												j := j - 1;										END;									errorCode := FSClose(PersFile)								END						END			END;		ThisMenagerie.Size := j;	END; {StartDocuments}{   *********   event handling routines   *********** }END.