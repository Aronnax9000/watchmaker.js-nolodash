UNIT Album;{******************************************}{*						v1.1 Sept 1993													 *}{*		Changed file commands to Mac File manager					 	 *}{*		Removed Repeat/Until loop in DoClose								 *}{******************************************}INTERFACEUSES	Engineering;PROCEDURE DoLoad (WithDialogue: Boolean);PROCEDURE SaveSlides;PROCEDURE ResetFossils;PROCEDURE ReadAnimals (VAR ThisMenagerie: Menagerie);PROCEDURE DoSave (HowMuch: Integer);PROCEDURE GracefulDeath;PROCEDURE DoClose;PROCEDURE StoreBreedingScreen;PROCEDURE DoClear (Really: Boolean); {otherwise paste}PROCEDURE AddToAlbum (Biomorph: Person);PROCEDURE Emphasize (MLoc: point);PROCEDURE Zoom;PROCEDURE UnCurtainPage (p: Integer);PROCEDURE TakeCare (Page: Integer);PROCEDURE ClosePlayBack;PROCEDURE StartPlayBack;PROCEDURE SaveAnimals (ThisMenagerie: Menagerie; Foss: Boolean);PROCEDURE DoPlayBack (MLoc: Point);FUNCTION AlbumFull: Boolean;IMPLEMENTATIONVAR	StoreMode: Mode;	StoreOldSpecial: Integer;{moved from globals, used only in StoreBreedingScreen and RestoreBreedingScreen}PROCEDURE MyAction (MyControl: ControlHandle; PartCode: Integer);	VAR		p: longint;		err: OSErr;		bytesToRead: LongInt;	BEGIN		CASE PartCode OF			0: 				; {SysBeep(1)}			inUpButton: 				BEGIN					FossilCounter := FossilCounter - 1;					IF FossilCounter < 0 THEN						FossilCounter := 0;				END;			inDownButton: 				BEGIN					FossilCounter := FossilCounter + 1;					IF FossilCounter > NumberinFile THEN						FossilCounter := NumberinFile				END;			inPageUp: 				BEGIN					FossilCounter := FossilCounter - 1;					IF FossilCounter < 0 THEN						FossilCounter := 0;				END;			inPageDown: 				BEGIN					FossilCounter := FossilCounter + 1;					IF FossilCounter > NumberinFile THEN						FossilCounter := NumberinFile				END;			inThumb: 				BEGIN					FossilCounter := GetCtlValue(myControl)				END;			OTHERWISE   {SysBeep(1)}		END; {Cases}		IF PartCode <> 0 THEN			BEGIN				SetCtlValue(myControl, FossilCounter);				err := SetFPos(Slides, fsFromStart, 0);				p := 0;				REPEAT					bytesToRead := SizeOfPerson;					err := FSRead(slides, bytesToRead, @theBiomorph);	{??? It looks as if this reads only the last biomorph}					p := p + 1				UNTIL (err = eofErr) OR (p = 1 + NumberinFile - FossilCounter);				eraserect(PlayBackRect);				Develop(theBiomorph, MidPoint);			END;{IF NOT Fossilizing THEN}		Child[special] := theBiomorph;	END; {MyAction}PROCEDURE DoPlayBack (MLoc: Point);	VAR		DoubleRect: Rect;		AllDone, Going: Boolean;		thePart: Integer;		theControl: ControlHandle;	BEGIN {DoPlayBack}		PlayBackRect := PlayBackPtr^.PortRect;		WITH PlayBackRect DO			BEGIN				right := right - Scrollbarwidth - 1;				bottom := bottom - Scrollbarwidth - 1;				MidPoint.h := (right - left) DIV 2;				MidPoint.v := (bottom - top) DIV 2			END;		IF NumberInFile >= 1 THEN			BEGIN				thePart := FindControl(MLoc, PlayBackPtr, theControl);				IF thePart = inThumb THEN					BEGIN						thePart := TrackControl(theControl, MLoc, NIL);						MyAction(theControl, thePart)					END				ELSE					thePart := TrackControl(theControl, MLoc, @MyAction);			END;{InvalRect(TheControl^^.ContrlRect);}	END; {DoPlayBack}PROCEDURE StartPlayBack;	VAR		thePart, j: Integer;		mous: Point;		bytesRead: LongInt;		err: OSErr;	BEGIN		SmallMenus;		IF FrontWindow = MainPtr THEN			StoreOffScreen(MainPtr^.PortRect, MyBitMap);		NumberInFile := 0;		err := SetFPos(Slides, fsFromStart, 0);		err := GetEOF(slides, bytesRead);		IF bytesRead >= SizeOf(Person) THEN			REPEAT		{??? This reading is done twice in the procedure}				NumberInFile := NumberInFile + 1;				bytesRead := SizeOfPerson;				err := FSRead(Slides, bytesRead, @theBiomorph);			UNTIL err = eofErr;		err := SetFPos(Slides, fsFromStart, 0);		{v1.1  was reset(Slides);}		NumberInFile := NumberInFile - 1;		SetUpBoxes;		SelectWindow(PlayBackPtr);		SetPort(PlayBackPtr);		ShowWindow(PlayBackPtr);		frontw := PlayBackPtr;		SetCtlMax(MyControl, NumberInFile);		SetCtlMin(MyControl, 0);		SetCtlValue(MyControl, 0);		DrawControls(PlayBackPtr);		DrawGrowIcon(PlayBackPtr);		SaveMode := theMode;		TheMode := PlayingBack;		FossilCounter := 0;		PlayBackRect := PlayBackPtr^.PortRect;		WITH PlayBackRect DO			BEGIN				right := right - Scrollbarwidth - 1;				bottom := bottom - Scrollbarwidth - 1;				MidPoint.h := (right - left) DIV 2;				MidPoint.v := (bottom - top) DIV 2			END;		FirstBiomorph := theBiomorph;		Child[special] := theBiomorph;		Develop(theBiomorph, MidPoint);	END; {StartPlayBack}PROCEDURE ClosePlayBack;{NB this didn't really close the window, it doesn't even hide it, it just moves it behind the main window}{v1.1 changed it to hide the window instead (caused problems when I hide the main window in bg)}	BEGIN		HideWindow(playbackPtr);		SelectWindow(MainPtr);		Frontw := MainPtr;		SetPort(MainPtr);		TheMode := SaveMode;		FlushEvents(EveryEvent, 0);{ValidRect(Prect);}		LargeMenus;	END; {ClosePlayBack}PROCEDURE SaveAnimals (ThisMenagerie: Menagerie; Foss: Boolean);		{In the case of a single biomorph, Child[special] has already been}{		placed in ThisMenagerie [ 1 ] }	VAR		ThisFile: Integer;		OurPrompt, str: Str255;		thePrompt: StringHandle;		j: Integer;		ErrorCode: OSErr;		MyReply: SFReply;		MyPoint: Point;		MyFileType: OSType;		VRefNum: Integer;		dirID, procID: LongInt;		jobdone: Boolean;		bytesToSave: Longint;	BEGIN		DotheSave := FALSE;		FindDlogPosition('DLOG', PutDlgID, MyPoint);{v1.1 originally called sfPutDialogID, but this resource only exists under system 7! putDlgID is the old style box}		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		IF Foss THEN			ThePrompt := GetString(9520)		ELSE			BEGIN				IF ThisMenagerie.Size = 1 THEN					ThePrompt := GetString(3866)				ELSE					ThePrompt := GetString(10281)			END;		OurPrompt := ThePrompt^^;{ThePrompt := GetString(AsString);   - Don't think this does anything - Alun}		SFPutFile(MyPoint, OurPrompt, LastPutFileName, NIL, MyReply);		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		IF ThisMenagerie.Size = 1 THEN			MyFiletype := 'RAUP'		ELSE			MyFiletype := 'RALB';		IF MyReply.good THEN			BEGIN				LastPutFileName := MyReply.fname;				SetCursor(CursList[WatchCursor]^^);				ErrorCode := GetWDInfo(myreply.vrefnum, vRefNum, dirID, procID);				DeleteOldFile(vRefNum, dirID, myReply.fname);				errorCode := HCreate(vrefnum, dirID, myreply.fname, 'SNAW', MyFileType);				IF errorCode <> noErr THEN					BEGIN  {Use the offscreen bitmap procs if applicable}						IOError(errorCode, 'Check disk and try again');						Exit(SaveAnimals)					END;				errorCode := HOpen(myreply.vrefnum, dirID, myreply.fname, fsRdWrPerm, ThisFile);				IF errorCode <> noErr THEN					BEGIN						IOError(errorCode, 'Check disk and try again');						Exit(SaveAnimals)					END;				IF foss THEN					FossilsToSave := FALSE;				WITH ThisMenagerie DO					FOR j := 1 TO Size DO						BEGIN							bytesToSave := SizeOfPerson;							errorCode := FSWrite(ThisFile, bytesToSave, @Member[j]);							IF errorCode <> noErr THEN								BEGIN									IOError(errorCode, 'Check disk and try again');									errorCode := FSClose(thisFile);									Exit(SaveAnimals)								END;						END;				errorCode := FSClose(ThisFile);			END		ELSE			Finished := FALSE;		LastPutFileName := MyReply.fname;		IF theMode = Engineering THEN			Delayvelop(child[special], centre[MidBox], Midbox); {Correct displacement bug}		FlushEvents(EveryEvent, 0);		ValidRect(Prect);	END; {Save Animals}PROCEDURE SaveSlides;	VAR		ThisMenagerie: Menagerie;		aFossil: Person;		err: OSErr;		bytesToRead: LongInt;	BEGIN		DotheSave := FALSE;	{put it here in case we don't need to call SaveAnimals}		ThisMenagerie.Size := 0;		err := SetFPos(Slides, fsFromStart, 0);		{v1.1  was reset(Slides);}{Check to see if at least one fossil is in slides}		err := GetEOF(slides, bytesToRead);{IF bytesToRead < SizeOfPerson THEN Exit(SaveSlides);}		WHILE NOT IsEOF(slides, SizeOfPerson) DO			BEGIN				bytesToRead := SizeOfPerson;				err := FSRead(slides, bytesToRead, @aFossil);				ThisMenagerie.Size := ThisMenagerie.Size + 1;				ThisMenagerie.Member[ThisMenagerie.Size] := aFossil			END; {while}		SaveAnimals(ThisMenagerie, TRUE);	END; {SaveSlides}PROCEDURE ResetFossils;	VAR		err: OSErr;	BEGIN		Fossilizing := TRUE; 	{Reset Fossil Record}		err := SetEOF(slides, 0);	END; {ResetFossils}PROCEDURE ShowAlbumPage (p: Integer);	BEGIN {StoreOffScreen(MainPtr^.PortRect,MyBitMap);}		IF OldSpecial > 0 THEN			InvertRect(Box[OldSpecial]);		OldSpecial := 0;		CopyBits(AlbumBitMap[p], MainPtr^.PortBits, MainPtr^.PortBits.Bounds, MainPtr^.PortBits.Bounds, srcCopy, NIL);{ReStoreOffScreen(MainPtr^.PortRect,MyBitMap);}	END; {ShowAlbumPage}PROCEDURE ReadAnimals (VAR ThisMenagerie: Menagerie);	VAR		ThisFile: Integer;		j: Integer;		ErrorCode, readErr: OSErr;		TheBiomorph: Person;		MyReply: SFReply;		myFileTypes: SFTypeList;		MyPoint: Point;		VRefNum: Integer;		dirID, procID: LongInt;		bytesToRead: LongInt;	BEGIN		FindDlogPosition('DLOG', sfGetDialogID, MyPoint);			{Calculate the position on screen}		MyFileTypes[0] := 'RAUP';		MyFileTypes[1] := 'RALB'; {****}		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		SFGetFile(MyPoint, '', @DawkFilter, -1, myFileTypes, NIL, MyReply);		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		IF (MyReply.good) THEN{AND (ErrorCode = NoErr) }			BEGIN				errorCode := GetWDInfo(myReply.vRefNum, vRefNum, dirID, procID);				IF Album.Size > 0 THEN					AlbumChanged := TRUE;				WITH myReply DO					errorCode := HOpen(vRefNum, dirID, fname, fsRdWrPerm, thisFile);				IF LoadingFossils THEN					errorCode := SetEOF(slides, 0);	{was Rewrite(slides);	}				j := 0;				WHILE NOT ((IsEOF(ThisFile, sizeOfPerson)) OR (j >= MaxAlbum)) DO					BEGIN						j := j + 1;						IF NOT LoadingFossils THEN							BEGIN								bytesToRead := SizeOfPerson;								readErr := FSRead(thisFile, bytesToRead, @ThisMenagerie.member[j])							END						ELSE							BEGIN								bytesToRead := SizeOfPerson;								readErr := FSRead(ThisFile, bytesToRead, @TheBiomorph);								errorCode := FSWrite(Slides, bytesToRead, @TheBiomorph);							END;					END;    {while}				errorCode := FSClose(ThisFile);				IF NOT LoadingFossils THEN					BEGIN						ThisMenagerie.Size := j;						theMode := albuming;					END			END		ELSE			BEGIN {Sysbeep(1);}				ThisMenagerie.Size := 0			END;		IF ThisMenagerie.Size > MaxAlbum THEN			ThisMenagerie.Size := MaxAlbum;		LastGetFileName := MyReply.fname;		IF LoadingFossils AND (MyReply.good) AND (ErrorCode = NoErr) THEN    {BEGIN Child[Special]:=TheBiomorph;}{    DoBreed;}{    Fossilizing:=TRUE;}{    ValidRect(PRect);}{    END;}			BEGIN				errorCode := SetFPos(Slides, fsFromStart, 0);		{v1.1  was reset(Slides);}				StartPlayBack;			END;	END; {ReadAnimal}PROCEDURE TakeCare (Page: Integer);	VAR		j: Integer;		PageStart: Integer;	BEGIN		PageStart := ((Page - 1) * NBoxes) MOD Album.Size;		FOR j := 1 TO PBoxNo[Page] DO			BEGIN				Special := j;				Child[j] := Album.Member[PageStart + j]			END;		OldSpecial := 0;		TheMode := Albuming;		NActiveBoxes := PBoxNo[Page];		CurrentPage := Page;		SetCursor(CursList[BlackCursor]^^);	END; {TakeCare}PROCEDURE StickInAlbum; {Only called (once) by DoLoad}	VAR		TitleRect: Rect;		Bust: Boolean;		Albstr: Stringhandle;	BEGIN		IF Page = 0 THEN			Page := 1;		Bust := FALSE;		TitleRect := Prect;		TitleRect.Bottom := PRect.Top + GenesHeight;{Morph is initially set to 1. It increases by 1 when a new one is stuck in album}		WHILE (Morph <= Album.Size) AND NOT Bust DO			BEGIN				IF (BoxNo > NBoxes) THEN					BEGIN						BoxNo := 1;						Page := Page + 1;						IF Page > MaxPages THEN							BEGIN								Bust := TRUE;								Sysbeep(1);{4 pages of album already full}								Album.Size := Morph;								Page := MaxPages							END					END; {case of new page needed}				IF NOT Bust THEN					BEGIN						IF BoxNo = 1 THEN							BEGIN								ClipRect(PRect);								EraseRect(Prect);								OldSpecial := 0;								MoveTo(200, 15);								TextSize(12);								TextFace([]);								AlbStr := GetString(AlbumPageID);								DrawString(Concat(AlbStr^^, ' ', char(Page + 48))); {changed v1.1}								TextSize(9);								StoreOffScreen(PRect, AlbumBitMap[Page]);							END;						ClipRect(Box[BoxNo]);						DelayVelop(Album.Member[Morph], Centre[BoxNo], BoxNo);						PBoxNo[Page] := BoxNo;{range check failed}						Album.Place[Morph].Page := Page;						Album.Place[Morph].BoxNo := BoxNo;						StoreOffScreen(Box[BoxNo], AlbumBitMap[Page]);						Morph := Morph + 1;						BoxNo := BoxNo + 1;						ClipRect(Prect);						CurrentPage := Page;						TakeCare(Page);        {AlbumNRows:=NRows; AlbumNCols:=NCols;}					END			END	END; {StickInAlbum}PROCEDURE UnCurtainPage (p: Integer);	VAR		LSlice, RSlice: Rect;		Mid: Integer;		TickValue: LongInt;	BEGIN {CurtainPage;}		Mid := (Prect.Right - Prect.Left) DIV 2;		LSlice := Prect;		WITH LSlice DO			BEGIN				Right := Mid;				Left := Mid - 8			END;		RSlice := Prect;		WITH RSlice DO			BEGIN				Left := Mid;				Right := Mid + 8			END;		WHILE LSlice.Left > Prect.Left DO			BEGIN				IF Button THEN					BrokenOut := TRUE;				CopyBits(AlbumBitMap[p], MainPtr^.PortBits, LSlice, LSlice, srcCopy, NIL);				CopyBits(AlbumBitMap[p], MainPtr^.PortBits, RSlice, RSlice, srcCopy, NIL);				OffSetRect(LSlice, -8, 0);				OffSetRect(Rslice, 8, 0);			END;		EraseRect(LSlice);		EraseRect(RSlice);	END; {UnCurtainPage}PROCEDURE DoLoad (WithDialogue: Boolean);	VAR		i, j, k: Integer;	BEGIN		SetCursor(CursList[WatchCursor]^^);		IF Album.Size > 0 THEN			BEGIN				UnCurtainPage(Page);				theMode := Albuming			END;		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		IF WithDialogue THEN			ReadAnimals(ThisMenagerie);		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);{I think that ideally this should be handled by DoUpdate, but we}{    don't visit GetNextEvent before other things are done}		IF ThisMenagerie.Size > 0 THEN			BEGIN				k := 0;				i := album.size;				NBoxes := NRows * NCols;				WHILE (k < ThisMenagerie.Size) AND (i < MaxAlbum) DO					BEGIN						k := succ(k);						i := i + 1;						album.member[i] := ThisMenagerie.member[k];					END;				Album.Size := i;				StickInAlbum;				IF OldSpecial = 0 THEN					BEGIN						OldSpecial := Special;						InvertRect(Box[special])					END;				AlbumEmpty := FALSE;				StoreOffScreen(MainPtr^.PortRect, MyBitMap);			END;		IF FrontWindow = MainPtr THEN			StoreOffScreen(MainPtr^.PortRect, MyBitMap);{IF TheMode=Highlighting THEN}{    BEGIN InvertRect(Box[Special]); OldSpecial:=0 END;}{theMode:=Albuming;}		IF Button THEN			REPEAT			UNTIL NOT Button;		FlushEvents(everyEvent, 0);		ValidRect(PRect);		IF Album.Size > MaxAlbum THEN			Album.Size := MaxAlbum;	END; {DoLoad}PROCEDURE StoreBreedingScreen;	VAR		j: Integer;	BEGIN		StoreMode := TheMode; {either breeding or highlighting}		StoreOldSpecial := OldSpecial;		FOR j := 1 TO BreedNBoxes DO			StoreChild[j] := Child[j];{IF TheMode=Highlighting THEN}{    BEGIN IF OldSpecial>0 THEN InvertRect(Box[OldSpecial]);}{    OldSpecial:=0}{    END;}		StoreOffScreen(MainPtr^.PortRect, AlbumBitMap[0]);{AlbumBitMap[0] is special reserve bitmap for breeding screen}		SomethingToRestore := (theMode = Breeding) OR (theMode = Highlighting)	END; {StoreBreedingScreen}PROCEDURE RestoreBreedingScreen;	VAR		j: Integer;	BEGIN		IF OldSpecial > 0 THEN			InvertRect(Box[OldSpecial]);		FOR j := 1 TO BreedNBoxes DO			Child[j] := StoreChild[j];		NRows := BreedNRows;		NCols := BreedNCols;		TheMode := Preliminary; {To prevent SetUpBoxes drawing boxes}		SetUpBoxes;		Special := MidBox;		TheMode := StoreMode;		ReStoreOffScreen(MainPtr^.PortRect, AlbumBitMap[0]);		NActiveBoxes := NBoxes;		OldSpecial := StoreOldSpecial;		SomethingToRestore := FALSE;		IF TheMode = Highlighting THEN			BEGIN				IF OldSpecial > 0 THEN					InvertRect(Box[OldSpecial]);				OldSpecial := 0			END;	END;{RestoreBreedingScreen}PROCEDURE AddToAlbum (Biomorph: Person);	VAR		StoreSpecial: Integer;	BEGIN		AlbumChanged := TRUE;		StoreSpecial := Special;		ThisMenagerie.Size := 1;		ThisMenagerie.Member[1] := Biomorph; {In order to use Load}		DoLoad(FALSE);		Special := StoreSpecial;		RestoreBreedingScreen;		IF TheMode = Engineering THEN			DoEngineer;	END; {AddToAlbum}PROCEDURE DoClear (Really: Boolean);{If really is false, we paste}	VAR		k, j, H: Integer;		RoomInAlbum: Boolean;	BEGIN	END; {DoClear}PROCEDURE DoSave (HowMuch: Integer);	VAR		ThatMenagerie: Menagerie;	BEGIN		IF FrontWindow = MainPtr THEN			StoreOffScreen(MainPtr^.PortRect, MyBitMap);		CASE HowMuch OF			1: 				BEGIN					ThatMenagerie.member[1] := Child[Special];					ThatMenagerie.Size := 1;					SaveAnimals(ThatMenagerie, FALSE)				END; {Save Biomorph}			2: 				BEGIN				END;			3: 				BEGIN					SaveAnimals(Album, FALSE);					IF DoTheSave THEN						AlbumChanged := FALSE				END		END {CASES}	END; {DoSave}PROCEDURE GracefulDeath;{This is used only for abnormal terminations, normal ones simple set finished to true and exit the main loop}{v1.1 fixed}	VAR		string1, string2: Str255;		theItem: Integer;	BEGIN		IF AlbumChanged THEN			BEGIN				IF gSystem.systemVersion < $0700 THEN					PositionDialog('ALRT', 152);				GetIndString(string1, kAlertStringsID, kAlbumID);				GetIndString(string2, kAlertStringsID, kClosingID);				ParamText(string1, string2, '', '');				theItem := CautionAlert(152, NIL);				IF theItem = 1 THEN					DoSave(3); {Yes}			END;		IF FossilsToSave THEN			BEGIN				IF gSystem.systemVersion < $0700 THEN					PositionDialog('ALRT', 152);				GetIndString(string1, kAlertStringsID, kFossilsID);				ParamText(string1, string2, '', '');				theItem := CautionAlert(152, NIL);				IF theItem = 1 THEN					SaveSlides; {Yes}			END;		CleanUp;		ExitToShell;		{Removed from cleanup to allow normal termination}	END; {GracefulDeath}PROCEDURE DoClose;	VAR		Verdict: Integer;	BEGIN		Verdict := 0;		IF AlbumChanged THEN			BEGIN				DireMessage(kAlbumID, kClosingID, Verdict, true);				IF Verdict = 1 THEN					DoSave(3); {Yes}				IF Verdict = 3 THEN					Finished := FALSE; {Cancel}			END;		IF (Verdict <> 3) OR (NOT AlbumChanged) THEN			BEGIN				Page := 0;				BoxNo := 1;				Morph := 1;				CurrentPage := 0;				Album.Size := 0;				EraseRect(Prect);				StoreOffScreen(MainPtr^.PortRect, MyBitMap);				TheMode := Preliminary;				NActiveBoxes := 0;{Special:=0;}				AlbumEmpty := TRUE			END;	END;PROCEDURE Emphasize (MLoc: point);	VAR		j: Integer;	BEGIN		GlobalToLocal(Mloc);		j := 0;		REPEAT			j := j + 1		UNTIL (PtInRect(Mloc, box[j])) OR (j > NActiveBoxes);		IF j <= NActiveBoxes THEN			BEGIN				IF danger THEN					danger := FALSE				ELSE					BEGIN						special := j;						IF oldspecial > 0 THEN							InvertRect(box[OldSpecial]);						InvertRect(box[special]);        {MakeGeneBox(child[special]);}						oldspecial := special					END			END;	END; {emphasize}PROCEDURE Zoom;	VAR		Quadrant: ARRAY[1..4] OF Rect;		j, OldQuadrant, ThisQuadrant, MaxPage: Integer;		MLoc: POINT;	BEGIN		EraseRect(Prect);		FOR j := 1 TO 4 DO			Quadrant[j] := Prect;		WITH Prect DO			BEGIN				Quadrant[1].top := top + 15;				Quadrant[2].top := top + 15;				Quadrant[1].right := Left + (right - Left) DIV 2;				Quadrant[1].Bottom := Top + (Bottom - Top) DIV 2;				Quadrant[3].Right := Quadrant[1].Right;				Quadrant[3].Top := Quadrant[1].Bottom;				Quadrant[2].Left := Quadrant[1].Right;				Quadrant[2].Bottom := Quadrant[1].Bottom;				Quadrant[4].Left := Quadrant[2].Left;				Quadrant[4].Top := Quadrant[2].Bottom			END;		FOR j := 1 TO Page DO			CopyBits(AlbumBitMap[j], MainPtr^.PortBits, Prect, Quadrant[j], srcCopy, NIL);		OldQuadrant := 0;		ThisQuadrant := 1;		REPEAT			GetMouse(Mloc);			IF MLoc.v < Quadrant[1].top THEN				SetCursor(Arrow)			ELSE				BEGIN					SetCursor(CursList[LensCursor]^^);					j := 0;					REPEAT						j := j + 1					UNTIL (j = 4) OR (PtInRect(Mloc, Quadrant[j]));					IF (OldQuadrant <> j) AND (j <= Page) THEN						BEGIN							PenSize(3, 3);							PenMode(PatXor);							IF OldQuadrant <> 0 THEN								BEGIN {PenPat(White);}									FrameRect(Quadrant[OldQuadrant]);            {PenPat(Black)}								END;							IF j <= Page THEN								BEGIN									FrameRect(Quadrant[j]);									OldQuadrant := j;								END;							PenSize(PSize, PSize);							PenMode(PatCopy);						END;				END;		UNTIL Button;		CopyBits(AlbumBitMap[OldQuadrant], MainPtr^.PortBits, Prect, Prect, srcCopy, NIL);		TakeCare(OldQuadrant);		WITH MLoc DO			BEGIN				h := 2 * (h - Quadrant[OldQuadrant].left);				v := 2 * (v - Quadrant[OldQuadrant].Top)			END;		emphasize(Mloc);		zoomed := TRUE;	END; {Zoom}FUNCTION AlbumFull: Boolean;	VAR		AF: Boolean;	BEGIN		AF := FALSE;		IF (Page = 4) THEN			BEGIN				IF PBoxNo[Page] = (AlbumNRows * AlbumNCols) THEN					AF := TRUE			END;		AlbumFull := AF	END; {AlbumFull}END.