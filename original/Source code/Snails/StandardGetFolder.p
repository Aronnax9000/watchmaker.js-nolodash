{******************************************************************************}{ StandardGetFolder.c                                                          }{                                                                              }{    This little chunk o' code implements a way to let the user choose a       }{    folder to save files in via a StandardFile Dialog.                        }{                                                                              }{    Since the code uses the CustomGetFile function and depends on the use of  }{    FSSpec records, it only works under System 7.0 or later.                  }{                                                                              }{    And don't forget to include the custom dialog resources ( a 'DITL' and    }{   'DLOG') in your project.                                                   }{                                                                              }{    Portions of this code were originally provided by Paul Forrester          }{    (paulf@apple.com) to the think-c internet mailing list in response to my  }{    my question on how to do exactly what this code does.  I've added a       }{    couple of features, such as the ability to handle aliased folders and     }{    the programmer definable prompt.  I also cleaned and tightened the code,  }{    stomped a couple of bugs, and packaged it up neatly.  Bunches of work,    }{    but I learned A LOT about Standard File, the File Manager, the Dialog     }{    Manager, and the Alias Manager.  I tried to include in the comments some  }{    of the neat stuff I discovered in my hours of pouring over Inside Mac.    }{    Hope you find it educational as well as useful.                           }{******************************************************************************}{ Converted to Pascal by Peter N Lewis <peter@cujo.curtin.edu.au> Dec 1992 }UNIT StandardGetFolder;INTERFACEFUNCTION GetSFCurDir: longInt;FUNCTION GetSFVRefNum: integer;PROCEDURE StandardGetFolder (where: Point; message: Str255; VAR mySFReply: StandardFileReply);IMPLEMENTATIONUSES	Aliases, Script;{ Resource IDs }CONST	rGetFolderButton = 10;	rGetFolderMessage = 11;	kFolderBit = $0010;	rGetFolderDialog = 2008;{ Global Variables }VAR	gCurrentSelectedFolder: str255;{******************************************************************************}{ SetButtonTitle                                                               }{                                                                              }{     Whenever the selected folder is changed, SetButtonTitle is called to     }{     redraw the get folder button.  Pass it a handle to the button, the new   }{     string to be drawn in the button, and a pointer to the rect the button   }{     is drawn within.                                                         }{******************************************************************************}PROCEDURE SetButtonTitle (ButtonHdl: Handle; name: Str255; VAR ButtonRect: Rect);	VAR		resultCode: integer;		width: integer;		TmpStr: str255;	BEGIN		gCurrentSelectedFolder := name;    {*-------------------------------------------------------------------------}    { Find the width left over in the button after drawing the word 'Select'   }    { the quotation marks. Truncate the new name to this length.               }    {-------------------------------------------------------------------------*}		width := (ButtonRect.right - ButtonRect.left) - (StringWidth('Select ""J'));		resultCode := TruncString(width, name, smTruncEnd);		IF resultCode < 0 THEN			;    {*-------------------------------------------------------------------------}    { Redraw the button.                                                       }    {-------------------------------------------------------------------------*}		TmpStr := concat('Select "', name, '"');		SetCTitle(ControlHandle(ButtonHdl), TmpStr);		ValidRect(ButtonRect);	END;{******************************************************************************}{ MyCustomGetDirectoryFileFilter                                               }{                                                                              }{     This is the file filter passed to CustomGetFile. It passes folders only. }{******************************************************************************}FUNCTION MyCustomGetDirectoryFileFilter (VAR myPB: CInfoPBRec; myDataPtr: Ptr): boolean;	BEGIN		MyCustomGetDirectoryFileFilter := BAND(myPB.ioFlAttrib, kFolderBit) = 0;	END;{******************************************************************************}{ MyCustomGetDirectoryDlogHook                                                 }{                                                                              }{     This function lets us process item hits in the GetFolderDialog.  We're   }{     only interested if the user hit the selectFolder button. We pass all     }{     other item hits back to ModalDialog.                                     }{******************************************************************************}FUNCTION MyCustomGetDirectoryDlogHook (item: integer; theDialog: DialogPtr; myDataPtr: Ptr): integer;	TYPE		StandardFileReplyPtr = ^StandardFileReply;	VAR		dlgPeek: WindowPeek;		selectedName: Str255;		pb: CInfoPBRec;		err: OSErr;		itemType: integer;		itemRect: Rect;		itemHandle: Handle;		isAlias: Boolean;		isFolder: Boolean;		mySFRPtr: StandardFileReplyPtr;	BEGIN    {*-------------------------------------------------------------------------}    { Set the return value to default to the item that was passed in.          					 }    {-------------------------------------------------------------------------*}		MyCustomGetDirectoryDlogHook := item;    {*-------------------------------------------------------------------------}    { CustomGet calls dialog hook for both main and subsidiary dialog boxes.   				}    { Make sure that dialog record indicates that this is the main GetFolder   				}    { dialog.                                                                  												}    {-------------------------------------------------------------------------*}		dlgPeek := WindowPeek(theDialog);		IF OSType(dlgPeek^.refCon) = sfMainDialogRefCon THEN			BEGIN        {*---------------------------------------------------------------------}        { Get a handle to the select folder button, in case we need to change  					}        { the label.                                                           												}        {---------------------------------------------------------------------*}				GetDItem(theDialog, rGetFolderButton, itemType, itemHandle, itemRect);        {*---------------------------------------------------------------------}        { If this is the first time the dialog hook has been called...         }        {---------------------------------------------------------------------*}				IF item = sfHookFirstCall THEN					BEGIN            {*-----------------------------------------------------------------}            { Set the prompt displayed above the file list...                  }            {-----------------------------------------------------------------*}						GetDItem(theDialog, rGetFolderMessage, itemType, itemHandle, itemRect);						mySFRPtr := StandardFileReplyPtr(myDataPtr);						SetIText(itemHandle, mySFRPtr^.sfFile.name);            {*-----------------------------------------------------------------}            { And the name of the currently selected folder in the select      }            { folder button.                                                   }            {-----------------------------------------------------------------*}						pb.ioNamePtr := @selectedName;						pb.ioVRefNum := GetSFVRefNum;						pb.ioDirID := GetSFCurDir;						pb.ioFDirIndex := -1;						err := PBGetCatInfo(@pb, FALSE);            {*-----------------------------------------------------------------}            { Note that this error return is important! When the dialog hook   }            { is called for the first time, Super Boomerang (and possibly      }            { Norton directory assistance) aren't finished doing their          }            { rebounting, so the values returned by GetSFVRefNum and           }            { GetSFCurDir may not be valid, and hence PBGetCatInfo will return }            { an error.  That one took me a while to figure out.               }            {-----------------------------------------------------------------*}						IF err <> noErr THEN							BEGIN								exit(MyCustomGetDirectoryDlogHook);							END;						GetDItem(theDialog, rGetFolderButton, itemType, itemHandle, itemRect);						SetButtonTitle(itemHandle, selectedName, itemRect);					END				ELSE					BEGIN            {*-----------------------------------------------------------------}            { Cast myDataPtr back to a SFReply pointer.                        }            {-----------------------------------------------------------------*}						mySFRPtr := StandardFileReplyPtr(myDataPtr);            {*-----------------------------------------------------------------}            { If the selected folder is an alias, resolve it. isFolder will    }            { be set to true if a folder or aliased folder is selected.        }            {-----------------------------------------------------------------*}             {*-----------------------------------------------------------------}            { If the selected item is a folder or volume, just copy the name   }            { into selectedName...                                             }            {-----------------------------------------------------------------*}						err := ResolveAliasFile(mySFRPtr^.sfFile, TRUE, isFolder, isAlias);						IF ((err = noErr) AND isAlias AND isFolder) OR mySFRPtr^.sfIsFolder OR mySFRPtr^.sfIsVolume THEN							BEGIN								selectedName := mySFRPtr^.sfFile.name;            {*-----------------------------------------------------------------}            { Otherwise, copy the name of the selected item's parent directory }            { into selectedName.                                               }            {-----------------------------------------------------------------*}							END						ELSE							BEGIN								pb.ioNamePtr := @selectedName;								pb.ioVRefNum := mySFRPtr^.sfFile.vRefNum;								pb.ioDirID := mySFRPtr^.sfFile.parID;								pb.ioFDirIndex := -1;								err := PBGetCatInfo(@pb, FALSE);								IF err <> noErr THEN									exit(MyCustomGetDirectoryDlogHook);							END;            {*-----------------------------------------------------------------}            { If the selected folder has changed since the last call to this   }            { dialog hook function, re-draw the button with the new selected   }            { folder name.                                                     }            {-----------------------------------------------------------------*}						IF NOT EqualString(selectedName, gCurrentSelectedFolder, FALSE, FALSE) THEN							SetButtonTitle(itemHandle, selectedName, itemRect);            {*-----------------------------------------------------------------}            { If the user clicked the select folder button, force a cancel and }            { set the sfGood field of the Reply record to true.                }            {-----------------------------------------------------------------*}						IF item = rGetFolderButton THEN							BEGIN								MyCustomGetDirectoryDlogHook := sfItemCancelButton;								mySFRPtr^.sfGood := TRUE;							END;					END;			END;	END;{******************************************************************************}{ StandardGetFolder                                                            }{                                                                              }{     The StandardGetFolder function. You pass it the point where you want the }{     standard file dialog box drawn, the prompt to display above the file     }{     list, and a pointer to an StandardFileReply record.                      }{                                                                              }{     Upon return, the sfFile field of the SFReply record contains the volume  }{     reference number and directory ID that specify the folder the user       }{     chose. It also passes back the name of the chosen folder.  The sfGood    }{     field is set to true if the user chose a folder, or false if not.        }{******************************************************************************}PROCEDURE StandardGetFolder (where: Point; message: Str255; VAR mySFReply: StandardFileReply);	VAR		theTypeList: SFTypeList;		numTypes: integer;		myModalFilter: ProcPtr;		pb: CInfoPBRec;		err: OSErr;		theItem: integer;	BEGIN    {*-------------------------------------------------------------------------}    { Setting num types to -1 tells CustomGetFile to pass all files and        }    { folders to the file filter function.                                     }    {-------------------------------------------------------------------------*}		numTypes := -1;    {*-------------------------------------------------------------------------}    { Copy the prompt to be displayed above the file list into the name field  }    { of the SFReply record. When MyCustomGetDirectoryDlogHook is called for   }    { the first time, it will use this info to draw the prompt.                }    {-------------------------------------------------------------------------*}		mySFReply.sfFile.name := message;    {*-------------------------------------------------------------------------}    { Call CustomGetFile. Pass it a pointer to the file filter and dialog      }    { hook functions. Also pass a pointer to mySFReply in the user data field. }    {-------------------------------------------------------------------------*}		CustomGetFile(@MyCustomGetDirectoryFileFilter, numTypes, theTypeList, mySFReply, rGetFolderDialog, where, @MyCustomGetDirectoryDlogHook, NIL, NIL, NIL, @mySFReply);    {*-------------------------------------------------------------------------}    { Ok, now the reply record contains the volume reference number and the    }    { name of the selected folder. We need to use PBGetCatInfo to get the      }    { directory ID of the selected folder.                                     }    {-------------------------------------------------------------------------*}		IF mySFReply.sfGood THEN			BEGIN { Don't call PBGetCatInfo on cancel! }				pb.ioNamePtr := @mySFReply.sfFile.name;				pb.ioVRefNum := mySFReply.sfFile.vRefNum;				pb.ioFDirIndex := 0;				pb.ioDirID := mySFReply.sfFile.parID;				err := PBGetCatInfo(@pb, FALSE);    {*-------------------------------------------------------------------------}    { Insert your error handler here. I couldn't think of one so I left it     }    { empty. Works fine without it.                                            }    {-------------------------------------------------------------------------*}				IF err <> noErr THEN					;    {*-------------------------------------------------------------------------}    { Copy the directory ID of the selected folder to the sfFile field of the  }    { SFReply record.                                                          }    {-------------------------------------------------------------------------*}				mySFReply.sfFile.parID := pb.ioDrDirID;				mySFReply.sfFile.name := '';			END;	END;{******************************************************************************}{ GetSFCurDir, GetSFVRefNum                                                    }{                                                                              }{ The following set of routines are used to access a couple of low memory      }{ globals that are necessary when extending Standard File.  One example is     }{ trying to get the current directory while in a file filter.  These routines  }{ were used to bottleneck all the low memory usage.  If the system one day     }{ supports them with a trap call, then we can easily update these routines.    }{******************************************************************************}FUNCTION GetSFCurDir: longInt;	CONST		CurDirStoreA = $398;	TYPE		longPtr = ^longInt;	BEGIN		GetSFCurDir := longPtr(CurDirStoreA)^;	END;FUNCTION GetSFVRefNum: integer;	CONST		SFSaveDiskA = $214;	TYPE		intPtr = ^integer;	BEGIN		GetSFVRefNum := -intPtr(SFSaveDiskA)^;	END;END.