UNIT Biomorphs;{token change}INTERFACEUSES	ErrorUnit;VAR	min: Integer;PROCEDURE Develop (VAR theShell: person; Where: point);PROCEDURE Delayvelop (VAR Biomorph: Person; Here: Point; theBox: Integer);PROCEDURE SetUpBoxes;PROCEDURE MakeGeneBox (biomorph: person);PROCEDURE Snapshot (ThisPic: Pic; box: Rect; biomorph: person);PROCEDURE ShowGeneBox (j: Integer; biomorph: person);PROCEDURE ShowChangedGene (an1, an2: person);PROCEDURE DrawPic (ThisPic: Pic; Place: Point; VAR Biomorph: person);FUNCTION margarine (W: real; direction: integer): real;PROCEDURE Reproduce (parent: person; VAR child: person);PROCEDURE SendToClipBoard;PROCEDURE DoHighlight;PROCEDURE DoBreed;PROCEDURE DoRowMore;PROCEDURE DoRowLess;PROCEDURE DoColMore;PROCEDURE DoColLess;PROCEDURE Targetevolve (target: person);PROCEDURE Evolve (MLoc: point);FUNCTION Direction: Integer;PROCEDURE DoArray (theBiomorph: Person; WDetails, DDetails, TDetails: MarchingOrders);PROCEDURE DoResources (theBiomorph: Person; WDetails, DDetails, TDetails: MarchingOrders);IMPLEMENTATIONFUNCTION power (w, i: real): real;	BEGIN		power := exp(i * ln(w));	END;PROCEDURE GeneBoxTemplate;	VAR		j: Integer;	BEGIN		width := (Prect.right - Prect.left) DIV 5;		WITH GeneBox[1] DO			BEGIN				left := box[1].left;				right := left + width;				top := Prect.Top;				bottom := top + GenesHeight;				EraseRect(GeneBox[1]);				Framerect(GeneBox[1]);			END;		FOR j := 2 TO 5 DO			WITH GeneBox[j] DO				BEGIN					top := PRect.top;					bottom := top + GenesHeight;					left := GeneBox[j - 1].right;					right := left + width;					EraseRect(GeneBox[j]);					Framerect(GeneBox[j])				END;	END; {GeneBoxTemplate}PROCEDURE ShowGeneBox (j: Integer; biomorph: person);	VAR		theString: str255;		n: real;		l: longint;	BEGIN		WITH biomorph DO			IF j > 0 THEN				WITH GeneBox[j] DO					BEGIN						EraseInnerRect(GeneBox[j]);						MoveTo(left - 8 + width DIV 2, top + 14);						CASE j OF							1: 								BEGIN									DrawReal(WOpening);									MoveTo(Left, top + 14);									Drawstring('   W');									MoveTo(left + (width - stringwidth(thestring)) DIV 2, top + 14);								END;							2: 								BEGIN									DrawReal(DDisplacement);									MoveTo(Left, top + 14);									Drawstring('   D');									MoveTo(left + (width - stringwidth(thestring)) DIV 2, top + 14);								END;							3: 								BEGIN									DrawReal(SShape);									MoveTo(Left, top + 14);									Drawstring('   S ');									MoveTo(left + (width - stringwidth(thestring)) DIV 2, top + 14);								END;							4: 								BEGIN									DrawReal(TTranslation);									MoveTo(Left, top + 14);									Drawstring('   T');									MoveTo(left + (width - stringwidth(thestring)) DIV 2, top + 14);								END;						END; {cases}					END; {with}	END; {ShowGeneBox}PROCEDURE ShowChangedGene (an1, an2: person);	VAR		k: integer;	BEGIN		IF OldBox > 0 THEN			BEGIN				IF an1.Wopening <> an2.Wopening THEN					ShowGeneBox(1, an1);				IF an1.DDisplacement <> an2.DDisplacement THEN					ShowGeneBox(2, an1);				IF an1.SShape <> an2.SShape THEN					ShowGeneBox(3, an1);				IF an1.TTranslation <> an2.TTranslation THEN					ShowGeneBox(4, an1);			END;	END; {ShowChangedGene}PROCEDURE MakeGeneBox (biomorph: person);	VAR		j: Integer;	BEGIN		GeneBoxTemplate;		FOR j := 1 TO 4 DO			ShowGeneBox(j, biomorph);	END; {MakeGeneBox}FUNCTION Direction: Integer;	BEGIN		IF randint(2) = 2 THEN			direction := 1		ELSE			direction := -1	END;FUNCTION Direction9: Integer;	VAR		r: integer;	BEGIN		r := randint(5);		CASE r OF			5: 				direction9 := 2;			4: 				direction9 := 1;			3: 				direction9 := 0;			2: 				direction9 := -1;			1: 				direction9 := -2;			OTHERWISE				direction9 := 0;		END; {cases}	END;FUNCTION margarine (W: real; direction: integer): real;{we want to change by large amounts when low, small amounts when large}	VAR		m, logged, logchanged, WMutSize: real;	BEGIN		WMutSize := 0.1;		logged := ln(W);		logchanged := logged + WMutSize * direction;		IF logchanged > 20 THEN			logchanged := 20;		m := exp(logchanged);		IF m < 1 THEN			m := 1;		margarine := m	END;PROCEDURE Reproduce (parent: person; VAR child: person);	VAR		j: Integer;	BEGIN		child := parent;		WITH child DO			BEGIN				BEGIN					IF Randint(100) < MutProb THEN						WOpening := Margarine(WOpening, direction);					IF Randint(100) < MutProb THEN						BEGIN							DDisplacement := DDisplacement + direction9 * DMutSize;							IF DDisplacement < 0 THEN								DDisplacement := 0;							IF DDisplacement > 1 THEN								DDisplacement := 1;						END;					IF (Randint(100) < MutProb) AND SideView THEN						BEGIN {Don't let Translation gene drift when you can't see its consequences}							TTranslation := TTranslation + direction9 * TMutSize;						END;					IF (Randint(100) < 1) THEN						Handedness := -Handedness;				END;			END	END; {reproduce}FUNCTION Sgn (x: Integer): Integer;	BEGIN		IF x < 0 THEN			sgn := -1		ELSE IF x > 0 THEN			sgn := 1		ELSE			sgn := 0	END; {sgn}PROCEDURE Slide (LiveRect, DestRect: Rect);	VAR		SlideRect: RECT;		xDiscrep, yDiscrep, dh, dv, dx, dy, xmoved, ymoved, xToMove, yToMove, distx, disty: Integer;		TickValue: LONGINT;		upregion: RgnHandle;		{moved from globals}	BEGIN {PenMode(PatXor); FrameRect(LiveRect); PenMode(PatCopy);}		upregion := NewRgn;		{moved from initialize}		xMoved := 0;		yMoved := 0;		distx := DestRect.left - LiveRect.left;		disty := DestRect.bottom - LiveRect.bottom;		dx := sgn(distx);		dy := sgn(disty);		xToMove := ABS(distx);		yToMove := ABS(disty);		xMoved := 0;		yMoved := 0;		UnionRect(LiveRect, DestRect, SlideRect);		ObscureCursor;		REPEAT			TickValue := TickCount;			xDiscrep := xToMove - xMoved;			IF xDiscrep <= 20 THEN				dh := xDiscrep			ELSE				dh := (xDiscrep) DIV 2;			yDiscrep := yToMove - yMoved;			IF Ydiscrep <= 20 THEN				dv := yDiscrep			ELSE				dv := (yDiscrep) DIV 2;			REPEAT			UNTIL TickValue <> TickCount;			IF (xMoved < xToMove) OR (yMoved < yToMove) THEN				ScrollRect(SlideRect, dx * dh, dy * dv, upregion);			xMoved := xMoved + ABS(dh);			yMoved := yMoved + ABS(dv);		UNTIL (xMoved >= xToMove) AND (yMoved >= yToMove);	END; {Slide}PROCEDURE SetUpBoxes;	VAR		j, l, t, row, column, boxwidth: Integer;		SquareBox, inbox: Rect;	BEGIN		SquareBox := Prect;		SquareBox.right := Prect.bottom;		j := 0;		NBoxes := NRows * NCols;		MidBox := NBoxes DIV 2 + 1;		NActiveBoxes := NBoxes;		WITH PRect DO			BEGIN{Framerect(Prect);}				boxwidth := (right - left) DIV ncols;				height := (bottom - top - GenesHeight) DIV nrows;				FOR row := 1 TO nrows DO					FOR column := 1 TO ncols DO						BEGIN							j := j + 1;							l := left + boxwidth * (column - 1);							t := top + GenesHeight + height * (row - 1);							setrect(box[j], l, t, l + boxwidth, t + height);							IF (TheMode = breeding) AND (j <> MidBox) THEN								FrameRect(box[j]);							WITH box[j] DO								BEGIN									Centre[j].h := left + boxwidth DIV 2;									CENTRE[j].v := top + height DIV 2								END;						END; {row & column loop}			END; {WITH Prect}		IF theMode = breeding THEN			BEGIN				PenSize(3, 3);				FrameRect(box[MidBox]);				PenSize(Psize, Psize);			END;		WITH BusinessPart DO			BEGIN				left := box[1].left;				right := Box[NBoxes].right;				top := box[1].top;				bottom := box[Nboxes].bottom			END;	END; {setup boxes}PROCEDURE DoShowBoxes;	BEGIN		SetUpBoxes;		BoxesOnly	END;PROCEDURE PicLine (VAR ThisPic: Pic; x, y, xnew, ynew: Integer);	BEGIN		WITH ThisPic DO			BEGIN				IF PicSize >= PicSizeMax THEN					BEGIN{Message(GetString(TooLargeString));} {used the help dialog! v1.1 changed to alert}						DisplayError(-147, 'Biomorph too large, or other problem', ' ', StopError);						ExitToShell					END				ELSE					WITH MovePtr^ DO						BEGIN							StartPt.h := x;							StartPt.v := y;							EndPt.h := xnew;							EndPt.v := ynew						END;				MovePtr := linptr(size(MovePtr) + 8);  {advance 'array subscript' by number}{                                    of bytes occupied by one lin}				PicSize := PicSize + 1			END	END; {PicLine}PROCEDURE ZeroPic (VAR ThisPic: Pic; Here: Point);	BEGIN		WITH ThisPic DO			BEGIN				MovePtr := LinPtr(BasePtr);				PicSize := 0;				Origin := Here			END	END; {ZeroPic}PROCEDURE FindTheScale (VAR theScale: real);	VAR		targetheight, targetwidth, inheight, inwidth: integer;		heightscale, widthscale: real;	BEGIN {fix theScale here based upon Margin and box[midbox]}		WITH box[midbox] DO			BEGIN				targetheight := bottom - top;				targetwidth := right - left;				inheight := margin.bottom - margin.top;				inwidth := margin.right - margin.left;				heightscale := targetheight / inheight;				widthscale := targetwidth / inwidth;				IF heightscale < widthscale THEN					theScale := heightscale				ELSE					theScale := widthScale;			END;		theScale := 0.95 * theScale;	END;PROCEDURE DrawPic (ThisPic: Pic; Place: Point; VAR Biomorph: person); {Pic already contains its own origin, meaning the coordinates at which}{ it was originally drawn. Now draw it at Place}	PROCEDURE quarantine;		BEGIN			WITH ThisPic.MovePtr^ DO				BEGIN					startpt.v := thisPic.Origin.v + round(theScale * (Startpt.v - thisPic.Origin.v));					endpt.v := thisPic.Origin.v + round(theScale * (endpt.v - thisPic.Origin.v));					startpt.h := thisPic.Origin.h + round(theScale * (Startpt.h - thisPic.Origin.h));					endpt.h := thisPic.Origin.h + round(theScale * (Endpt.h - thisPic.Origin.h));				END;		END;		VAR			j, y0, y1, x0, x1, VertOffset, HorizOffset, Mid2, belly2, RingCounter, width, height, JThreshold: Integer;			theRect: rect;			SavePort: GrafPtr;			SaveBitMap: BitMap;	PROCEDURE ActualLine;		VAR			temp: integer;			doMirror, TooThin: boolean;		BEGIN			WITH ThisPic.MovePtr^ DO				BEGIN					quarantine;					VertOffset := round(theScale * (ThisPic.Origin.v - Place.v));					HorizOffset := round(theScale * (ThisPic.Origin.h - Place.h));					y0 := StartPt.v - VertOffset;					y1 := EndPt.v - VertOffset;					x0 := StartPt.h - HorizOffset;					x1 := EndPt.h - HorizOffset				END;			IF NOT sideView THEN				BEGIN					MoveTo(x0, y0);					LineTo(x1, y1)				END			ELSE				BEGIN					doMirror := false;					IF x1 < x0 THEN						BEGIN {here we need a mirror image}							DoMirror := true;							temp := x0;							x0 := x1;							x1 := temp;						END;					setRect(theRect, x0, y0, x1, y1);					WITH theRect DO						BEGIN							width := abs(right - left);							height := abs(bottom - top);							TooThin := (width < threshold) OR (height < threshold);							IF (Biomorph.GeneratingCurve = 0) OR (theMode = Triangling) OR ((J < JThreshold) AND TooThin) THEN								BEGIN									IF width = 0 THEN										BEGIN											MoveTo(left, top);											LineTo(right, bottom);										END									ELSE										FrameOval(theRect);								END							ELSE								BEGIN									IF odd(width) THEN										right := right + 1;									IF NOT doMirror THEN										CopyBits(MugShot, SaveBitMap, RectOfInterest, theRect, srcOr, NIL)									ELSE										CopyBits(Mirrorshot, SaveBitMap, RectOfInterest, theRect, srcOr, NIL);								END						END;				END		END; {ActualLine}	PROCEDURE ChangeTheBitMaps;		VAR			StrangePicture: PicHandle;		BEGIN			StrangePicture := GetPicture(Biomorph.GeneratingCurve);			WITH StrangePicture^^.PicFrame DO				BEGIN					SetRect(RectOfInterest, 0, 0, right - left, bottom - top);					WITH RectOfInterest DO						IF odd(right - left) THEN							right := right + 1;				END;			ClipRect(RectOfInterest);			SetPortBits(MugShot);			FillRect(RectOfInterest, White); {Off screen}			DrawPicture(StrangePicture, RectOfInterest);			Cliprect(Prect);			SetPortBits(SaveBitMap);			MirrorBits(MugShot, RectOfInterest, MirrorShot);		END;	BEGIN		GetPort(SavePort);		SaveBitMap := SavePort^.PortBits;		WITH ThisPic DO			BEGIN				IF (Biomorph.GeneratingCurve < 128) OR (Biomorph.GeneratingCurve > MaxResources) THEN					Biomorph.GeneratingCurve := 0				ELSE					BEGIN						IF (Biomorph.GeneratingCurve <> CurrentGeneratingCurve) THEN							ChangeTheBitMaps;					END;				CurrentGeneratingCurve := Biomorph.GeneratingCurve;				MovePtr := linptr(BasePtr); {reposition at base of grabbed space}				JThreshold := PicSize * 7 DIV 8;				FOR j := 1 TO PicSize DO					BEGIN						ActualLine; {sometimes rangecheck error}						ThisPic.MovePtr := linptr(size(ThisPic.MovePtr) + 8);					END;			END;		PenSize(1, 1);	END; {DrawPic}PROCEDURE Snapshot (ThisPic: Pic; box: Rect; biomorph: person);	VAR		Midpoint: Point;		SavePort: GrafPtr;		SaveBitMap: BitMap;	BEGIN		IF theMode = Sweeping THEN			ClipRect(PRect)		ELSE			ClipRect(businessPart);		WITH box DO			BEGIN				MidPoint.h := left + (right - left) DIV 2;				MidPoint.v := top + (bottom - top) DIV 2			END;		GetPort(SavePort);		SaveBitMap := SavePort^.PortBits;		SetPortBits(AlbumBitMap[0]);		EraseRect(box); {offscreen}		DrawPic(ThisPic, MidPoint, biomorph);		SetPort(SavePort);		SetPortBits(SaveBitMap);		CopyBits(AlbumBitMap[0], SavePort^.PortBits, box, box, srcCopy, NIL);		ClipRect(MainPtr^.PortRect);    {Pause('End of Snapshot ');}	END; {Snapshot}PROCEDURE Develop (VAR theShell: person; Where: point);	VAR		centre: point;		p: real;		ink, Offset, LeftExtent, RightExtent, Upextent, Downextentheight, width, newheight, newwidth, newtop, newbottom, newleft, newright: integer;	PROCEDURE DrawTop;		VAR			denom, theSize, W, D, S, T, MNX, MNY, RAD, XV1, YV1, XV2, YV2, XU1, YU1, XU2, YU2, X1, Y1, X2, Y2, SX, PI, I, BD, WI: real;			M, start: INTEGER;		PROCEDURE GOSUB8000;			VAR				XX1, XX2, YY1, YY2: integer;			BEGIN				XX1 := round(x1 - MNX);				XX2 := round(X2 - MNX);				YY1 := round(Y1 - MNY);				YY2 := round(Y2 - MNY);				WITH margin DO					BEGIN						IF xx1 < left THEN							left := xx1;						IF xx2 > right THEN							right := xx2;						IF YY1 < top THEN							top := YY1;						IF YY2 > bottom THEN							bottom := YY2;					END;				PicLine(MyPic, XX1, YY1, XX2, YY2);			END;		BEGIN			WITH theShell DO				BEGIN					DGradient := 1;					W := WOpening;					D := DDisplacement;					S := SShape;					T := TTranslation;					INC := Coarsegraininess;					start := reach * 360;					rad := 100;				END;			theSize := 0.74;			denom := 136 * theSize;			mny := (-(100 / denom) * where.v);{the smaller or more negative the number,the lower down the page}{mxy := 90;}			mnx := (-(100 / denom) * where.h);			XV1 := 0;			Yv1 := 0;			xU1 := 0;			YU1 := 0;			PI := 3.14159;			m := start;			REPEAT				p := (start - (start - m) * (1 - theShell.DGradient)) / start;				D := theShell.DDisplacement * p;				i := m / 360;				BD := 2 * PI * I;				WI := RAD * EXP(-I * LN(W));				XV2 := theShell.handedness * (-WI * COS(BD));				YV2 := WI * SIN(BD);				XU2 := XV2 * D;				YU2 := YV2 * D;				X1 := XV1;				X2 := XV2;				Y1 := YV1;				Y2 := YV2;				GOSUB8000;				X1 := X2;				X2 := XU2;				Y1 := Y2;				Y2 := YU2;				IF m <= 0 THEN					GOSUB8000;				X1 := X2;				X2 := XU1;				Y1 := Y2;				Y2 := YU1;				GOSUB8000;				XV1 := XV2;				YV1 := YV2;				XU1 := XU2;				YU1 := YU2;				m := m - inc;			UNTIL m < 0;		END;	PROCEDURE Drawshell;		VAR			rad1, rad2, r, rad, Twopi, i, fw, bd, W, D, S, T, gradient, p: real;{r, rad, mny, mnx,}			m, inc, Start: integer;			grunge, temp, f, g, h, k, xc, yc, xr, yr, mnx, mny, siz: real;			theRect: rect;			myPicture: PicHandle;			denom, theSize: real;		PROCEDURE swap (VAR a, b: longint);			VAR				temp: longint;			BEGIN				temp := a;				a := b;				b := temp			END; {swap}		PROCEDURE SetUp;			BEGIN				theSize := 0.8;				denom := 136 * theSize;				WITH theShell DO					BEGIN						W := WOpening;						D := DDisplacement;						S := SShape;						T := TTranslation;						r := 3;						rad := 100;						Twopi := 2 * 3.14159;						mny := round(-(100 / denom) * where.v * 1.088);						mnx := round(-(100 / denom) * where.h * 1.088);						rad1 := 1.088 * (rad + rad * D) / 2;						rad2 := 1.088 * (rad - rad * D) / 2;						IF CoarseGraininess < 1 THEN							Coarsegraininess := 1;						inc := Coarsegraininess;						IF reach < 1 THEN							reach := 1;						start := reach * 360;					END; {with theShell}				centre := where;				ClipBoarding := FALSE;				m := start;			END; {SetUp}		BEGIN {main procedure Drawshell}			SetUp;			WITH theShell DO				REPEAT					p := (start - (start - m) * (1 - TranslationGradient)) / start;					T := TTranslation * p;					i := m / 360;					fw := exp(-i * ln(W));					grunge := fw * cos(TwoPi * i);					xc := handedness * (rad1 * grunge);					yc := -rad1 * T * (1 - fw);					xr := handedness * (rad2 * grunge);					yr := -rad2 * fw * S;{the minus signs are to invert the whole snail}					h := (yc - yr - mny);					g := (xc - xr - mnx);					f := (yc + yr - mny);					k := (xc + xr - mnx);					WITH theRect DO						BEGIN							top := round(f);							bottom := round(h);							left := round(g);							right := round(k);							IF left <= right THEN								BEGIN									IF left < margin.left THEN										margin.left := left;									IF right > margin.right THEN										margin.right := right;								END							ELSE								BEGIN									IF right < margin.left THEN										margin.left := right;									IF left > margin.right THEN										margin.right := left;								END;							IF top < margin.top THEN								margin.top := top;							IF bottom > margin.bottom THEN								margin.bottom := bottom;						END;					BEGIN						IF NOT DontDraw THEN							WITH theRect DO								PicLine(MyPic, left, top, right, bottom);					END; {DontDraw is set by Pedigree so only Margin is measured, no drawing}					m := m - inc;				UNTIL m <= 0;		END; {DrawShell}	BEGIN {develop}		SetCursor(CursList[watchCursor]^^);		ZeroPic(MyPic, where);		IF zeromargin THEN			WITH margin DO				BEGIN					left := Where.h;					right := Where.h;					top := Where.v;					bottom := Where.v;				END;		IF SideView THEN			DrawShell		ELSE			DRAWTOP;		FindTheScale(theScale);		WITH Margin DO			BEGIN				height := bottom - top;				width := right - left;				newheight := round(height * theScale);				newwidth := round(width * thescale);				newtop := top + (height - newheight) DIV 2;				newbottom := newtop + newheight;				newleft := left + (width - newwidth) DIV 2;				newright := newleft + newwidth;			END;		setrect(Margin, newleft, newtop, newright, newbottom);		WITH Margin DO			BEGIN				centre.v := top + (bottom - top) DIV 2;				offset := centre.v - where.v;				Top := Top - Offset;				Bottom := Bottom - Offset;				OffCentre.v := Where.v - Offset;				centre.h := left + (right - left) DIV 2;				offset := centre.h - where.h;				left := left - Offset;				right := right - Offset;				OffCentre.h := Where.h - Offset;			END;		IF NOT DelayedDrawing THEN			DrawPic(MyPic, offCentre, theShell);	END; {Develop}PROCEDURE Delayvelop (VAR Biomorph: Person; Here: Point; theBox: Integer);	VAR		margcentre, offset: Integer;		OffCentre: Point;	BEGIN		Zeromargin := TRUE;		DelayedDrawing := false;		develop(Biomorph, Here);	END; {Delayvelop}PROCEDURE Evolve (MLoc: point);	VAR		j, Margcentre: Integer;		BoxesChanged: Boolean;		SlideRect: Rect;		bytesToSave: LongInt;		err: OSErr;	PROCEDURE GrowChild (j: Integer);		VAR			k: LONGINT;		BEGIN			Cliprect(Prect);			PenMode(PatXor);			MoveTo(Centre[Midbox].h, Centre[Midbox].v);			LineTo(Centre[j].h, Centre[j].v);			k := TickCount;			REPEAT			UNTIL TickCount >= k + 2;			MoveTo(Centre[Midbox].h, Centre[Midbox].v);			LineTo(Centre[j].h, Centre[j].v);			PenMode(PatCopy);			reproduce(child[MidBox], child[j]);			ClipRect(Box[j]);			delayvelop(Child[j], Centre[j], j);		END;	BEGIN		GlobalToLocal(Mloc);		j := 0;		REPEAT			j := j + 1		UNTIL (PtInRect(Mloc, box[j])) OR (j > NBoxes);		IF j <= NBoxes THEN			special := j		ELSE			special := 0;		IF special > 0 THEN			BEGIN				ObscureCursor;				FOR j := 1 TO NBoxes DO					IF j <> special THEN						EraseRect(box[j]);				PenPat(white);				Framerect(box[special]);				PenPat(MyPat);				Slide(box[special], box[MidBox]);				child[MidBox] := child[special];				SetUpBoxes;    {delayvelop(Child[MidBox],Centre[MidBox]);}				FOR j := 1 TO MidBox - 1 DO					Growchild(j);				FOR j := MidBox + 1 TO NBoxes DO					Growchild(j);			END;		ClipRect(Prect);		special := MidBox;		IF fossilizing THEN			BEGIN				bytesToSave := SizeOfPerson;				err := FSWrite(Slides, bytesToSave, @child[MidBox]);				FossilsToSave := TRUE			END;{****}	END; {evolve}PROCEDURE DoRowMore;	BEGIN		Nrows := Nrows + 2;		IF NRows * Ncols > MaxBoxes THEN			NRows := NRows - 2;		EraseRect(Prect);		DoShowBoxes;		IF special > 0 THEN			Delayvelop(Child[Special], Centre[MidBox], MidBox);		OldSpecial := 0;	END; {DoRowMore}PROCEDURE DoRowLess;	BEGIN		IF Nrows > 1 THEN			Nrows := Nrows - 2;		EraseRect(Prect);		DoShowBoxes;		IF special > 0 THEN			Delayvelop(Child[Special], Centre[MidBox], MidBox);		OldSpecial := 0;	END; {DoRowLess}PROCEDURE DoColMore;	BEGIN		Ncols := Ncols + 2;		IF NRows * Ncols > MaxBoxes THEN			NCols := NCols - 2;		EraseRect(Prect);		DoShowBoxes;		IF special > 0 THEN			Delayvelop(Child[Special], Centre[MidBox], MidBox);		OldSpecial := 0;	END; {DoColMore}PROCEDURE DoColLess;	BEGIN		IF NCols > 1 THEN			NCols := Ncols - 2;		EraseRect(Prect);		DoShowBoxes;		IF special > 0 THEN			Delayvelop(Child[Special], Centre[MidBox], MidBox);		OldSpecial := 0;	END; {DoColLess}PROCEDURE DoBreed;	VAR		p: point;	BEGIN		TheMode := breeding;		OldBox := special;		EraseRect(PRect);{IF Margin.bottom - Margin.top > Box[MidBox].bottom - Box[Midbox].top THEN}{NRows := 1;}		SetUpBoxes;		OldSpecial := 0;		SetCursor(CursList[watchCursor]^^);		Child[MidBox] := child[special];		Special := MidBox;		MakeGeneBox(Child[special]);		Delayvelop(Child[Special], Centre[MidBox], Midbox);		p := centre[MidBox];		p.v := box[MidBox].bottom - 1;		Evolve(p);		StoreOffScreen(MainPtr^.PortRect, MyBitMap);	END; {DoBreed}PROCEDURE DoHighlight;	VAR		j: Integer;		Ticking: Boolean;		TickValue: LongInt;	BEGIN		Ticking := FALSE;		IF (TheMode = Phyloging) OR (TheMode = Moving) OR (TheMode = Detaching) OR (TheMode = Killing) THEN {OR (theMode=Noahing)}			BEGIN				InvertRect(SpecialFull^^.Surround);				TickValue := TickCount;				Ticking := TRUE;			END;		IF (theMode = breeding) OR (TheMode = Drifting) THEN			BEGIN				OldSpecial := Special;				InvertRect(box[Special]);				TheMode := Highlighting;				MakeGeneBox(child[special]);			END;		IF theMode = Albuming THEN			OldSpecial := Special;		IF Ticking THEN			BEGIN				REPEAT				UNTIL TickCount - TickValue >= 30;				InvertRect(SpecialFull^^.Surround);			END	END; {DoHighlighting}PROCEDURE PictureToScrap;	VAR		LENGTH: LongInt;		Source: Ptr;	BEGIN		IF ZeroScrap <> NoErr THEN			BEGIN				Sysbeep(1); {write('ZeroScrap Error')}			END		ELSE			BEGIN				HLock(handle(MyPicture));				Length := MyPicture^^.PicSize;				Source := Ptr(MyPicture^);				IF PutScrap(Length, 'PICT', Ptr(MyPicture^)) <> NoErr THEN					ExitToShell;				HUnlock(handle(MyPicture));			END;		ClipBoarding := TRUE;	END;PROCEDURE SendToClipBoard;	VAR		HS: Integer;		errString, helpString: Str255;	BEGIN		MyPicture := OpenPicture(Box[MidBox]);		Delayvelop(Child[Special], Centre[MidBox], MidBox);		CopiedAnimal := Child[special];		ClosePicture;		HS := GetHandleSize(Handle(MyPicture));		IF (HS = 0) OR (HS > 32000) THEN			BEGIN				errString := GetString(131)^^;				helpString := GetString(132)^^;				DisplayError(0, errString, helpString, StopError);{was: (uses Help dialog! ) Message(GetString(TooLargeString))}			END		ELSE			PictureToScrap;		KillPicture(MyPicture);	END; {SendToClipBoard}PROCEDURE DoResources (theBiomorph: Person; WDetails, DDetails, TDetails: MarchingOrders);	VAR		maxx, maxy, MaxZ, x, y, z, b, theID, ErrorMessage, ShellFileNumber, MainFileNumber: integer;		W, D, T: real;		thePicture: PicHandle;		s1, s2, s3, theString: str255;		HSize: LongInt;		MyHandle: Handle;		ErrorCode: OSErr;		MyReply: SFReply;		MyPoint: Point;		MyFileType: OSType;	PROCEDURE theDeed;		BEGIN			WITH theBiomorph DO				BEGIN					DDisplacement := D;					WOpening := W;					TTranslation := T;					ClipRect(Prect);					EraseRect(Prect);					thePicture := OpenPicture(Box[MidBox]);					ShowPen;					Develop(theBiomorph, Centre[MidBox]);					WITH Box[Midbox] DO						BEGIN							MoveTo(left + 2, bottom - 2);							RealToString(WOpening, s1);							RealToString(DDisplacement, s2);							RealToString(TTranslation, s3);							theString := concat('W=', s1, ' ', 'D=', s2, ' ', 'T=', s3);							DrawString(theString);						END;					ClosePicture;					REPEAT						theID := UniqueID('PICT')					UNTIL theID >= 128;					MyHandle := handle(thePicture);					HSize := SizeOf(thePicture);					IF HSize > 32000 THEN						sysbeep(1)					ELSE						BEGIN							ShellFileNumber := OpenResFile(MyReply.fname);							UseResFile(ShellFileNumber);							AddResource(MyHandle, 'PICT', theID, theString);							ErrorMessage := ResError;							IF ErrorMessage = NoErr THEN								WriteResource(MyHandle)							ELSE								ErrorMessage := ErrorMessage;						END;					CloseResFile(ShellFileNumber);					KillPicture(thePicture);					UseResFile(MainFileNumber);				END; {with biomorph}		END;{theDeed}	BEGIN		theMode := arraying;		MainFileNumber := CurResFile;		FindDlogPosition('DLOG', PutDlgID, MyPoint);		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		SFPutFile(MyPoint, '', '', NIL, MyReply);		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		IF MyReply.good THEN			BEGIN				CreateResFile(MyReply.fname);				W := WDetails.start;				Maxy := round(Wdetails.till);				FOR y := 1 TO maxy DO					BEGIN						D := DDetails.start;						WHILE D < DDetails.till DO							BEGIN								T := TDetails.start;								WHILE T < TDetails.till DO									BEGIN										theDeed;										T := T + TDetails.by;									END; {x loop}								D := D + DDetails.by							END; {D loop}						w := w * WDetails.By;					END;{W loop}			END; {my reply good}	END; {DoResources}PROCEDURE DoArray (theBiomorph: person; WDetails, DDetails, TDetails: MarchingOrders);	VAR		b, verdict: integer;		W, D, T, X: real;		s, s1, s2, s3, theString: str255;		HoldConstant, RowChap, ColChap: MarchingOrders;	PROCEDURE theBusiness (other: str255);		BEGIN			b := b + 1;			WITH theBiomorph DO				BEGIN					WOpening := W;					CASE colChap.kind OF						Dis: 							DDisplacement := X;						Trans: 							TTRanslation := X;					END; {cases}					develop(theBiomorph, centre[b]);				END;		END;	PROCEDURE OtherW (other: str255);{enter all these routines with all three starting values set, with b zeroed and with SetUpBoxes called to fix NRows & NCols}		VAR			j: integer;		BEGIN			X := rowChap.start;			WITH theBiomorph DO				BEGIN					WHILE X <= rowChap.till DO						BEGIN							W := WDetails.start;							FOR j := 1 TO round(WDetails.till) DO								BEGIN									b := b + 1;									WITH theBiomorph DO										BEGIN											WOpening := W;											CASE rowChap.kind OF												Dis: 													BEGIN														DDisplacement := X;														TTranslation := T;													END;												Trans: 													BEGIN														TTRanslation := X;														DDisplacement := D;													END;											END; {cases}											develop(theBiomorph, centre[b]);										END;									IF b <= NCols THEN										WITH box[b] DO											BEGIN												MoveTo(left + 50, top - 5);												DrawString('W=');												DrawReal(W);											END;									IF B - NCols * (B DIV NCols) = 1 THEN										WITH box[b] DO											BEGIN												MoveTo(left + 2, bottom - 2);												DrawString(concat(other, '='));												DrawReal(X);											END;									X := X + rowChap.by;								END;							W := W * WDetails.by;						END;				END;		END;{OtherW}	PROCEDURE WOther (other: str255);{enter all these routines with all three starting values set, with b zeroed and with SetUpBoxes called to fix NRows & NCols}		VAR			j: integer;		BEGIN			W := WDetails.start;			WITH theBiomorph DO				BEGIN					FOR j := 1 TO round(WDetails.till) DO						BEGIN							X := colChap.start;							WHILE round(10 * X) <= round(10 * colChap.till) DO								BEGIN									b := b + 1;									WITH theBiomorph DO										BEGIN											WOpening := W;											CASE colChap.kind OF												Dis: 													BEGIN														DDisplacement := X;														TTranslation := T;													END;												Trans: 													BEGIN														TTRanslation := X;														DDisplacement := D;													END;											END; {cases}											develop(theBiomorph, centre[b]);										END;									IF b <= NCols THEN										WITH box[b] DO											BEGIN												MoveTo(left + 50, top - 5);												DrawString(concat(other, '='));												DrawReal(X);											END;									IF B - NCols * (B DIV NCols) = 1 THEN										WITH box[b] DO											BEGIN												MoveTo(left + 2, bottom - 2);												DrawString('W=');												DrawReal(W);											END;									X := X + colChap.by;								END;							W := W * WDetails.by;						END;				END;		END;{WOther}	PROCEDURE OtherOther (rowString, colString: str255);{enter all these routines with all three starting values set, with b zeroed and with SetUpBoxes called to fix NRows & NCols}		VAR			X, Y: real;		BEGIN			W := WDetails.start;			Y := rowChap.start;			WITH theBiomorph DO				BEGIN					WHILE round(10 * Y) <= round(10 * rowChap.till) DO						BEGIN							X := colChap.start;							WHILE round(10 * X) <= round(10 * colChap.till) DO								BEGIN									b := b + 1;									IF b <= NCols THEN										WITH box[b] DO											BEGIN												MoveTo(left + 50, top - 5);												DrawString(concat(colString, '='));												DrawReal(X);											END;									IF B - NCols * (B DIV NCols) = 1 THEN										WITH box[b] DO											BEGIN												MoveTo(left + 2, bottom - 2);												DrawString(concat(rowString, '='));												DrawReal(Y);											END;									WITH theBiomorph DO										BEGIN											WOpening := W;											CASE rowChap.kind OF												Dis: 													DDisplacement := Y;												Trans: 													TTRanslation := Y;											END; {cases}											CASE colChap.kind OF												Dis: 													DDisplacement := X;												Trans: 													TTRanslation := X;											END; {cases}											develop(theBiomorph, centre[b]);										END;									X := X + colChap.by;								END;							Y := Y + rowChap.by;						END;				END;		END;{OtherOther}	BEGIN		theMode := Arraying;		HoldConstant := DDetails;		RowChap := WDetails;		ColChap := TDetails;		IF LayoutDialog(HoldConstant, RowChap, ColChap, NRows, NCols) THEN			BEGIN				NBoxes := NRows * NCols;				EraseRect(PRect);				setupboxes;				b := 0;				WITH box[1] DO					WITH theBiomorph DO						BEGIN							MoveTo(left + 2, top - 13);							DrawString('   Graininess = ');							DrawReal(CoarseGraininess);							DrawString('     Reach = ');							DrawReal(reach);						END;				b := 0;				W := WDetails.start;				D := DDetails.start;				T := TDetails.start;				CASE rowChap.kind OF					Wop: 						CASE colChap.kind OF							Dis: 								BEGIN									DrawString('   T=');									DrawReal(TDetails.start);									WOther('D');								END;							Trans: 								BEGIN									DrawString('   D=');									DrawReal(DDetails.start);									WOther('T');								END;						END; {cases}					Dis: 						CASE colChap.kind OF							Wop: 								BEGIN									DrawString('   T=');									DrawReal(TDetails.start);									OtherW('D');								END;							Trans: 								BEGIN									DrawString('   W=');									DrawReal(WDetails.start);									OtherOther('D', 'T');								END;						END; {cases}					Trans: 						CASE colChap.kind OF							Wop: 								BEGIN									DrawString('   D=');									DrawReal(DDetails.start);									OtherW('T');								END;							Dis: 								BEGIN									DrawString('   W=');									DrawReal(WDetails.start);									OtherOther('T', 'D');								END;						END; {cases}				END; {cases}				StoreOffScreen(MainPtr^.PortRect, MyBitMap);			END;	END; {DoArray}END.