UNIT Triangle;INTERFACEUSES	Biomorphs;PROCEDURE AtLeast (VAR OutRect: Rect);PROCEDURE OwnCursor (theRect: Rect; fromBitMap: BitMap; VAR theCursor: Cursor);PROCEDURE MainTriangle;PROCEDURE PlotTriangle (MLoc: point; Localswitch: Boolean);PROCEDURE FlickerTriangle (MLoc: Point);IMPLEMENTATIONPROCEDURE Triangle (VAR r1, r2, r3: real; b: point; m: point);	VAR		x, y, k: real;		screenheight: LONGINT;	BEGIN		screenheight := screenbits.bounds.bottom - screenbits.bounds.top;		k := round(200 * screenheight / 340);		x := m.h - b.h;		y := (screenheight - m.v) - (screenheight - b.v);		r1 := y / k;		r3 := (x - y / 2) / k;		r2 := (k - x - y / 2) / k;	END; {triangle}PROCEDURE DrawTriangle (a, b, c: point);	BEGIN		Moveto(a.h, a.v);		LineTo(b.h, b.v);		LineTo(c.h, c.v);		LineTo(a.h, a.v);	END; {drawtriangle}PROCEDURE Concoct (r1, r2, r3: real; a, b, c: person; VAR new: person);	VAR		hand, j, weight: Integer;	FUNCTION Force3 (r: real): Integer;		VAR			i: Integer;		BEGIN			i := round(r);			IF i > 2 THEN				i := 2;			IF i < 0 THEN				i := 0;			Force3 := i		END; {Force3}	FUNCTION Force2 (r: real): Integer;		VAR			i: Integer;		BEGIN			i := round(r);			IF i > 1 THEN				i := 1;			IF i < 0 THEN				i := 0;			Force2 := i		END; {Force2}	BEGIN		WITH new DO			BEGIN				Wopening := exp(r1 * ln(a.Wopening) + r2 * ln(b.Wopening) + r3 * ln(c.Wopening));				IF WOpening < 1 THEN					BEGIN						sysbeep(1);						Wopening := 1					END;				DDisplacement := r1 * a.DDisplacement + r2 * b.DDisplacement + r3 * c.DDisplacement;				SShape := r1 * a.SShape + r2 * b.SShape + r3 * c.SShape;				TTranslation := r1 * a.TTranslation + r2 * b.TTranslation + r3 * c.TTranslation;				TranslationGradient := r1 * a.TranslationGradient + r2 * b.TranslationGradient + r3 * c.TranslationGradient;				IF TranslationGradient <= 0.1 THEN					TranslationGradient := 0.1;				reach := round(r1 * a.reach + r2 * b.reach + r3 * c.reach);				Coarsegraininess := round(r1 * a.Coarsegraininess + r2 * b.Coarsegraininess + r3 * c.Coarsegraininess);				hand := round(r1 * a.Coarsegraininess + r2 * b.Coarsegraininess + r3 * c.Coarsegraininess);				IF hand < 0 THEN					handedness := -1				ELSE					handedness := 1;			END	END; {concoct}PROCEDURE PlotTriangle (MLoc: point; Localswitch: Boolean);	VAR		margcentre, offset: Integer;		centre, where: Point;	BEGIN		IF LocalSwitch THEN			GlobalToLocal(Mloc);		triangle(r1, r2, r3, b, MLoc);		concoct(r1, r2, r3, topan, leftan, rightan, child[special]);		zeromargin := TRUE;		DelayedDrawing := true;		develop(child[special], Mloc);		grow(margin, 2);		EraseRect(margin);		FrameRect(margin);		DrawPic(MyPic, OffCentre, child[special]);		DrawTriangle(a, b, c);{MakeGeneBox(child[special]);}	END; {PlotTriangle}PROCEDURE MainTriangle;	VAR		ScreenWidth, ScreenHeight: LONGINT;		Storeanimal: person;	BEGIN		AlreadyTriangling := FALSE;		IF special > 0 THEN			Storeanimal := child[special];		LastMouse.h := -1;		LastMouse.v := -1;		eraserect(Prect);		WITH Screenbits.Bounds DO			BEGIN				ScreenWidth := right - left;				ScreenHeight := bottom - top			END;		a.h := round(234 * ScreenWidth / 512);		a.v := round(51 * ScreenHeight / 342);		b.h := round(134 * ScreenWidth / 512);		b.v := round(250 * ScreenHeight / 342);		c.h := round(333 * ScreenWidth / 512);		c.v := round(250 * ScreenHeight / 342);		mous.v := 0;		mous.h := 0;		eraserect(Prect);{drawtriangle(a, b, c);}		IF special = 0 THEN			special := 1;		PlotTriangle(a, false);		PlotTriangle(b, false);		PlotTriangle(c, false);		IF special > 0 THEN			child[special] := storeanimal;	END; {maintriangle}PROCEDURE OwnCursor (theRect: Rect; fromBitMap: BitMap; VAR theCursor: Cursor);	VAR		Box, SmallRect: Rect;		aBitMap: BitMap;		myBits16: Bits16;		SizeNeeded: LONGINT;		CanDo: Boolean;		errString, helpString: Str255;	FUNCTION MakeBits16 (theBitMap: BitMap; VAR theBits16: Bits16): Boolean;		TYPE			BitsPtr = ^Bits16;		VAR			thePtr: BitsPtr;			thebase: LONGINT;		BEGIN			SizeNeeded := LONGINT(SizeOf(BitsPtr));			IF (Memavail - SizeNeeded) < SafetyValve THEN				BEGIN					GetIndString(errString, 128, 13);			{** v1.1 **}					GetIndString(helpString, 128, 14);					DisplayError(-108, errString, helpString, StopError);					ExitToShell;{was: MemoryMessage ( 4405 , ' in making Bits16' , Verdict ); exitToShell from proc}					MakeBits16 := FALSE				END			ELSE				BEGIN					thePtr := BitsPtr(NewPtr(SizeOf(BitsPtr)));					IF MemError <> noErr THEN						ExitToShell;					thePtr := BitsPtr(theBitMap.BaseAddr);					theBits16 := thePtr^;					DisposPtr(Ptr(thePtr));					MakeBits16 := TRUE;				END; {TRUE condition}		END; {Make Bits16}	FUNCTION BigEnough (VAR theRect: Rect): Boolean;		VAR			Width, Height: Integer;		BEGIN			WITH theRect DO				BEGIN					Width := Right - Left;					Height := Bottom - Top;				END;			BigEnough := (Width > 16) AND (Height > 16);		END; {LargerRect}	BEGIN		SetRect(Box, 0, 0, 16, 16);		WITH theRect DO			BEGIN				left := left + 2;				right := right - 2;				top := top + 2;				bottom := bottom - 2			END;		aBitMap.rowBytes := 2;		aBitMap.bounds := box;		SizeNeeded := LONGINT(SizeOf(Bits16));		IF (Memavail - SizeNeeded) < SafetyValve THEN			BEGIN				GetIndString(errString, 128, 14);		{** v1.1 **}				GetIndString(helpString, 128, 4);				DisplayError(-108, errString, helpString, StopError);				ExitToShell;{was: MemoryMessage(4405, 'CanÕt make biomorphic cursor', Verdict);}				CanDo := FALSE;			END		ELSE			BEGIN				CanDo := TRUE;				aBitMap.baseAddr := NewPtr(SizeOf(Bits16));				IF MemError <> noErr THEN					ExitToShell;     {No memory available}				CopyBits(fromBitMap, aBitMap, TheRect, box, srcCopy, NIL);			END;		IF CanDo AND MakeBits16(aBitMap, MyBits16) AND (BigEnough(theRect) OR (theMode = Triangling)) THEN			BEGIN				theCursor.data := MyBits16;				theCursor.mask := curslist[breedcursor]^^.mask;				theCursor.hotSpot.v := 8;				theCursor.hotSpot.h := 8;				DisposPtr(aBitMap.baseAddr);			END		ELSE			theCursor := curslist[crosscursor]^^;	END; {OwnCursor}FUNCTION DivisibleByEight (n: Integer): Boolean;	BEGIN		DivisibleByEight := 8 * (n DIV 8) = n	END;PROCEDURE AtLeast (VAR OutRect: Rect);	VAR		width, height: Integer;	BEGIN		InsetRect(OutRect, -3, -3);		WITH OutRect DO			BEGIN				WHILE NOT (DivisibleByEight(left)) DO					left := left - 1;				WHILE NOT (DivisibleByEight(right)) DO					right := right + 1			END	END;PROCEDURE MakeNiceBox (Inbox: Rect; VAR outbox: Rect);	VAR		width, height, MidWidth, MidHeight, Widthbytes: Integer;	BEGIN		OutBox := InBox;		WITH OutBox DO			BEGIN				height := bottom - top;{1+}				width := right - left;{1+}				IF width < height THEN					width := height				ELSE					height := width;    {WidthBytes:=width DIV 8;}{    WHILE odd(WidthBytes) DO WidthBytes:=WidthBytes+1;}{    Width:=WidthBytes*8;}				left := 8;				Right := left + Width;				Top := 8;				Bottom := Top + Height;				AtLeast(outbox);				right := right + 1;			END;	END; {MakeNiceBox}PROCEDURE CursSnap (ThisPic: Pic; box: Rect; offset: Integer; biomorph: person);	VAR		Midpoint: Point;		NiceBox: Rect;		Offcen: Point;		Centre: Integer;		SavePort: GrafPtr;		SaveBitMap: Bitmap;	BEGIN {ClipRect(businessPart);}		GetPort(SavePort);		SaveBitMap := SavePort^.PortBits;		SetPortBits(AlbumBitMap[0]);		MakeNiceBox(box, NiceBox);		WITH NiceBox DO			BEGIN				MidPoint.v := top + (bottom - top) DIV 2;				MidPoint.h := left + (right - left) DIV 2;			END;		EraseRect(NiceBox); {offscreen}		Offcen := MidPoint;		Offcen.v := Offcen.v - offset;		Develop(biomorph, OffCen);		DrawPic(ThisPic, Offcentre, biomorph);		OwnCursor(Nicebox, AlbumBitMap[0], theCursor);		SetPort(SavePort);		SetPortBits(SaveBitMap);		ClipRect(MainPtr^.PortRect);	END; {CursSnap}PROCEDURE FlickerTriangle (MLoc: Point);	VAR		infant: person;		margcentre, offset: Integer;	BEGIN		triangle(r1, r2, r3, b, MLoc);		concoct(r1, r2, r3, topan, leftan, rightan, infant);		IF theMode <> triangling THEN			BEGIN			END;		DelayedDrawing := TRUE;		ZeroMargin := TRUE;		Develop(infant, MLoc);    {At this point Margin really does correctly frame the biomorph}		WITH margin DO			margcentre := top + (bottom - top) DIV 2;		offset := margcentre - MLoc.v;		CursSnap(MyPic, Margin, offset, infant);	END; {FlickerTriangle}END.