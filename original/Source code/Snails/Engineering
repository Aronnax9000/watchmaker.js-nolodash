UNIT Engineering;INTERFACEUSES	Biomorphs;PROCEDURE DoEngineer;PROCEDURE DoSaltation;PROCEDURE Manipulation (MLoc: point);FUNCTION LeftRightPos (MLoc: Point; Box: Rect): HorizPos;FUNCTION Rung (Mloc: Point; Box: Rect): VertPos;IMPLEMENTATIONPROCEDURE DoEngineer;	BEGIN		TheMode := engineering;		EraseRect(Prect);		SetUpBoxes;		child[midbox] := child[special];		special := midbox;		Delayvelop(child[special], centre[MidBox], Midbox);		MakeGeneBox(child[special]);		StoreOffScreen(MainPtr^.PortRect, MyBitMap);	END; {DoEngineer}FUNCTION LeftRightPos (MLoc: Point; Box: Rect): HorizPos;	BEGIN		WITH Box DO			IF MLoc.h < left + (right - left) DIV 3 THEN				LeftRightPos := LeftThird			ELSE IF Mloc.h > right - (right - left) DIV 3 THEN				LeftRightPos := RightThird			ELSE				LeftRightPos := MidThird	END;FUNCTION Rung (Mloc: Point; Box: Rect): VertPos;	BEGIN		WITH Box DO			IF MLoc.v < top + (bottom - top) DIV 3 THEN				Rung := TopRung			ELSE IF MLoc.v > bottom - (bottom - top) DIV 3 THEN				Rung := BottomRung			ELSE				Rung := MidRung	END;PROCEDURE SnapDevelop (Biomorph: person; Place: Point);	VAR		SnappyBox: Rect;	BEGIN		DelayedDrawing := TRUE;		SnappyBox := Margin;		ZeroMargin := TRUE;		Develop(biomorph, Place);		WITH Snappybox DO			BEGIN				IF Margin.left < left THEN					left := Margin.left;				IF Margin.right > right THEN					right := Margin.right;				IF Margin.top < top THEN					top := Margin.top;				IF Margin.bottom > bottom THEN					bottom := Margin.bottom			END;		Grow(Snappybox, MyPenSize);		Snapshot(MyPic, Snappybox, Biomorph);	END; {SnapDevelop}PROCEDURE Manipulation (MLoc: point);	VAR		j, chosenbox: Integer;		Cent: Point;		swallowing, refrain: Boolean;	BEGIN		GlobalToLocal(Mloc);		ChosenBox := 0;		IF Mloc.v < GeneBox[1].bottom THEN			FOR j := 1 TO 16 DO				IF PtInRect(MLoc, GeneBox[j]) THEN					ChosenBox := j;		j := ChosenBox;		IF ChosenBox = 0 THEN			SyringeMessage		ELSE			WITH child[special] DO				BEGIN					CASE ChosenBox OF						1: 							CASE LeftRightPos(Mloc, GeneBox[j]) OF								LeftThird: 									WOpening := Margarine(WOpening, -1);								RightThird: 									WOpening := Margarine(WOpening, 1);								MidThird: 									;							END; {pos cases}						2: 							CASE LeftRightPos(Mloc, GeneBox[j]) OF								LeftThird: 									DDisplacement := DDisplacement - DMutSize;								RightThird: 									DDisplacement := DDisplacement + DMutSize;								MidThird: 									;							END; {pos cases}						3: 							CASE LeftRightPos(Mloc, GeneBox[j]) OF								LeftThird: 									SShape := SShape - SMutSize;								RightThird: 									SShape := SShape + SMutSize;								MidThird: 									;							END; {pos cases}						4: 							CASE LeftRightPos(Mloc, GeneBox[j]) OF								LeftThird: 									TTranslation := TTranslation - TMutSize;								RightThird: 									TTranslation := TTranslation + TMutSize;								MidThird: 									;							END; {pos cases}					END; {case ChosenBox}{IF WOpening < =0 then WOpening:=0;}					IF DDisplacement < 0 THEN						DDisplacement := 0;					IF DDisplacement > 100 THEN						DDisplacement := 100;				END;		EraseRect(Box[MidBox]);		ShowGeneBox(chosenbox, child[special]);		Develop(child[special], centre[MidBox]);	END; {Manipulation}FUNCTION Randreal (Max: real): real;	VAR		rint: integer;		r: real;	BEGIN		rint := abs(random);		r := rint / 32767;		randreal := r * max;	END; {randreal}PROCEDURE DoSaltation;	VAR		j, maxgene, r: Integer;		factor: -1..1;	BEGIN		DelayedDrawing := FALSE;		special := MidBox;		WITH child[special] DO			BEGIN				WOpening := exp(randreal(4));				DDisplacement := randreal(1);				SShape := randreal(2);				TTranslation := randreal(4);				MutProb := 50;				GeneratingCurve := 0;				Handedness := Direction;				TranslationGradient := randreal(1.3);				CoarseGraininess := randint(4);				reach := Randint(4);			END;		EraseRect(Prect);		Develop(child[special], centre[midBox]);{MakeGeneBox(child[MidBox]);}		TheMode := Randoming;	END; {DoSaltation}END.