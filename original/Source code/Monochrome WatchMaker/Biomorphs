UNIT Biomorphs;INTERFACEUSES	ErrorUnit;VAR	min: Integer;PROCEDURE Develop (VAR biomorph: person; Here: point);PROCEDURE Delayvelop (VAR Biomorph: Person; Here: Point);PROCEDURE SetUpBoxes;PROCEDURE MakeGeneBox (biomorph: person);PROCEDURE Snapshot (ThisPic: Pic; box: Rect; biomorph: person);PROCEDURE ShowGeneBox (j: Integer; biomorph: person);PROCEDURE ShowChangedGene (an1, an2: person);PROCEDURE DrawPic (ThisPic: Pic; Place: Point; VAR Biomorph: person);PROCEDURE Reproduce (parent: person; VAR child: person);PROCEDURE SendToClipBoard;PROCEDURE DoHighlight;PROCEDURE DoBreed;PROCEDURE DoRowMore;PROCEDURE DoRowLess;PROCEDURE DoColMore;PROCEDURE DoColLess;PROCEDURE Targetevolve (target: person);PROCEDURE Evolve (MLoc: point);PROCEDURE Chess (VAR genotype: person);PROCEDURE BasicTree (VAR genotype: person);PROCEDURE Insect (VAR genotype: person);IMPLEMENTATIONPROCEDURE GeneBoxTemplate;	VAR		j: Integer;	BEGIN		width := (Prect.right - Prect.left) DIV 16;		WITH GeneBox[1] DO			BEGIN				left := box[1].left;				right := left + width;				top := Prect.Top;				bottom := top + GenesHeight;				EraseRect(GeneBox[1]);				Framerect(GeneBox[1])			END;		FOR j := 2 TO 16 DO			WITH GeneBox[j] DO				BEGIN					top := PRect.top;					bottom := top + GenesHeight;					left := GeneBox[j - 1].right;					right := left + width;					EraseRect(GeneBox[j]);					Framerect(GeneBox[j])				END;	END; {GeneBoxTemplate}PROCEDURE ShowGeneBox (j: Integer; biomorph: person);	VAR		thestring: str255;	BEGIN		WITH GeneBox[j] DO			BEGIN				EraseInnerRect(GeneBox[j]);				MoveTo(left - 8 + width DIV 2, top + 14);				CASE j OF					1..9: 						BEGIN {DrawInt(biomorph.gene[j]);}							Numtostring(biomorph.gene[j], thestring);							MoveTo(left + (width - stringwidth(thestring)) DIV 2, top + 14);							Drawstring(thestring);							CASE biomorph.dGene[j] OF								Shrink: 									BEGIN										MoveTo(left + 2, top + 21);										DrawChar(chr(165))									END;								Same: 									;								Swell: 									BEGIN										MoveTo(left + 2, top + 7);										DrawChar(chr(165))									END;							END; {dGene cases}						END; {1..9}					10: 						DrawInt(biomorph.SegNoGene);					11: 						BEGIN							DrawInt(biomorph.SegDistGene);							CASE biomorph.dGene[10] OF								Shrink: 									BEGIN										MoveTo(left + 2, top + 21);										DrawChar(chr(165))									END;								Same: 									;								Swell: 									BEGIN										MoveTo(left + 2, top + 7);										DrawChar(chr(165))									END;							END; {dGene cases}						END;					12: 						BEGIN							MoveTo(left + 2, top + 14);							CASE Biomorph.CompletenessGene OF								Single: 									Drawstring(AsymString);								Double: 									Drawstring(BilatString)							END						END;					13: 						BEGIN							MoveTo(left + 2, Top + 14);							CASE Biomorph.SpokesGene OF								NorthOnly: 									DrawString(SingleString);								NSouth: 									DrawString(UpDnString);								Radial: 									DrawString(RadialString);							END						END;					14: 						DrawInt(biomorph.tricklegene);					15: 						DrawInt(biomorph.MutSizegene);					16: 						Drawint(biomorph.MutProbGene);				END; {Gene Cases}			END; {WITH GeneBox}	END; {ShowGeneBox}PROCEDURE ShowChangedGene (an1, an2: person);	VAR		k: Integer;	BEGIN		IF OldBox > 0 THEN			BEGIN				FOR k := 1 TO 9 DO					IF (an1.gene[k] <> an2.gene[k]) OR (an1.dgene[k] <> an2.dgene[k]) THEN						ShowGeneBox(k, an1);				IF (an1.dgene[10] <> an2.dgene[10]) THEN					ShowGeneBox(k, an1);				IF an1.SegNoGene <> an2.SegNoGene THEN					ShowGeneBox(10, an1);				IF (an1.SegDistGene <> an2.SegDistGene) OR (an1.dgene[10] <> an2.dgene[10]) THEN					ShowGeneBox(11, an1);				IF an1.CompletenessGene <> an2.CompletenessGene THEN					ShowGeneBox(12, an1);				IF an1.SpokesGene <> an2.SpokesGene THEN					ShowGeneBox(13, an1);				IF an1.TrickleGene <> an2.TrickleGene THEN					ShowGeneBox(14, an1);				IF an1.MutSizeGene <> an2.MutSizeGene THEN					ShowGeneBox(15, an1);				IF an1.MutProbGene <> an2.MutProbGene THEN					ShowGeneBox(16, an1);			END	END; {ShowChangedGene}PROCEDURE MakeGeneBox (biomorph: person);	VAR		j: Integer;	BEGIN		GeneBoxTemplate;		FOR j := 1 TO 16 DO			ShowGeneBox(j, biomorph);	END; {MakeGeneBox}PROCEDURE Reproduce (parent: person; VAR child: person);	VAR		RI, j: Integer;	FUNCTION Direction: Integer;		BEGIN			IF randint(2) = 2 THEN				direction := child.MutSizegene			ELSE				direction := -child.MutSizegene		END;	FUNCTION Direction9: Integer;		BEGIN			IF randint(2) = 2 THEN				direction9 := 1			ELSE				direction9 := -1		END;	BEGIN		child := parent;		WITH child DO			BEGIN				IF Mut[7] THEN					IF Randint(100) < MutProbGene THEN						BEGIN							REPEAT								MutProbGene := MutProbGene + direction9;							UNTIL (abs(MutProbGene) <= 100) AND (MutProbGene <> 0);						END;				FOR j := 1 TO 8 DO					IF Randint(100) < MutProbGene THEN						Gene[j] := Gene[j] + direction;				IF Randint(100) < MutProbGene THEN					Gene[9] := Gene[9] + direction9;				IF Gene[9] < 1 THEN					Gene[9] := 1;				SizeWorry := SegNoGene * TwoToThe(gene[9]);				IF SizeWorry > WorryMax THEN					Gene[9] := Gene[9] - 1;				IF Mut[1] THEN					IF RandInt(100) < MutProbGene THEN						BEGIN							j := direction9;							SegNoGene := SegNoGene + j;							IF j > 0 THEN								BEGIN									SizeWorry := SegNoGene * TwoToThe(gene[9]);									IF SizeWorry > WorryMax THEN										SegNoGene := SegNoGene - 1;								END;						END;				IF SegNoGene < 1 THEN					SegNoGene := 1;				IF (Mut[2]) AND (SegNoGene > 1) THEN					BEGIN						FOR j := 1 TO 8 DO							IF Randint(100) < MutProbGene DIV 2 THEN								dGene[j] := RandSwell(dgene[j]);						IF Randint(100) < MutProbGene DIV 2 THEN							dGene[10] := RandSwell(dgene[10]);					END;				IF Mut[8] THEN					IF (Mut[9] AND (randint(100) < MutProbGene)) THEN						dGene[9] := RandSwell(dGene[9]);				IF (Mut[1]) AND (SegNoGene > 1) THEN					IF Randint(100) < MutProbGene THEN						SegDistGene := SegDistGene + Direction9;				IF Mut[3] THEN					IF Randint(100) < MutProbGene DIV 2 THEN						IF CompletenessGene = Single THEN							CompletenessGene := Double						ELSE							CompletenessGene := Single;				IF Mut[4] THEN					IF Randint(100) < MutProbGene DIV 2 THEN						CASE SpokesGene OF							NorthOnly: 								SpokesGene := NSouth;							NSouth: 								BEGIN									IF Direction9 = 1 THEN										SpokesGene := Radial									ELSE										SpokesGene := NorthOnly								END;							Radial: 								SpokesGene := NSouth						END;				IF Mut[5] THEN					IF Randint(100) < abs(MutProbGene) THEN						BEGIN							TrickleGene := Tricklegene + direction9;							IF TrickleGene < 1 THEN								TrickleGene := 1						END;				IF Mut[6] THEN					IF Randint(100) < abs(MutProbGene) THEN						BEGIN							MutSizeGene := MutSizeGene + direction9;							IF MutSizeGene < 1 THEN								MutSizeGene := 1						END;			END	END; {reproduce}FUNCTION Sgn (x: Integer): Integer;	BEGIN		IF x < 0 THEN			sgn := -1		ELSE IF x > 0 THEN			sgn := 1		ELSE			sgn := 0	END; {sgn}PROCEDURE Slide (LiveRect, DestRect: Rect);	VAR		SlideRect: RECT;		xDiscrep, yDiscrep, dh, dv, dx, dy, xmoved, ymoved, xToMove, yToMove, distx, disty: Integer;		TickValue: LONGINT;		upregion: RgnHandle;		{moved from globals}	BEGIN {PenMode(PatXor); FrameRect(LiveRect); PenMode(PatCopy);}		upregion := NewRgn;		{moved from initialize}		xMoved := 0;		yMoved := 0;		distx := DestRect.left - LiveRect.left;		disty := DestRect.bottom - LiveRect.bottom;		dx := sgn(distx);		dy := sgn(disty);		xToMove := ABS(distx);		yToMove := ABS(disty);		xMoved := 0;		yMoved := 0;		UnionRect(LiveRect, DestRect, SlideRect);		ObscureCursor;		REPEAT			TickValue := TickCount;			xDiscrep := xToMove - xMoved;			IF xDiscrep <= 20 THEN				dh := xDiscrep			ELSE				dh := (xDiscrep) DIV 2;			yDiscrep := yToMove - yMoved;			IF Ydiscrep <= 20 THEN				dv := yDiscrep			ELSE				dv := (yDiscrep) DIV 2;			REPEAT			UNTIL TickValue <> TickCount;			IF (xMoved < xToMove) OR (yMoved < yToMove) THEN				ScrollRect(SlideRect, dx * dh, dy * dv, upregion);			xMoved := xMoved + ABS(dh);			yMoved := yMoved + ABS(dv);		UNTIL (xMoved >= xToMove) AND (yMoved >= yToMove);	END; {Slide}PROCEDURE SetUpBoxes;	VAR		j, l, t, row, column, boxwidth: Integer;		inbox: Rect;	BEGIN		j := 0;		NBoxes := NRows * NCols;		MidBox := NBoxes DIV 2 + 1;		NActiveBoxes := NBoxes;		WITH Prect DO			BEGIN				boxwidth := (right - left) DIV ncols;				height := (bottom - top - GenesHeight) DIV nrows;				FOR row := 1 TO nrows DO					FOR column := 1 TO ncols DO						BEGIN							j := j + 1;							l := left + boxwidth * (column - 1);							t := top + GenesHeight + height * (row - 1);							setrect(box[j], l, t, l + boxwidth, t + height);							IF (TheMode = breeding) AND (j <> MidBox) THEN								FrameRect(box[j]);							WITH box[j] DO								BEGIN									Centre[j].h := left + boxwidth DIV 2;									CENTRE[j].v := top + height DIV 2								END;						END; {row & column loop}			END; {WITH Prect}		IF theMode = breeding THEN			BEGIN				PenSize(3, 3);				FrameRect(box[MidBox]);				PenSize(1, 1);			END;		WITH BusinessPart DO			BEGIN				left := box[1].left;				right := Box[NBoxes].right;				top := box[1].top;				bottom := box[Nboxes].bottom			END;	END; {setup boxes}PROCEDURE DoShowBoxes;	BEGIN		SetUpBoxes;		BoxesOnly	END;PROCEDURE PicLine (VAR ThisPic: Pic; x, y, xnew, ynew, thick: Integer);	BEGIN		IF thick > 8 THEN			thick := 8;		WITH ThisPic DO			BEGIN				IF PicSize >= PicSizeMax THEN					BEGIN{Message(GetString(TooLargeString));} {used the help dialog! v1.1 changed to alert}						DisplayError(-147, 'Biomorph too large, or other problem', ' ', StopError);						ExitToShell					END				ELSE					WITH MovePtr^ DO						BEGIN							StartPt.h := x;							StartPt.v := y;							EndPt.h := xnew;							EndPt.v := ynew;							Thickness := Thick						END;				MovePtr := linptr(size(MovePtr) + 10);  {advance 'array subscript' by number}{                                    of bytes occupied by one lin}				PicSize := PicSize + 1			END	END; {PicLine}PROCEDURE ZeroPic (VAR ThisPic: Pic; Here: Point);	BEGIN		WITH ThisPic DO			BEGIN				MovePtr := LinPtr(BasePtr);				PicSize := 0;				Origin := Here			END	END; {ZeroPic}PROCEDURE DrawPic (ThisPic: Pic; Place: Point; VAR Biomorph: person); {Pic already contains its own origin, meaning the coordinates at which}{ it was originally drawn. Now draw it at Place}	TYPE		PicStyleType = (LF, RF, FF, LUD, RUD, FUD, LSW, RSW, FSW);	VAR		j, y0, y1, x0, x1, VertOffset, HorizOffset, Mid2, belly2: Integer;		PicStyle: PicStyleType;	PROCEDURE ActualLine (PicStyle: PicStyleType; Orientation: Compass);		BEGIN			WITH ThisPic.MovePtr^ DO				BEGIN					Pensize(Thickness, Thickness);					IF Orientation = NorthSouth THEN						BEGIN							VertOffset := ThisPic.Origin.v - Place.v;							HorizOffset := ThisPic.Origin.h - Place.h;							y0 := StartPt.v - VertOffset;							y1 := EndPt.v - VertOffset;							x0 := StartPt.h - HorizOffset;							x1 := EndPt.h - HorizOffset						END					ELSE						BEGIN							VertOffset := ThisPic.Origin.h - Place.v;							HorizOffset := ThisPic.Origin.v - Place.h;							y0 := StartPt.h - VertOffset;							y1 := EndPt.h - VertOffset;							x0 := StartPt.v - HorizOffset;							x1 := EndPt.v - HorizOffset						END;					CASE PicStyle OF						LF: 							BEGIN								MoveTo(x0, y0);								LineTo(x1, y1)							END;						RF: 							BEGIN								MoveTo(Mid2 - x0, y0);								LineTo(Mid2 - x1, y1)							END;						FF: 							BEGIN								MoveTo(x0, y0);								LineTo(x1, y1);								MoveTo(Mid2 - x0, y0);								LineTo(Mid2 - x1, y1)							END;						LUD: 							BEGIN								MoveTo(x0, y0);								LineTo(x1, y1);								MoveTo(Mid2 - x0, belly2 - y0);								LineTo(Mid2 - x1, belly2 - y1);							END;						RUD: 							BEGIN								MoveTo(Mid2 - x0, y0);								LineTo(Mid2 - x1, y1);								MoveTo(x0, belly2 - y0);								LineTo(x1, belly2 - y1);							END;						FUD: 							BEGIN								MoveTo(x0, y0);								LineTo(x1, y1);								MoveTo(Mid2 - x0, y0);								LineTo(Mid2 - x1, y1);								MoveTo(x0, belly2 - y0);								LineTo(x1, belly2 - y1);								MoveTo(Mid2 - x0, belly2 - y0);								LineTo(Mid2 - x1, belly2 - y1)							END;					END; {CASES}				END		END; {ActualLine}	BEGIN		PicStyle := FF; {To correct initialisation bug, due to call in DoUpdate}		WITH biomorph DO			CASE CompletenessGene OF				Single: 					CASE SpokesGene OF						NorthOnly: 							PicStyle := LF;						NSouth: 							PicStyle := LUD;						Radial: 							PicStyle := LUD;					END;				Double: 					CASE SpokesGene OF						NorthOnly: 							PicStyle := FF;						NSouth: 							PicStyle := FUD;						Radial: 							PicStyle := FUD;					END;			END; {CASES}		PenSize(MyPenSize, MyPenSize);		Mid2 := 2 * Place.h;		belly2 := 2 * Place.v;		WITH ThisPic DO			BEGIN				MovePtr := linptr(BasePtr); {reposition at base of grabbed space}				FOR j := 1 TO PicSize DO					WITH Biomorph DO						BEGIN							ActualLine(PicStyle, NorthSouth); {sometimes rangecheck error}							IF SpokesGene = Radial THEN								BEGIN									IF CompletenessGene = Single THEN										ActualLine(RUD, EastWest)									ELSE										ActualLine(PicStyle, EastWest)								END;							ThisPic.MovePtr := linptr(size(ThisPic.MovePtr) + 10);						END;			END;		PenSize(1, 1);	END; {DrawPic}PROCEDURE Snapshot (ThisPic: Pic; box: Rect; biomorph: person);	VAR		Midpoint: Point;		SavePort: GrafPtr;		SaveBitMap: BitMap;	BEGIN		IF theMode = Sweeping THEN			ClipRect(PRect)		ELSE			ClipRect(businessPart);		WITH box DO			BEGIN				MidPoint.h := left + (right - left) DIV 2;				MidPoint.v := top + (bottom - top) DIV 2			END;		GetPort(SavePort);		SaveBitMap := SavePort^.PortBits;		SetPortBits(AlbumBitMap[0]);		EraseRect(box); {offscreen}		DrawPic(ThisPic, MidPoint, biomorph);		SetPort(SavePort);		SetPortBits(SaveBitMap);		CopyBits(AlbumBitMap[0], SavePort^.PortBits, box, box, srcCopy, NIL);		ClipRect(MainPtr^.PortRect);    {Pause('End of Snapshot ');}	END; {Snapshot}PROCEDURE Develop (VAR biomorph: person; Here: point);	VAR		order, j, x, y, seg, Upextent, Downextent, wid, ht, SizeWorry, thick: Integer;		dx, dy: ARRAY[0..7] OF Integer;		Running: chromosome;		OldHere, Centre: Point;		OddOne: Boolean;		ExtraDistance, IncDistance: Integer;	PROCEDURE Tree (x, y, lgth, dir: Integer);		VAR			xnew, ynew: Integer;		BEGIN			IF dir < 0 THEN				dir := dir + 8;			IF dir >= 8 THEN				dir := dir - 8;			IF biomorph.tricklegene < 1 THEN				biomorph.tricklegene := 1;			xnew := x + lgth * dx[dir] DIV biomorph.tricklegene;			ynew := y + lgth * dy[dir] DIV biomorph.tricklegene;			WITH margin DO				BEGIN					IF x < left THEN						left := x;					IF x > right THEN						right := x;					IF y > bottom THEN						bottom := y;					IF y < top THEN						top := y;					IF xnew < left THEN						left := xnew;					IF xnew > right THEN						right := xnew;					IF ynew > bottom THEN						bottom := ynew;					IF ynew < top THEN						top := ynew;				END;   {IF (x<>xnew) OR (y<>ynew) THEN }			IF biomorph.dGene[9] = shrink THEN				thick := lgth			ELSE IF biomorph.dGene[9] = swell THEN				thick := 1 + biomorph.Gene[9] - lgth			ELSE				thick := 1;			PicLine(MyPic, x, y, xnew, ynew, thick * MyPenSize);			IF (lgth > 1) THEN				BEGIN					IF oddone THEN						BEGIN							tree(xnew, ynew, lgth - 1, dir + 1);							IF lgth < order THEN								tree(xnew, ynew, lgth - 1, dir - 1)						END					ELSE						BEGIN							tree(xnew, ynew, lgth - 1, dir - 1);							IF lgth < order THEN								tree(xnew, ynew, lgth - 1, dir + 1)						END				END		END; {tree}	PROCEDURE PlugIn (Gene: chromosome);		BEGIN			order := gene[9];			dx[3] := gene[1];			dx[4] := gene[2];			dx[5] := gene[3];			dy[2] := gene[4];			dy[3] := gene[5];			dy[4] := gene[6];			dy[5] := gene[7];			dy[6] := gene[8];			dx[1] := -dx[3];			dy[1] := dy[3];			dx[0] := -dx[4];			dy[0] := dy[4];			dx[7] := -dx[5];			dy[7] := dy[5];			dx[2] := 0;			dx[6] := 0;		END; {PlugIn}	BEGIN {develop}		ClipBoarding := FALSE;		IF zeromargin THEN			WITH margin DO				BEGIN					left := Here.h;					right := Here.h;					right := Here.h;					top := Here.v;					bottom := Here.v;				END;		Centre := Here;		PlugIn(Biomorph.gene);		ZeroPic(MyPic, Here);		WITH biomorph DO			BEGIN				IF SegNoGene < 1 THEN					SegNoGene := 1;				IF dGene[10] = Swell THEN					Extradistance := Tricklegene				ELSE IF dGene[10] = Shrink THEN					Extradistance := -Tricklegene				ELSE					ExtraDistance := 0;				Running := gene;				IncDistance := 0;				FOR seg := 1 TO SegNoGene DO					BEGIN						OddOne := odd(seg);						IF seg > 1 THEN							BEGIN								OldHere := Here;								Here.v := Here.v + (SegDistGene + IncDistance) DIV Tricklegene;								IncDistance := IncDistance + ExtraDistance;								IF biomorph.dGene[9] = shrink THEN									thick := biomorph.Gene[9]								ELSE									thick := 1;								PicLine(MyPic, OldHere.h, Oldhere.v, Here.h, Here.v, thick);								FOR j := 1 TO 8 DO									BEGIN										IF dGene[j] = Swell THEN											Running[j] := Running[j] + Tricklegene;										IF dGene[j] = Shrink THEN											Running[j] := Running[j] - Tricklegene;									END;								IF Running[9] < 1 THEN									Running[9] := 1;								PlugIn(Running)							END;						SizeWorry := biomorph.SegNoGene * TwoToThe(biomorph.gene[9]);						IF SizeWorry > WorryMax THEN							biomorph.Gene[9] := biomorph.Gene[9] - 1;						IF biomorph.gene[9] < 1 THEN							biomorph.gene[9] := 1;						tree(Here.h, Here.v, order, 2);					END;			END;		WITH biomorph DO			WITH margin DO				BEGIN					IF Centre.h - left > right - Centre.h THEN						right := Centre.h + (Centre.h - left)					ELSE						left := Centre.h - (right - Centre.h);					Upextent := Centre.v - top; {can be zero if biomorph goes down}					Downextent := bottom - Centre.v;					IF ((SpokesGene = NSouth) OR (SpokesGene = Radial)) OR (TheMode = Engineering) THEN {Obscurely necessary to cope with erasing last Rect in Manipulation}						BEGIN							IF UpExtent > DownExtent THEN								bottom := Centre.v + UpExtent							ELSE								top := Centre.v - DownExtent						END;					IF SpokesGene = Radial THEN						BEGIN							wid := right - left;							ht := bottom - top;							IF wid > ht THEN								BEGIN									top := centre.v - wid DIV 2 - 1;									bottom := centre.v + wid DIV 2 + 1								END							ELSE								BEGIN									left := centre.h - ht DIV 2 - 1;									right := centre.h + ht DIV 2 + 1								END						END				END;		MyPic.PicPerson := biomorph;		IF NOT DelayedDrawing THEN			DrawPic(MyPic, Centre, biomorph)	END; {develop}PROCEDURE Delayvelop (VAR Biomorph: Person; Here: Point);	VAR		margcentre, offset: Integer;		OffCentre: Point;	BEGIN		DelayedDrawing := TRUE;		Zeromargin := TRUE;		develop(Biomorph, Here);		DelayedDrawing := FALSE;		WITH margin DO			margcentre := top + (bottom - top) DIV 2;		offset := margcentre - Here.v;		WITH Margin DO			BEGIN				Top := Top - Offset;				Bottom := Bottom - Offset			END;		WITH OffCentre DO			BEGIN				h := Here.h;				v := Here.v - offset;			END;		DrawPic(MyPic, offcentre, Biomorph);	END; {Delayvelop}PROCEDURE TargetEvolve (target: person);	VAR		j: Integer;		BoxesChanged, exit, BigBetter: Boolean;		SlideRect: Rect;		BestSoFar: Integer;		thisDiscrep, thisBigDiscrep: Integer;		bytesToSave: LongInt;		err: OSErr;	FUNCTION BigDiscrep (present, ideal: person): Integer;		VAR			s: Integer;		BEGIN			s := abs(present.SegNoGene - ideal.SegNoGene);			s := s + abs(present.SegDistGene - ideal.SegDistGene);			s := s + abs(present.tricklegene - ideal.tricklegene);			IF present.CompletenessGene <> ideal.CompletenessGene THEN				s := s + 1;			IF present.Spokesgene <> ideal.Spokesgene THEN				s := s + 1;			Bigdiscrep := s;		END; {BigDiscrep}	FUNCTION Discrep (present, ideal: person): Integer;		VAR			j, p, i: Integer;			s, d: Integer;		BEGIN			s := 0; {BigDiscrep(present, ideal);}			FOR j := 1 TO 9 DO				BEGIN					d := present.gene[j] - ideal.gene[j];					s := s + d * d;				END;			discrep := s		END; {discrep}	BEGIN		Exit := false;		GlobalToLocal(Mloc);		REPEAT			FOR j := 1 TO NBoxes DO				BEGIN					thisDiscrep := discrep(child[j], target);					IF thisDiscrep < min THEN						BEGIN							min := thisDiscrep;							bestSoFar := j;						END;				END;			Special := bestSoFar;			IF special > 0 THEN				BEGIN					IF min < 10 THEN						child[special].mutsizegene := 1;					ObscureCursor;					FOR j := 1 TO NBoxes DO						IF j <> special THEN							EraseRect(box[j]);					PenPat(white);					Framerect(box[special]);					PenPat(black);					Slide(box[special], box[MidBox]);					child[MidBox] := child[special];					SetUpBoxes;					PenSize(3, 3);					Framerect(box[MidBox]);					PenSize(1, 1);					FOR j := 1 TO MidBox - 1 DO						BEGIN							reproduce(child[MidBox], child[j]);							ClipRect(Box[j]);							delayvelop(Child[j], Centre[j]);						END;					FOR j := MidBox + 1 TO NBoxes DO						BEGIN							reproduce(child[MidBox], child[j]);							ClipRect(Box[j]);							delayvelop(Child[j], Centre[j])						END;				END;			ClipRect(Prect);			special := MidBox;			IF fossilizing THEN				bytesToSave := SizeOfPerson;			err := FSWrite(Slides, bytesToSave, @child[MidBox]); {Need to check these error codes - Alun}			IF min < 20 THEN				child[midbox].mutsizegene := 1;			IF GetNextEvent(mDownMask, theEvent) THEN				exit := true;			ShowChangedGene(child[MidBox], target);{writeln(generation, '   ', min);}		UNTIL (min = 0) OR exit;		IF min = 0 THEN			BEGIN				StoreOffScreen(MainPtr^.PortRect, MyBitMap);				Sysbeep(1);			END;	END; {Targetevolve}PROCEDURE Evolve (MLoc: point);	VAR		j, Margcentre: Integer;		BoxesChanged: Boolean;		SlideRect: Rect;		bytesToSave: LongInt;		err: OSErr;	PROCEDURE GrowChild (j: Integer);		VAR			k: LONGINT;		BEGIN			Cliprect(Prect);			PenMode(PatXor);			MoveTo(Centre[Midbox].h, Centre[Midbox].v);			LineTo(Centre[j].h, Centre[j].v);			k := TickCount;			REPEAT			UNTIL TickCount >= k + 2;			MoveTo(Centre[Midbox].h, Centre[Midbox].v);			LineTo(Centre[j].h, Centre[j].v);			PenMode(PatCopy);			reproduce(child[MidBox], child[j]);			ClipRect(Box[j]);			delayvelop(Child[j], Centre[j]);		END;	BEGIN		GlobalToLocal(Mloc);		j := 0;		REPEAT			j := j + 1		UNTIL (PtInRect(Mloc, box[j])) OR (j > NBoxes);		IF j <= NBoxes THEN			special := j		ELSE			special := 0;		IF special > 0 THEN			BEGIN				ObscureCursor;				FOR j := 1 TO NBoxes DO					IF j <> special THEN						EraseRect(box[j]);				PenPat(white);				Framerect(box[special]);				PenPat(black);				Slide(box[special], box[MidBox]);				child[MidBox] := child[special];				SetUpBoxes;    {delayvelop(Child[MidBox],Centre[MidBox]);}				FOR j := 1 TO MidBox - 1 DO					Growchild(j);				FOR j := MidBox + 1 TO NBoxes DO					Growchild(j);			END;		ClipRect(Prect);		special := MidBox;		IF fossilizing THEN			BEGIN				bytesToSave := SizeOfPerson;				err := FSWrite(Slides, bytesToSave, @child[MidBox]);				FossilsToSave := TRUE			END;{****}	END; {evolve}PROCEDURE DoBreed;	VAR		p: point;	BEGIN		TheMode := breeding;		OldBox := special;		EraseRect(PRect);		SetUpBoxes;		OldSpecial := 0;		SetCursor(CursList[watchCursor]^^);		Child[MidBox] := child[special];		Special := MidBox;		MakeGeneBox(Child[special]);		Delayvelop(Child[Special], Centre[MidBox]);		p := centre[MidBox];		p.v := box[MidBox].bottom - 1;		Evolve(p);		ClipRect(Box[MidBox]);		Delayvelop(Child[Special], Centre[MidBox]);		ClipRect(PRect);		StoreOffScreen(MainPtr^.PortRect, MyBitMap);	END; {DoBreed}PROCEDURE DoHighlight;	VAR		j: Integer;		Ticking: Boolean;		TickValue: LongInt;	BEGIN		Ticking := FALSE;		IF (TheMode = Phyloging) OR (TheMode = Moving) OR (TheMode = Detaching) OR (TheMode = Killing) THEN {OR (theMode=Noahing)}			BEGIN				InvertRect(SpecialFull^^.Surround);				TickValue := TickCount;				Ticking := TRUE;			END;		IF (theMode = breeding) OR (TheMode = Drifting) THEN			BEGIN				OldSpecial := Special;				InvertRect(box[Special]);				TheMode := Highlighting;				MakeGeneBox(child[special]);			END;		IF theMode = Albuming THEN			OldSpecial := Special;		IF Ticking THEN			BEGIN				REPEAT				UNTIL TickCount - TickValue >= 30;				InvertRect(SpecialFull^^.Surround);			END	END; {DoHighlighting}PROCEDURE DoRowMore;	BEGIN		Nrows := Nrows + 2;		IF NRows * Ncols > MaxBoxes THEN			NRows := NRows - 2;		EraseRect(Prect);		DoShowBoxes;		IF special > 0 THEN			Delayvelop(Child[Special], Centre[MidBox]);		OldSpecial := 0;	END; {DoRowMore}PROCEDURE DoRowLess;	BEGIN		IF Nrows > 1 THEN			Nrows := Nrows - 2;		EraseRect(Prect);		DoShowBoxes;		IF special > 0 THEN			Delayvelop(Child[Special], Centre[MidBox]);		OldSpecial := 0;	END; {DoRowLess}PROCEDURE DoColMore;	BEGIN		Ncols := Ncols + 2;		IF NRows * Ncols > MaxBoxes THEN			NCols := NCols - 2;		EraseRect(Prect);		DoShowBoxes;		IF special > 0 THEN			Delayvelop(Child[Special], Centre[MidBox]);		OldSpecial := 0;	END; {DoColMore}PROCEDURE DoColLess;	BEGIN		IF NCols > 1 THEN			NCols := Ncols - 2;		EraseRect(Prect);		DoShowBoxes;		IF special > 0 THEN			Delayvelop(Child[Special], Centre[MidBox]);		OldSpecial := 0;	END; {DoColLess}PROCEDURE PictureToScrap;	VAR		LENGTH: LongInt;		Source: Ptr;	BEGIN		IF ZeroScrap <> NoErr THEN			BEGIN				Sysbeep(1); {write('ZeroScrap Error')}			END		ELSE			BEGIN				HLock(handle(MyPicture));				Length := MyPicture^^.PicSize;				Source := Ptr(MyPicture^);				IF PutScrap(Length, 'PICT', Ptr(MyPicture^)) <> NoErr THEN					ExitToShell;				HUnlock(handle(MyPicture));			END;		ClipBoarding := TRUE;	END;PROCEDURE SendToClipBoard;	VAR		HS: Integer;		errString, helpString: Str255;	BEGIN		MyPicture := OpenPicture(Box[MidBox]);		Delayvelop(Child[Special], Centre[MidBox]);		CopiedAnimal := Child[special];		ClosePicture;		HS := GetHandleSize(Handle(MyPicture));		IF (HS = 0) OR (HS > 32000) THEN			BEGIN				errString := GetString(131)^^;				helpString := GetString(132)^^;				DisplayError(0, errString, helpString, StopError);{was: (uses Help dialog! ) Message(GetString(TooLargeString))}			END		ELSE			PictureToScrap;		KillPicture(MyPicture);	END; {SendToClipBoard}PROCEDURE MakeGenes (VAR genotype: person; a, b, c, d, e, f, g, h, i: Integer);	VAR		j: Integer;	BEGIN		WITH genotype DO			BEGIN				FOR j := 1 TO 10 DO					dgene[j] := same;				SegNoGene := 1;				SegDistGene := 150;				CompletenessGene := Double;				SpokesGene := NorthOnly;				TrickleGene := Trickle;				MutSizeGene := Trickle DIV 2;				MutProbGene := 10;				gene[1] := a;				gene[2] := b;				gene[3] := c;				gene[4] := d;				gene[5] := e;				gene[6] := f;				gene[7] := g;				gene[8] := h;				gene[9] := i;			END;	END; {makegenes}PROCEDURE Chess (VAR genotype: person);	BEGIN		makegenes(genotype, -trickle, 3 * trickle, -3 * trickle, -3 * trickle, trickle, -2 * trickle, 6 * trickle, -5 * trickle, 7);	END; {chess}PROCEDURE BasicTree (VAR genotype: person);	VAR		j: Integer;	BEGIN		makegenes(genotype, -10, -20, -20, -15, -15, 0, 15, 15, 7);		WITH genotype DO			BEGIN				SegNoGene := 2;				SegDistGene := 150;				CompletenessGene := single;				dgene[4] := shrink;				dgene[5] := shrink;				dgene[6] := shrink;				dgene[9] := shrink;				tricklegene := 9;			END;	END; {root}PROCEDURE Insect (VAR genotype: person);	BEGIN		makegenes(genotype, trickle, trickle, -4 * trickle, trickle, -trickle, -2 * trickle, 8 * trickle, -4 * trickle, 6);	END; {insect}END.