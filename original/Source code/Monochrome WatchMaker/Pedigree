UNIT Pedigree;INTERFACEUSES	Triangle, Album;PROCEDURE PhylogNew (Biomorph: Person);PROCEDURE DrawOutFrom (ThisFull: FullHandle);PROCEDURE Detach (ThisFull: FullHandle);PROCEDURE Shoot (ThisFull: FullHandle);FUNCTION MouseInBox (MLoc: Point; VAR ThisFull: FullHandle): Boolean;PROCEDURE FollowMouse (ThisFull: FullHandle);FUNCTION IsAnAdam (ThisFull: FullHandle): Boolean;FUNCTION Created: FullHandle;IMPLEMENTATIONFUNCTION Created: FullHandle;	VAR		TickValue: LongInt;		Mem: Size;		interim: FullHandle;		sizeNeeded: LongInt;		errString, helpString: Str255;	BEGIN		Mem := CompactMem(SizeOf(Full));		IF Mem < SizeOf(Full) THEN			Sysbeep(1);		SizeNeeded := SizeOf(Full);		IF (Memavail - SizeNeeded) < SafetyValve THEN			BEGIN				GetIndString(errString, 128, 15);				GetIndString(helpString, 128, 4);				DisplayError(-108, errString, helpString, StopError);				GracefulDeath;{was MemoryMessage(4405, ' in Creating new Pedigree origin', Verdict);}			END;		Interim := FullHandle(NewHandle(SizeNeeded));		IF MemError <> noErr THEN			ExitToShell;		Interim^^.Parent := NIL;		Interim^^.FirstBorn := NIL;		Interim^^.LastBorn := NIL;		Interim^^.ElderSib := NIL;		Interim^^.YoungerSib := NIL;		Interim^^.Damaged := FALSE;		Interim^^.next := NIL;		Interim^^.prec := NIL;		created := interim	END;FUNCTION MouseInBox (MLoc: Point; VAR ThisFull: FullHandle): Boolean;	VAR		Victim: FullHandle;	PROCEDURE CheckVictim (ThisFull: FullHandle);		BEGIN			IF PtInRect(MLoc, ThisFull^^.Surround) THEN				Victim := ThisFull			ELSE				BEGIN					IF ThisFull^^.Next <> NIL THEN						CheckVictim(ThisFull^^.Next)				END		END; {CheckVictim}	BEGIN		Victim := NIL;		IF ThisFull <> NIL THEN			CheckVictim(ThisFull);		IF Victim = NIL THEN			MouseInBox := FALSE		ELSE			BEGIN				ThisFull := Victim;				MouseInBox := TRUE			END	END; {MouseInBox}PROCEDURE HighlightAll (ThisFull: FullHandle);	BEGIN {Highlights Thisfull and its elder sibs, and all their descendants}		IF ThisFull <> NIL THEN			InvertRect(ThisFull^^.Surround);		IF ThisFull^^.LastBorn <> NIL THEN			HighlightAll(ThisFull^^.LastBorn);		IF ThisFull^^.ElderSib <> NIL THEN			HighlightAll(ThisFull^^.ElderSib);	END; {HighlightAllSibs}PROCEDURE HighlightPedigree (ThisFull: FullHandle);	BEGIN		IF ThisFull <> NIL THEN			BEGIN				InvertRect(ThisFull^^.Surround);				IF ThisFull^^.LastBorn <> NIL THEN					HighlightAll(ThisFull^^.LastBorn);			END	END; {HighlightPedigree}PROCEDURE FindLastGod; {Delivers last God in theGod}	VAR		thisGod: GodHandle;	PROCEDURE TryGod (thisGod: GodHandle);		BEGIN			GodCounter := GodCounter + 1;			IF thisGod^^.NextGod = NIL THEN				theGod := thisGod			ELSE				TryGod(thisGod^^.NextGod)		END; {TryGod}	BEGIN		thisGod := RootGod;		GodCounter := 1;		IF thisGod^^.NextGod = NIL THEN			theGod := thisGod		ELSE			TryGod(thisGod)	END; {FindLastGod}FUNCTION IsAnAdam (ThisFull: FullHandle): Boolean;{Returns TRUE if ThisFull is an Adam}	VAR		Yes: Boolean;		TryGod: GodHandle;	PROCEDURE AdamError (WhichError: Integer);		BEGIN			IF thisfull <> NIL THEN				InvertRect(ThisFull^^.Surround);			Sysbeep(1); {Writeln('Adam Error');}			Sysbeep(1);			IF Whicherror = 1 THEN {Writeln('Is Adam but Parent<>NIL') ELSE}{        Writeln('Not Adam, but Parent=NIL')}				;			InvertRect(ThisFull^^.Surround)		END; {AdamError}	PROCEDURE CheckAdam (ThisGod: GodHandle);		BEGIN			IF ThisGod <> NIL THEN				BEGIN					IF ThisGod^^.Adam <> NIL THEN						BEGIN							IF ThisGod^^.Adam = ThisFull THEN								BEGIN									Yes := TRUE;									theGod := thisGod								END						END;					IF ThisGod^^.NextGod <> NIL THEN						CheckAdam(ThisGod^^.NextGod);				END;		END; {CheckAdam}	BEGIN		Yes := FALSE;		tryGod := rootGod;		IF ThisFull <> NIL THEN			CheckAdam(tryGod);{IF Yes AND (ThisFull^^.parent<>NIL) THEN AdamError(1);}{IF (NOT Yes) AND (ThisFull^^.Parent=NIL) THEN AdamError(2);}		IsAnAdam := Yes	END; {IsAnAdam}PROCEDURE ShowAllAdams (theGod: GodHandle);	BEGIN		IF theGod <> NIL THEN			BEGIN				InvertRect(theGod^^.Adam^^.surround);				IF theGod^^.nextGod <> NIL THEN					ShowAllAdams(theGod^^.NextGod)			END	END;PROCEDURE ShowRelatives (thisFull: FullHandle);	BEGIN		IF thisFull <> NIL THEN			BEGIN				IF thisFull^^.parent <> NIL THEN					FrameRect(ThisFull^^.parent^^.surround);				IF thisFull^^.ElderSib <> NIL THEN					FrameRect(ThisFull^^.ElderSib^^.surround);				IF thisFull^^.YoungerSib <> NIL THEN					FrameRect(ThisFull^^.YoungerSib^^.surround);				IF thisFull^^.LastBorn <> NIL THEN					FrameRect(ThisFull^^.LastBorn^^.surround);				IF thisFull^^.FirstBorn <> NIL THEN					FrameRect(ThisFull^^.FirstBorn^^.surround);			END	END;PROCEDURE ShowAllFulls (thisFull: FullHandle);	BEGIN		IF thisFull <> NIL THEN			BEGIN				Framerect(thisFull^^.surround);				ShowRelatives(ThisFull)			END;		IF ThisFull^^.Next <> NIL THEN			ShowAllFulls(ThisFull^^.Next)	END;PROCEDURE MarkIf (ThisFull: FullHandle);	BEGIN		IF IsAnAdam(ThisFull) THEN			BEGIN				FrameInnerRect(ThisFull^^.Surround);			END	END; {MarkIf}PROCEDURE MarkUp (ThisFull: FullHandle);	BEGIN		IF ThisFull <> NIL THEN			MarkIf(ThisFull);		IF ThisFull^^.Next <> NIL THEN			MarkUp(ThisFull^^.Next)	END; {MarkUp}PROCEDURE ReDevelop (ThisFull: FullHandle);	VAR		TempSnap: BitMap;		TickValue: LongInt;	BEGIN		IF thisfull <> NIL THEN			BEGIN				TempSnap.BaseAddr := ThisFull^^.SnapHandle^;				TempSnap.rowBytes := ThisFull^^.SnapBytes;				TempSnap.Bounds := ThisFull^^.SnapBounds;				CopyBits(TempSnap, MainPtr^.PortBits, TempSnap.Bounds, thisFull^^.Surround, srcCopy, NIL);				MarkIf(ThisFull);				ThisFull^^.Damaged := FALSE;			END;	END; {ReDevelop}PROCEDURE CrossOut (ThisFull: FullHandle; Colour: Pattern);	BEGIN		IF thisfull <> NIL THEN			BEGIN				MoveTo(ThisFull^^.Surround.Left, ThisFull^^.Surround.Top);				PenPat(Colour);				LineTo(ThisFull^^.Surround.Right, ThisFull^^.Surround.Bottom);				PenNormal			END	END;PROCEDURE SetAllUndamaged (ThisFull: FullHandle);	BEGIN		IF ThisFull <> NIL THEN			BEGIN				IF ThisFull^^.Damaged THEN					CrossOut(ThisFull, White);				ThisFull^^.Damaged := FALSE;			END;		IF ThisFull^^.Next <> NIL THEN			SetAllUndamaged(ThisFull^^.Next)	END; {SetAllUndamaged}PROCEDURE JuniorIntersection (ThisFull, OtherFull: FullHandle);{Records whether any intersection between This and Other (or Other's juniors),}{    in truth value of Other^^.Damaged and This^^.Damaged}	BEGIN		IF (thisfull <> NIL) AND (OtherFull <> NIL) THEN			BEGIN				IF ThisFull <> OtherFull THEN					BEGIN						IF SectRect(ThisFull^^.Surround, OtherFull^^.Surround, DummyRect) THEN							BEGIN								OtherFull^^.Damaged := TRUE;								ThisFull^^.Damaged := TRUE							END					END;				IF OtherFull^^.Next <> NIL THEN					JuniorIntersection(ThisFull, OtherFull^^.Next);			END	END; {JuniorIntersection}PROCEDURE Coverer (ThisFull: FullHandle);	BEGIN		IF (ThisFull <> NIL) AND (ThisFull^^.Next <> NIL) THEN			JuniorIntersection(ThisFull, ThisFull^^.Next);{IF ThisFull^^.Next<>NIL THEN Coverer(ThisFull^^.Next)}	END; {Coverer}FUNCTION IsCovered (ThisFull: FullHandle): Boolean;{Returns TRUE IF Thisfull is covered by any of its own seniors}	VAR		Covered: Boolean;	PROCEDURE SeniorIntersection (ThisFull, OtherFull: FullHandle);{Records whether any intersection between This and Other (or Other's seniors,}{    in truth value of Other^^.Damaged and This^^.Damaged}		BEGIN			IF (thisfull <> NIL) AND (OtherFull <> NIL) THEN				BEGIN					IF ThisFull <> OtherFull THEN						BEGIN							IF SectRect(ThisFull^^.Surround, OtherFull^^.Surround, DummyRect) THEN								Covered := TRUE						END;					IF OtherFull^^.Prec <> NIL THEN						SeniorIntersection(ThisFull, OtherFull^^.Prec);				END		END; {SeniorIntersection}	BEGIN		IF ThisFull <> NIL THEN			BEGIN				IF ThisFull^^.Prec = NIL THEN					IsCovered := FALSE				ELSE					BEGIN						Covered := FALSE;						SeniorIntersection(ThisFull, ThisFull^^.Prec);						IsCovered := Covered;					END;			END	END; {IsCovered}FUNCTION OverEdge (ThisFull: FullHandle): Boolean;	VAR		Any: Boolean;		DestRect: Rect;	BEGIN		Any := SectRect(Prect, ThisFull^^.Surround, DestRect);    {Don't use Any, interested in DestRect}		OverEdge := NOT EqualRect(DestRect, ThisFull^^.Surround)	END; {OverEdge}PROCEDURE ReDrawAll (ThisFull: FullHandle);	BEGIN		IF ThisFull <> NIL THEN			BEGIN				MoveTo(ThisFull^^.Centre.h, ThisFull^^.Centre.v);				IF ThisFull^^.Parent <> NIL THEN					LineTo(ThisFull^^.Parent^^.Centre.h, ThisFull^^.Parent^^.Centre.v)			END;		IF ThisFull^^.LastBorn <> NIL THEN			ReDrawAll(ThisFull^^.LastBorn);		IF ThisFull^^.ElderSib <> NIL THEN			ReDrawAll(ThisFull^^.ElderSib);	END; {ReDrawAll}PROCEDURE ReDrawLines (ThisFull: FullHandle);{Draws line from each box to its parent, if it has one, treating}{original ThisFull as Adam}	BEGIN		IF ThisFull <> NIL THEN			BEGIN				MoveTo(ThisFull^^.Centre.h, ThisFull^^.Centre.v);				IF ThisFull^^.Parent <> NIL THEN					LineTo(ThisFull^^.Parent^^.Centre.h, ThisFull^^.Parent^^.Centre.v);				IF ThisFull^^.LastBorn <> NIL THEN					ReDrawAll(ThisFull^^.LastBorn);			END	END; {ReDrawLines}PROCEDURE AllLines (theGod: GodHandle);	BEGIN		IF theGod <> NIL THEN			BEGIN				IF theGod^^.Adam <> NIL THEN					ReDrawLines(theGod^^.Adam);				IF theGod^^.nextGod <> NIL THEN					AllLines(theGod^^.nextGod)			END	END; {AllLines}PROCEDURE Connect (NucleusFull, OrbitFull: FullHandle);	BEGIN		IF (nucleusfull <> NIL) AND (orbitfull <> NIL) THEN			BEGIN				MoveTo(NucleusFull^^.Centre.h, NucleusFull^^.Centre.v);				ThereAreLines := TRUE;				LineTo(OrbitFull^^.Centre.h, OrbitFull^^.Centre.v);			END	END;PROCEDURE LocalLines (ThisFull: FullHandle);	PROCEDURE ChildLine (Child: FullHandle);		BEGIN			Connect(ThisFull, Child);			IF Child^^.YoungerSib <> NIL THEN				ChildLine(Child^^.YoungerSib);		END; {ChildLine}	BEGIN		IF ThisFull^^.Parent <> NIL THEN			Connect(ThisFull, ThisFull^^.Parent);		IF ThisFull^^.FirstBorn <> NIL THEN			ChildLine(ThisFull^^.FirstBorn)	END; {LocalLines}PROCEDURE Incorporate (ThisFull: FullHandle);{Incorporates it into clip region so not drawn over in future}	BEGIN		RectRgn(Region2, ThisFull^^.Surround);		DiffRgn(DestRegion, Region2, DestRegion); {DestRegion now updated to include new box}		SetClip(DestRegion)	END; {Incorporate}PROCEDURE WithdrawProtection (ThisFull: FullHandle);	BEGIN		RectRgn(Region2, ThisFull^^.Surround);		UnionRgn(DestRegion, Region2, DestRegion); {DestRegion now updated to include new box}		SetClip(DestRegion)	END; {WithdrawProtection}PROCEDURE Protect;	PROCEDURE ProtectAll (ThisFull: FullHandle);		BEGIN			IF ThisFull <> NIL THEN				Incorporate(ThisFull);			IF ThisFull^^.Next <> NIL THEN				ProtectAll(ThisFull^^.Next)		END; {ProtectAll}	BEGIN		RectRgn(DestRegion, PRect);		IF SpecialFull <> NIL THEN			ProtectAll(SpecialFull);	END; {Protect}PROCEDURE Repair;	PROCEDURE RepairThis (ThisFull: FullHandle);		BEGIN			IF ThisFull <> NIL THEN				BEGIN					IF ThisFull^^.Damaged THEN						BEGIN							Redevelop(ThisFull);							Incorporate(ThisFull);							ThisFull^^.Damaged := FALSE						END;					IF ThisFull^^.Next <> NIL THEN						RepairThis(ThisFull^^.Next)				END		END; {RepairThis}	BEGIN		RectRgn(DestRegion, Prect);		RepairThis(SpecialFull)	END; {Repair}PROCEDURE WeedOut (ThisFull: FullHandle);	VAR		OnlyChild: Boolean;	BEGIN {WeedOut}		IF ThisFull <> NIL THEN			IF ThisFull^^.Parent <> NIL THEN				BEGIN					OnlyChild := (ThisFull^^.YoungerSib = NIL) AND (ThisFull^^.ElderSib = NIL);					IF OnlyChild THEN						BEGIN							ThisFull^^.Parent^^.LastBorn := NIL;							ThisFull^^.Parent^^.FirstBorn := NIL						END					ELSE						BEGIN {not only child}							IF ThisFull^^.YoungerSib = NIL THEN								ThisFull^^.Parent^^.LastBorn := ThisFull^^.ElderSib							ELSE								ThisFull^^.YoungerSib^^.ElderSib := ThisFull^^.ElderSib;							IF ThisFull^^.ElderSib = NIL THEN								ThisFull^^.Parent^^.FirstBorn := ThisFull^^.YoungerSib							ELSE								ThisFull^^.ElderSib^^.YoungerSib := ThisFull^^.YoungerSib;						END;				END;	END; {WeedOut}PROCEDURE WipeOut (ThisFull: FullHandle);	BEGIN		DamageRect := ThisFull^^.Surround;		Coverer(ThisFull);		IF ThisFull = SpecialFull THEN			BEGIN				OldSpecialFull := SpecialFull;				SpecialFull := ThisFull^^.Next;				ThisFull^^.Prec := NIL;{Corrected by RD Dec 1993 to cure Norton-reported bug, bombing when ancestor Killed}				ThisFull^^.Next := NIL;			END		ELSE			ThisFull^^.Prec^^.Next := ThisFull^^.Next;		IF ThisFull^^.Next <> NIL THEN			ThisFull^^.Next^^.Prec := ThisFull^^.Prec;		EraseRect(DamageRect);	END; {WipeOut}PROCEDURE KillAll (ThisFull: FullHandle);{Kill ThisFull and all its elder sibs, including all their descendants}	VAR		NextVictim, SecondVictim: FullHandle;	BEGIN		IF ThisFull <> NIL THEN			BEGIN				NextVictim := ThisFull^^.LastBorn;				SecondVictim := ThisFull^^.ElderSib;				WipeOut(ThisFull);				IF ThisFull = NIL THEN					SysBeep(1)				ELSE					BEGIN						DisposHandle(ThisFull^^.SnapHandle);						DisposHandle(Handle(ThisFull));						ThisFull := NIL					END;			END;		IF NextVictim <> NIL THEN			KillAll(NextVictim);		IF SecondVictim <> NIL THEN			KillAll(SecondVictim);	END; {KillALL}PROCEDURE Kill (ThisFull: FullHandle);{Kill this one and all its descendants}	VAR		NextVictim, SecondVictim: FullHandle;	BEGIN		IF ThisFull <> NIL THEN			BEGIN				NextVictim := ThisFull^^.LastBorn;				WipeOut(ThisFull);				IF ThisFull = NIL THEN					SysBeep(1)				ELSE					BEGIN						DisposHandle(ThisFull^^.SnapHandle);						DisposHandle(Handle(ThisFull));						ThisFull := NIL					END;				IF NextVictim <> NIL THEN					KillAll(NextVictim);			END;	END; {Kill}PROCEDURE DrawWholeLot (ThisFull: FullHandle);	BEGIN		IF THisFull <> NIL THEN			BEGIN				Redevelop(ThisFull);				Incorporate(ThisFull);				IF ThisFull^^.Next <> NIL THEN					DrawWholeLot(ThisFull^^.Next)			END	END; {DrawWholeLot}PROCEDURE Shoot (ThisFull: FullHandle);	VAR		TempFull: FullHandle;		YesAdam: Boolean;	BEGIN		FindLastGod;		YesAdam := IsAnAdam(ThisFull); {leaves theGod as ThisFull's god if any}		IF NOT YesAdam THEN			BEGIN				WeedOut(ThisFull);				Kill(ThisFull)			END		ELSE			BEGIN {only comes here if trying to kill an Adam}				IF ThisFull^^.parent <> NIL THEN					Sysbeep(1);				IF ThisFull^^.LastBorn <> NIL THEN					BEGIN						KillAll(ThisFull^^.LastBorn);						ThisFull^^.FirstBorn := NIL;						ThisFull^^.LastBorn := NIL;					END;				IF ThisFull <> NIL THEN					BEGIN						WipeOut(ThisFull);						DisposHandle(ThisFull^^.SnapHandle);						DisposHandle(Handle(ThisFull));						ThisFull := NIL					END;				IF GodCounter = 3 THEN					BEGIN						TheMode := Preliminary;						Special := 0					END;				IF theGod^^.PreviousGod = NIL THEN					SysBeep(1)				ELSE					theGod^^.PreviousGod^^.NextGod := theGod^^.NextGod;				IF theGod^^.NextGod <> NIL THEN					theGod^^.NextGod^^.PreviousGod := theGod^^.PreviousGod;				theGod^^.nextGod := NIL;				theGod^^.PreviousGod := NIL;				TheGod^^.Adam := NIL;				IF theGod = NIL THEN					SysBeep(1)				ELSE					BEGIN						DisposHandle(Handle(theGod));						theGod := NIL					END			END;{   Protect;}{   EraseRect(Prect);}{   AllLines(rootGod);}{   ClipRect(Prect);}{Repair;}		EraseRect(Prect);		RectRgn(DestRegion, PRect);		DrawWholeLot(SpecialFull);		AllLines(rootGod);		ClipRect(PRect);	END; {shoot}PROCEDURE ShootAll (thisGod: GodHandle);	BEGIN		IF thisGod <> NIL THEN			BEGIN				IF ThisGod^^.Adam <> NIL THEN					Shoot(ThisGod^^.Adam);				IF ThisGod^^.NextGod <> NIL THEN					ShootAll(ThisGod^^.NextGod)			END	END; {ShootAll}PROCEDURE Massacre (ThisFull: FullHandle);{Normally called with SpecialFull first}	BEGIN		IF ThisFull <> NIL THEN			Shoot(ThisFull);		IF ThisFull^^.Next <> NIL THEN			Massacre(ThisFull^^.Next)	END; {Massacre}PROCEDURE Detach (ThisFull: FullHandle);{Isolates ThisFull from all except its descendants, leaving rest of}{pedigree hierarchical linked list tidied up and pointing elsewhere.}{Does not touch linear Specialfull linked list, since this reflects}{spatial relations on screen, and nonrelatives can cover each other}	VAR		TempGod: GodHandle;		sizeNeeded: LongInt;		errString, helpString: Str255;	BEGIN		IF ThisFull^^.Parent <> NIL THEN			BEGIN				PenPat(White);				RectRgn(DestRegion, PRect);				Incorporate(ThisFull);				Incorporate(ThisFull^^.Parent);				Connect(ThisFull, ThisFull^^.Parent);				PenNormal;				ClipRect(Prect);				IF ThisFull^^.Parent^^.LastBorn = ThisFull THEN					ThisFull^^.Parent^^.LastBorn := ThisFull^^.ElderSib;				IF ThisFull^^.Parent^^.FirstBorn = ThisFull THEN					ThisFull^^.Parent^^.FirstBorn := ThisFull^^.YoungerSib;			END; {of whitening line connecting with ThisFull's parent}		IF ThisFull^^.YoungerSib <> NIL THEN			ThisFull^^.YoungerSib^^.ElderSib := ThisFull^^.ElderSib;		IF ThisFull^^.ElderSib <> NIL THEN			ThisFull^^.ElderSib^^.YoungerSib := ThisFull^^.YoungerSib;		ThisFull^^.ElderSib := NIL;		ThisFull^^.YoungerSib := NIL;		ThisFull^^.Parent := NIL;		SizeNeeded := LONGINT(SizeOf(God));		IF (Memavail - SizeNeeded) < SafetyValve THEN			BEGIN				GetIndString(errString, 128, 16);				GetIndString(helpString, 128, 4);				DisplayError(-108, errString, helpString, StopError);{was: MemoryMessage(4405, ' in Detaching pedigree', Verdict);}				GracefulDeath;			END;		TempGod := GodHandle(NewHandle(SizeOf(God)));		IF MemError <> noErr THEN			ExitToShell;		TempGod^^.NextGod := NIL;		FindLastGod;		TempGod^^.PreviousGod := theGod;		TempGod^^.Adam := ThisFull;		theGod^^.nextGod := TempGod;		theGod := TempGod;		MarkIf(ThisFull);	END; {Detach}PROCEDURE FollowMouse (ThisFull: FullHandle);	VAR		mous, OldMous: Point;		Height, Width, HalfHeight, HalfWidth, VertOffset, HorizOffset: Integer;		OldDamage: Rect;		TickValue: Longint;		MaskRegion: RgnHandle;		WasOverEdge: Boolean;		TempSnap: BitMap;	BEGIN		SetCursor(CursList[WatchCursor]^^);		TempSnap.BaseAddr := ThisFull^^.SnapHandle^;		TempSnap.rowBytes := ThisFull^^.SnapBytes;		TempSnap.Bounds := ThisFull^^.SnapBounds;		IF ThisFull^^.Prec = NIL THEN{Chosen one is already in front. No change}		ELSE			BEGIN {Must bring chosen one to front, after isolating it}				ThisFull^^.Prec^^.Next := ThisFull^^.Next;				IF ThisFull^^.Next <> NIL THEN					ThisFull^^.Next^^.Prec := ThisFull^^.Prec;        {Chosen one has now been isolated, still called ThisFull}				ThisFull^^.Next := SpecialFull; {This brings it to front}				SpecialFull^^.Prec := ThisFull; {This corrects old specialfull's pointer to Prec}				OldSpecialFull := SpecialFull;				SpecialFull := ThisFull; {This gives the new specialfull its proper name}				SpecialFull^^.Prec := NIL;			END;		Coverer(ThisFull); {Records all damage done by ThisFull, now also Specialfull}		Child[special] := SpecialFull^^.Genome;		WasOverEdge := OverEdge(ThisFull);		Width := ThisFull^^.Surround.Right - ThisFull^^.Surround.Left;		Height := ThisFull^^.Surround.Bottom - ThisFull^^.Surround.Top;		HalfWidth := Width DIV 2;		HalfHeight := Height DIV 2;		DamageRect := ThisFull^^.Surround;		Protect;		PenPat(White);		LocalLines(ThisFull);		GetMouse(mous);		IF thisfull <> NIL THEN			BEGIN				HorizOffset := ThisFull^^.Centre.h - mous.h;				VertOffset := ThisFull^^.Centre.v - mous.v;				ThisFull^^.Surround.Left := ThisFull^^.Centre.h - HalfWidth;				ThisFull^^.Surround.Right := ThisFull^^.Surround.Left + width;				ThisFull^^.Surround.Top := ThisFull^^.Centre.v - Halfheight;				ThisFull^^.Surround.Bottom := ThisFull^^.Surround.Top + Height;				ClipRect(PRect);				EraseRect(ThisFull^^.Surround);			END;		CopyBits(MainPtr^.PortBits, MyBitMap, Prect, Prect, srcCopy, NIL);    {store background}		CopyBits(TempSnap, MainPtr^.PortBits, TempSnap.Bounds, thisFull^^.Surround, srcCopy, NIL); {show chosen one in front}		PenMode(PatXor); {White is bad because it deletes other lines}		PenPat(Black);		Protect;		ThereAreLines := FALSE;		LocalLines(ThisFull);		HideCursor;		REPEAT			OldMous := mous;			REPEAT				GetMouse(mous)			UNTIL PtInRect(mous, PRect);			ClipRect(ThisFull^^.Surround);    {CopyBits(TempSnap,MainPtr^.PortBits,}{        TempSnap.Bounds,thisFull^^.Surround,srcCopy,NIL);} {Bring on new one}			SetClip(DestRegion);			IF (mous.h <> OldMous.h) OR (mous.v <> oldmous.v) OR (NOT Stilldown) THEN				IF thisfull <> NIL THEN					BEGIN						ThatFull^^ := ThisFull^^;						ClipRect(Prect);						TickValue := TickCount;						IF mous.v > 100 THEN							REPEAT							UNTIL TickCount <> TickValue;        {an empirically suggested device for reducing flicker}						CopyBits(MyBitMap, MainPtr^.PortBits, ThisFull^^.Surround, ThisFull^^.Surround, srcCopy, NIL); {Bring back old}						ThisFull^^.Centre.h := mous.h + HorizOffset;						ThisFull^^.Centre.v := mous.v + VertOffset;						ThisFull^^.Surround.Left := ThisFull^^.Centre.h - HalfWidth;						ThisFull^^.Surround.Right := ThisFull^^.Surround.Left + width;						ThisFull^^.Surround.Top := ThisFull^^.Centre.v - Halfheight;						ThisFull^^.Surround.Bottom := ThisFull^^.Surround.Top + Height;						IF ThereAreLines THEN							BEGIN								SetClip(DestRegion);            {TickValue:=TickCount;}{            REPEAT UNTIL TickCount<>TickValue;}								LocalLines(ThatFull); {delete old lines}							END;						ClipRect(ThisFull^^.Surround);        {TickValue:=TickCount;}{        REPEAT UNTIL TickCount<>TickValue;}						CopyBits(TempSnap, MainPtr^.PortBits, TempSnap.Bounds, thisFull^^.Surround, srcCopy, NIL);                {Bring on new one}						IF ThereAreLines THEN							BEGIN								Protect;            {TickValue:=TickCount;}{            REPEAT UNTIL TickCount<>TickValue;}								LocalLines(ThisFull)							END					END		UNTIL NOT StillDown;		ShowCursor;		SetCursor(CursList[HandCursor]^^);		PenNormal;		ClipRect(Prect);		ThisFull^^.Origin.h := mous.h + HorizOffset;		ThisFull^^.Origin.v := mous.v + VertOffset;		ThisFull^^.Damaged := TRUE;{WasOverEdge}		ClipRect(Prect);		Repair;		Protect;		AllLines(rootGod);		ClipRect(Prect);	END; {FollowMouse}PROCEDURE DrawAll;	PROCEDURE DrawSibs (ThisFull: Fullhandle);		BEGIN			IF ThisFull <> NIL THEN				ThisFull^^.Damaged := TRUE;			IF ThisFull^^.FirstBorn <> NIL THEN				DrawSibs(ThisFull^^.FirstBorn);			IF ThisFull^^.YoungerSib <> NIL THEN				DrawSibs(ThisFull^^.YoungerSib);		END; {DrawSibs}	PROCEDURE Draw (ThisFull: FullHandle);		BEGIN			ThisFull^^.Damaged := TRUE;			IF ThisFull^^.FirstBorn <> NIL THEN				BEGIN					Draw(ThisFull^^.FirstBorn);					IF ThisFull^^.FirstBorn <> NIL THEN						DrawSibs(ThisFull^^.FirstBorn^^.YoungerSib)				END		END; {Draw}	BEGIN		ClipRect(Prect);		EraseRect(Prect);		Draw(theGod^^.Adam);		Protect;		AllLines(theGod);		ClipRect(Prect);	END; {DrawAll}PROCEDURE SpawnOne (ThisFull: FullHandle; Here: Point; VAR current: FullHandle);	VAR		TempSnap: BitMap;		Width, WidthBytes, Height, voffset: Integer;		theRect: Rect;		Interim: FullHandle;		SizeNeeded: LongInt;		errString, helpString: Str255;	BEGIN		SetCursor(Curslist[WatchCursor]^^);		Current := Created;		Reproduce(ThisFull^^.Genome, Current^^.Genome);		Current^^.Origin := here;		ZeroMargin := TRUE;		DelayedDrawing := TRUE;		Develop(Current^^.Genome, here);		Current^^.Surround := Margin;		AtLeast(Current^^.Surround);		WITH Current^^.Surround DO			BEGIN				height := bottom - top;				WidthBytes := (right - left) DIV 8;				WHILE odd(WidthBytes) DO					WidthBytes := WidthBytes + 1;				Width := WidthBytes * 8;				voffset := 0;				IF top < PRect.top THEN					BEGIN						voffset := Prect.top - top;						top := Prect.top;						bottom := top + height;					END;				IF bottom > PRect.bottom THEN					BEGIN						voffset := Prect.bottom - bottom;						bottom := Prect.bottom;						top := bottom - height					END;				IF left < PRect.left THEN					BEGIN						left := PRect.left;						right := left + width					END;				IF right > Prect.right THEN					BEGIN						right := Prect.right;						left := right - width					END;			END;		EraseRect(Current^^.Surround);		Framerect(Current^^.Surround);		WITH Current^^.Surround DO			BEGIN				Current^^.Centre.h := Left + (Right - Left) DIV 2;				Current^^.Centre.v := Top + (Bottom - Top) DIV 2			END;		Here.v := current^^.origin.v + voffset;		Here.h := Current^^.Centre.h;		DrawPic(MyPic, here, Current^^.Genome);		WITH Current^^.SnapBounds DO			BEGIN				left := 0;				right := Current^^.Surround.right - Current^^.Surround.left;				top := 0;				bottom := height			END;		TempSnap.Bounds := Current^^.SnapBounds;		Current^^.SnapBytes := WidthBytes;		SizeNeeded := LONGINT(WidthBytes * Height);		IF (Memavail - SizeNeeded) < SafetyValve THEN			BEGIN				GetIndString(errString, 128, 17);	{** v1.1 **}				GetIndString(helpString, 128, 4);				DisplayError(-108, errString, helpString, StopError);{was: MemoryMessage(4405, ' in Spawning new pedigree member', Verdict);}				GracefulDeath;			END;		Current^^.SnapHandle := NewHandle(SizeNeeded);		IF MemError <> noErr THEN			ExitToShell;		TempSnap.BaseAddr := Current^^.SnapHandle^;		TempSnap.rowBytes := Current^^.SnapBytes;		CopyBits(MainPtr^.PortBits, TempSnap, Current^^.Surround, TempSnap.Bounds, srcCopy, NIL);		Current^^.Parent := ThisFull;		Current^^.ElderSib := ThisFull^^.LastBorn;		IF Current^^.ElderSib <> NIL THEN			Current^^.ElderSib^^.YoungerSib := Current;		Current^^.LastBorn := NIL;		Current^^.YoungerSib := NIL;		IF ThisFull^^.LastBorn = NIL THEN			ThisFull^^.FirstBorn := Current;		ThisFull^^.LastBorn := Current;		Current^^.Next := SpecialFull; {Puts Currentfull at head of list}		SpecialFull^^.Prec := Current;  {Updates seniority pointer of previous head}		OldSpecialFull := SpecialFull;		SpecialFull := Current;  {Gives new head its proper title}		SpecialFull^^.Prec := NIL; {Probably unnecessary but good form}		Child[Special] := Current^^.Genome;		MarkIf(Current);	END; {SpawnOne}PROCEDURE Radiate (From, Goal: Point; Spokes: Integer; VAR Here: PointArray);	VAR		dx, dy, j: Integer;	BEGIN		dx := Goal.h - From.h;		dy := Goal.v - From.v;		Here[1].h := From.h + dx;		Here[1].v := From.v + dy;		Here[2].h := From.h - dx;		Here[2].v := From.v - dy;		Here[3].h := From.h - dy;		Here[3].v := From.v + dx;		Here[4].h := From.h + dy;		Here[4].v := From.v - dx;		FOR j := 1 TO Spokes DO			BEGIN				MoveTo(From.h, From.v);				LineTo(Here[j].h, Here[j].v)			END;	END; {Radiate}PROCEDURE DrawOutFrom (ThisFull: FullHandle);	VAR		mous: Point;		square: Rect;		tickValue: LongInt;		Current, OldFull: FullHandle;		OldMous: Point;		Here: PointArray;		wid, Ht, j: Integer;		DotCursor: Cursor;	BEGIN		SetCursor(CursList[CrossCursor]^^);		ClipRect(Prect);		IF IsCovered(ThisFull) THEN			Redevelop(ThisFull);		IF ThisFull^^.Prec = NIL THEN{Chosen one is already in front. No change}		ELSE			BEGIN {Must bring chosen one to front, after isolating it}				ThisFull^^.Prec^^.Next := ThisFull^^.Next;				IF ThisFull^^.Next <> NIL THEN					ThisFull^^.Next^^.Prec := ThisFull^^.Prec;        {Chosen one has now been isolated, still called ThisFull}				ThisFull^^.Next := SpecialFull; {This brings it to front}				SpecialFull^^.Prec := ThisFull; {This corrects old specialfull's pointer to Prec}				OldSpecialFull := SpecialFull;				SpecialFull := ThisFull; {This gives the new specialfull its proper name}				SpecialFull^^.Prec := NIL;			END;		GetClip(SaveRegion);		RectRgn(DestRegion, PRect);		Protect;		PenMode(PatXor);		OwnCursor(SpecialFull^^.Surround, MainPtr^.PortBits, theCursor);		SetCursor(theCursor);		REPEAT			GetMouse(mous);{TickValue:=TickCount;}{REPEAT UNTIL TickValue<>TickCount;}{Framerect(ThisFull^^.Surround);} {Just for flicker}		UNTIL (NOT StillDown) OR (NOT PtInRect(mous, ThisFull^^.Surround));		PenNormal;		Framerect(ThisFull^^.Surround);		MarkIf(ThisFull);		Child[special] := Thisfull^^.Genome;		IF StillDown THEN			BEGIN				SetClip(DestRegion);				PenMode(PatXor);				Radiate(ThisFull^^.Centre, mous, Rays, Here);				WHILE StillDown DO					BEGIN						OldMous := Mous;						GetMouse(mous);						IF mous.v < Prect.top THEN							mous.v := Prect.top;						IF ((mous.h <> OldMous.h) OR (mous.v <> OldMous.v)) THEN {(NOT PtInRect(mous,ThisFull^^.Surround)) AND}							BEGIN								TickValue := TickCount;								REPEAT								UNTIL TickValue <> TickCount;								Radiate(ThisFull^^.Centre, OldMous, Rays, Here);								TickValue := TickCount;								REPEAT								UNTIL TickValue <> TickCount;								IF NOT PtInRect(mous, ThisFull^^.Surround) THEN									Radiate(ThisFull^^.Centre, Mous, Rays, Here)							END;					END; {WHILE loop}{Button just released}{SetCursor(CursList[WatchCursor]^^);}				Radiate(ThisFull^^.Centre, Mous, Rays, Here);				PenNormal;				j := Rays;				ClipRect(Prect);				IF NOT PtInRect(mous, ThisFull^^.Surround) THEN					WHILE j >= 1 DO						BEGIN							theCursor.data := curslist[randcursor]^^.mask;							theCursor.data[8] := 128;  {make up dot cursor}							theCursor.mask := theCursor.data;							SetCursor(theCursor);							SpawnOne(Thisfull, Here[j], Current);							j := j - 1						END				ELSE			END;		Protect;		LocalLines(ThisFull);{EraseRect(Prect);}{AllLines(rootGod);}		ClipRect(Prect);{REPEAT  GetMouse(mous)}{    UNTIL NOT PtInRect(mous,Current^^.Surround);  The purpose of this is to keep}{    the dot cursor going until we have left the new box.  But it bombs if you move back}{    to the old box before drawing has finished}		SetCursor(CursList[DrawOutCursor]^^);	END; {DrawOutFrom}PROCEDURE PhylogNew (Biomorph: Person);	VAR		MLoc: Point;		tempGod: GodHandle;		TempSnap: BitMap;		Width, Height, SizeNeeded, Avail: LongInt;		errString, helpString: Str255;	BEGIN		EraseRect(Prect);		SizeNeeded := LONGINT(SizeOf(God));		IF (Memavail - SizeNeeded) < SafetyValve THEN			BEGIN				GetIndString(errString, 128, 18);		{** v1.1 **}				GetIndString(helpString, 128, 4);				DisplayError(-108, errString, helpString, StopError);{was: MemoryMessage(4405, ' in starting up new pedigree', Verdict);}				GracefulDeath;			END;		TempGod := GodHandle(NewHandle(SizeOf(God)));		IF MemError <> noErr THEN			ExitToShell;		TempGod^^.NextGod := NIL;		FindLastGod;		TempGod^^.PreviousGod := theGod;		theGod^^.nextGod := TempGod;		theGod := TempGod;		theGod^^.Adam := Created;		theGod^^.Adam^^.Genome := Biomorph;		WITH ScreenBits.Bounds DO			BEGIN				theGod^^.Adam^^.Origin.h := (Right - Left) DIV 2;				theGod^^.Adam^^.Origin.v := (Bottom - Top) DIV 2			END;		delayvelop(theGod^^.Adam^^.Genome, theGod^^.Adam^^.Origin);		theGod^^.Adam^^.Surround := Margin;		AtLeast(theGod^^.Adam^^.Surround);		FrameRect(theGod^^.Adam^^.Surround);		FrameInnerRect(theGod^^.Adam^^.Surround);		WITH theGod^^.Adam^^.Surround DO			BEGIN				height := bottom - top;				Width := (right - left) DIV 8;				WHILE odd(Width) DO					BEGIN {Write('Odd Width');}						Width := Width + 1;					END			END;		WITH theGod^^.Adam^^.SnapBounds DO			BEGIN				left := 0;				right := theGod^^.Adam^^.Surround.right - theGod^^.Adam^^.Surround.left;				top := 0;				bottom := height			END;		TempSnap.Bounds := theGod^^.Adam^^.SnapBounds;		theGod^^.Adam^^.SnapBytes := Width;		SizeNeeded := LONGINT(Width * Height);		IF ((MemAvail - SizeNeeded) < SafetyValve) OR (SizeNeeded > 100000) THEN			BEGIN				GetIndString(errString, 128, 19);		{** v1.1 **}				GetIndString(helpString, 128, 4);				DisplayError(-108, errString, '', CautionError);{was: MemoryMessage(4405, ' in Pedigree', Verdict);}				Exit(PhylogNew);			END;		theGod^^.Adam^^.SnapHandle := NewHandle(SizeNeeded);		IF MemError <> noErr THEN			ExitToShell;		TempSnap.BaseAddr := theGod^^.Adam^^.SnapHandle^;		TempSnap.rowBytes := theGod^^.Adam^^.SnapBytes;		CopyBits(MainPtr^.PortBits, TempSnap, theGod^^.Adam^^.Surround, TempSnap.Bounds, srcCopy, NIL);		WITH theGod^^.Adam^^ DO			BEGIN				Centre.h := Surround.Left + (Surround.Right - Surround.Left) DIV 2;				Centre.v := Surround.Top + (Surround.Bottom - Surround.Top) DIV 2			END;		OldSpecialFull := SpecialFull;		IF SpecialFull <> NIL THEN			SpecialFull^^.Prec := theGod^^.Adam;    													{This corrects old specialfull's pointer to Prec}		theGod^^.Adam^^.next := SpecialFull;		SpecialFull := theGod^^.Adam;		SpecialFull^^.Prec := NIL;		TheMode := Phyloging;								{Changed July 1990}		EraseRect(Prect);		RectRgn(DestRegion, PRect);		DrawWholeLot(SpecialFull);		AllLines(rootGod);		ClipRect(PRect);	END; 				{PhylogNew}END.