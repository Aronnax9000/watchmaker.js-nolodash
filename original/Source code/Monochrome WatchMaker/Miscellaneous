UNIT Miscellaneous;{******************************************************}{*												v1.1 Sept 1993														 *}{*																															 *}{*		Changed Message procs to use Alerts																 *}{*		Removed PictMessage (never called), change Message calls to DisplayError	 *}{*		Added positioning to alerts and dialogs															 *}{*		Alert now uses STR# for closing, quitting, etc		  										 *}{*		Added several functions, for EOF and checking system (see below)					 *}{*     Validated the rect after RestoreOffscreen to prevent drawing twice				 *}{******************************************************}INTERFACEUSES	Globals;FUNCTION FossilsExist: Boolean;PROCEDURE DireMessage (string1ID, string2ID: Integer; VAR Verdict: Integer; YesNo: Boolean);PROCEDURE MemoryMessage (ID: Integer; InMessage: Str255; VAR Verdict: Integer); { 27291 for Fewer album screens, 27295 for Careful}PROCEDURE SimpleMessage (ID: Integer; VAR Verdict: Integer);PROCEDURE HelpMessage (StrID: Integer);PROCEDURE SyringeMessage;PROCEDURE Pause (Message: Str255);PROCEDURE SetItemState (Mndx, Indx: Integer; Flag: Boolean);FUNCTION RandInt (Max: Integer): Integer;FUNCTION Odd (i: Integer): Boolean;FUNCTION RandSwell (Indgene: Swelltype): SwellType;PROCEDURE EraseInnerRect (box: Rect);PROCEDURE FrameOuterRect (box: Rect);PROCEDURE FrameInnerRect (box: Rect);PROCEDURE StoreOffScreen (box: Rect; VAR Snapshot: BitMap);PROCEDURE RestoreOffScreen (box: Rect; Snapshot: BitMap);PROCEDURE CleanUp;PROCEDURE MakeOffScreen (box: Rect; VAR Snapshot: BitMap; VAR Burst: Boolean);PROCEDURE DrawInt (i: Integer);PROCEDURE Drawi (i: Integer);PROCEDURE Grow (VAR Box: Rect; d: Integer);PROCEDURE BoxesOnly;PROCEDURE OwnEditMenu;FUNCTION DawkFilter (param: ParmBlkPtr): Boolean;PROCEDURE SmallMenus;PROCEDURE LargeMenus;PROCEDURE BigFuncBox (Box: Rect; VAR Outbox: Rect);PROCEDURE SmallFuncBox (Box: Rect; VAR Outbox: Rect; BoxSize: Integer);PROCEDURE FuncBox (Box: Rect; VAR Outbox: Rect; BoxSize: Integer);PROCEDURE Poop (n: Integer);PROCEDURE StartDocuments (DocumentCount: Integer);FUNCTION TwoToThe (n: integer): integer;{*****  Procedures added for v1.1 ********}										{ Operating System utilities }FUNCTION TrapAvailable (theTrap: integer): Boolean;FUNCTION WNEIsImplemented: Boolean;FUNCTION TempMemCallsAvailable: Boolean;PROCEDURE DeleteOldFile (volRefNum: Integer; dirID: LongInt; fileName: Str255);										{ Dialog Manager utilities		}PROCEDURE PositionDialog (theType: ResType; theID: integer);PROCEDURE FindDlogPosition (theType: ResType; theID: integer; VAR corner: Point);FUNCTION IsEOF (refNum: Integer; howClose: LongInt): Boolean;FUNCTION FileSize (refNum: Integer): LongInt;		{returns the number of bytes in the file. Same as}{	the toolbox function GetEOF, except this returns the size instead of an error code. It has this name to emulate the }{   Turbo routine, except this returns bytes (since we don't use pascal type-files now).}IMPLEMENTATIONUSES	Script, SysEqu, Traps;{*	Operating System utilities	*}{****************************************************}{ TrapAvailable}{}{ 	Check whether a certain trap exists on this machine.  }{ this function uses the new approved method as per IM-VI}{	p. 3-8												}{}{****************************************************}FUNCTION TwoToThe (n: integer): integer;	VAR		t: integer;	BEGIN		CASE n OF			0: 				t := 1;			1: 				t := 2;			2: 				t := 4;			3: 				t := 8;			4: 				t := 16;			5: 				t := 32;			6: 				t := 64;			7: 				t := 128;			8: 				t := 256;			9: 				t := 512;			10: 				t := 1024;			11: 				t := 2048;			12: 				t := 4096;			OTHERWISE				t := 8192		END; {cases}		TwoToThe := t	END; {TwoToThe}FUNCTION TrapAvailable (theTrap: Integer): Boolean;	VAR		tType: TrapType;		numToolBoxTraps: Integer;	BEGIN 		(* first determine the trap type *)		IF BAND(theTrap, $0800) > 0 THEN			tType := ToolTrap		ELSE			tType := OSTrap; 		(* next find out how may traps there are *)		IF NGetTrapAddress(_InitGraf, ToolTrap) = NGetTrapAddress($AA6E, ToolTrap) THEN			numToolBoxTraps := $200		ELSE			numToolBoxTraps := $400; 		(* check if trap number is too big for current trap table *)		IF tType = ToolTrap THEN			BEGIN				theTrap := BAND(theTrap, $07FF);				IF theTrap >= numToolBoxTraps THEN					theTrap := _Unimplemented;			END; 		(* the trap is implemented if its address is different 	*) 		(* from the unimplemented trap's address				*)		TrapAvailable := NGetTrapAddress(theTrap, tType) <> NGetTrapAddress(_Unimplemented, ToolTrap);	END;{****************************************************}{ WNEIsImplemented}{}{ 	See if WaitNextEvent is implemented }{}{****************************************************}FUNCTION WNEIsImplemented: Boolean;	CONST		_WaitNextEvent = $A860;					{ WaitNextEvent trap					}	VAR		theWorld: SysEnvRec;						{ System environment				}		errCode: OSErr;	BEGIN		errCode := SysEnvirons(1, theWorld);		{ Check environment					}		IF theWorld.machineType < 0 THEN 			{ Old ROMs, definitely not present	}			WNEIsImplemented := FALSE		ELSE											{ Check for WNE trap					}			WNEIsImplemented := TrapAvailable(_WaitNextEvent)	END;{****************************************************}{ TempMemCallsAvailable}{}{ 	Check whether the MultiFinder temporary memory calls are available}{}{****************************************************}FUNCTION TempMemCallsAvailable: Boolean;	CONST		_OSDispatch = $A88F;						{ Temporary MF memory calls		}	BEGIN						{ Check for the OSDispatch trap	}		TempMemCallsAvailable := TrapAvailable(_OSDispatch);	END;{*	Dialog Manager utilities	*}{****************************************************}{ PositionDialog}{}{		Center the bounding box of a dialog or alert in the upper third}{		of the screen.  This is the preferred location according to the}{		Human Interface Guidelines.}{}{****************************************************}PROCEDURE PositionDialog (theType: ResType; theID: integer);	VAR		theRect: Rect;		theRectPtr: RectPtr;		{ Ptr to bounding box of dialog	}		theTemplate: Handle;		{ Handle to resource template	}		left,							{ Left side of centered rect		}		top: integer;				{ Top side of centered rect		}	BEGIN		{ The first field of the resource template for DLOG's and ALRT's 	}		{ is its bounding box.  Get a pointer to this rectangle.  This   			}		{ handle dereferencing is safe since the remaining statements in 	}		{ this function do not move memory (assignment and simple math). 	}		theTemplate := GetResource(theType, theID);		IF resError <> noErr THEN			Exit(PositionDialog);	{If we fail to load it, forget about positioning}		theRectPtr := RectPtr(theTemplate^);		theRect := theRectPtr^;		IF (theRect.left >= theRect.right) OR (theRect.top >= theRect.bottom) THEN			Exit(PositionDialog); {Position Dialog is creating problems that I don't understand.  RD}{e.g. theRect can have a left bigger than its right}		{ Center horizontally on screen	}		left := (screenBits.bounds.right - (theRect.right - theRect.left)) DIV 2;		{ Leave twice as much space as above	 }		top := (screenBits.bounds.bottom - (theRect.bottom - theRect.top)) DIV 3;		{ Don't put rect under menu bar	}		IF top < GetMBarHeight + 7 THEN			top := GetMBarHeight + 7;		theRect.right := theRect.right + left - theRect.left;		theRect.left := left;		theRect.bottom := theRect.bottom + top - theRect.top;		theRect.top := top;		theRectPtr^ := theRect;	END;{****************************************************}{ FindDLOGPosition}{}{ 		Return the coordinates of the top left corner of a dialog or alert}{ 		which centers the box in the upper third of the main screen. This is}{ 		the preferred location according to the Human Interface Guidelines.}{}{****************************************************}PROCEDURE FindDlogPosition (theType: ResType; theID: integer; VAR corner: Point);	TYPE		RectPtr = ^Rect;		RectHandle = ^RectPtr;	VAR		theRect: Rect;		{ Bounding box of dialog				}		left, top: integer;	{ Left, top side of centered rect		}	BEGIN		{ The first field of the resource template for DLOG's and ALRT's 	}		{ is its bounding box.  Access this rectangle.  This   					}		{ handle dereferencing is safe since the remaining statements in 	}		{ this function do not move memory (assignment and simple math). 	}		theRect := RectHandle(GetResource(theType, theID))^^;		{ Center horizontally on screen	}		corner.h := (screenBits.bounds.right - (theRect.right - theRect.left)) DIV 2;		{ Leave twice as much space as above	 }		corner.v := (screenBits.bounds.bottom - (theRect.bottom - theRect.top)) DIV 3;		{ Don't put rect under menu bar	}		IF corner.v < GetMBarHeight + 7 THEN			corner.v := GetMBarHeight + 7;	END;PROCEDURE DeleteOldFile (volRefNum: Integer; dirID: LongInt; fileName: Str255);{If there was a crash, the fossil file may be present but busy. We need to convince the }{finder that it is okay to delete it}	VAR		info: CInfoPBRec;		info2: ParamBlockRec;		err: OSErr;	BEGIN		WITH info DO			BEGIN				ioCompletion := NIL;				ioNamePtr := @fileName;				ioDirID := dirID;				ioVRefNum := volRefNum;				ioFDirIndex := 0;				err := PBGetCatInfo(@info, FALSE);				IF err = noErr THEN		{if it exists}					BEGIN						IF ioFRefNum <> 0 THEN   {File has been left open}							BEGIN								info2.ioCompletion := NIL;								info2.ioRefNum := ioFRefNum;								err := PBClose(@info2, FALSE);							END;						err := HDelete(volRefNum, dirID, fileName);					END;{if}			END;{with}	END;{DeleteOldFile}FUNCTION IsEOF (refNum: Integer; howClose: LongInt): Boolean;{Acts like Pascal's eof() function, but in addition you can specify how close to the end of the file}{you are allowed to be (takes care of truncated files)}	VAR		err: OSErr;		eof, positionNow: LongInt;	BEGIN		IsEOF := TRUE;		err := GetFPos(refNum, positionNow);		err := GetEOF(refNum, eof);		IF err <> noErr THEN			Exit(IsEOF);		{If something went wrong, we should stop reading}		IsEOF := (eof - positionNow) < howClose	END;FUNCTION FileSize (refNum: Integer): LongInt;	VAR		err: OSErr;		numBytes: LongInt;	BEGIN		err := GetEOF(refnum, numBytes);		IF err <> noErr THEN			numBytes := 0;	{Problem with the file, should signal an exception here.}		FileSize := numBytes;	END;{***** End of v1.1 additions*****}FUNCTION FossilsExist: Boolean;{replace, but not precisely mimic, Turbo's built-in function}	VAR		Err: OSErr;		filePos: LongInt;	BEGIN		Err := GetFPos(slides, FilePos);		FossilsExist := FilePos > 0	END; {FossilsExist}PROCEDURE DireMessage (string1ID, string2ID: Integer; VAR Verdict: Integer; YesNo: Boolean);{v1.1 changed DLOGs to ALRTs.}{}	VAR		theItem: Integer;		MessagePtr: DialogPtr;		string1, string2: Str255;	BEGIN		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		GetIndString(string1, kAlertStringsID, string1ID);		GetIndString(string2, kAlertStringsID, string2ID);		ParamText(string1, string2, '', '');		IF YesNo THEN			BEGIN				IF gSystem.systemVersion < $0700 THEN		{added v1.1}					PositionDialog('ALRT', 151);					{Save changes alert. YesNo?}				theItem := CautionAlert(151, NIL);			END		ELSE			BEGIN				IF gSystem.systemVersion < $0700 THEN		{added v1.1}					PositionDialog('ALRT', 17089);				theItem := CautionAlert(17089, NIL);			END; { get dialog box}		Verdict := theItem;		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		FlushEvents(EveryEvent, 0);		ValidRect(Prect);	END; { of proc DireMessage }PROCEDURE MemoryMessage (ID: Integer; InMessage: Str255; VAR Verdict: Integer); {27291 for Fewer album screens, 27295 for Careful}{*** Change this to handle appropriate type alerts with strings from STR# ***}{ v1.1 changed to alerts, position correctly on screen,}{ ID 4405 (got to quit) message changed to DisplayError call}	VAR		theItem: Integer;		MessagePtr: DialogPtr;	BEGIN		SetCursor(CursList[CrossCursor]^^);		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		IF (ID = 27295) THEN			InMessage := '';		ParamText('', InMessage, '', '');		IF gSystem.systemVersion < $0700 THEN		{added v1.1}			PositionDialog('ALRT', ID);		theItem := CautionAlert(ID, NIL);		Verdict := theItem;		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		FlushEvents(EveryEvent, 0);		ValidRect(Prect);	END; {MemoryMessage}PROCEDURE SimpleMessage (ID: Integer; VAR Verdict: Integer);{v1.1 redesigned the alert slightly and made it a Caution Alert. This procedure}{seems to be always called with the same string ID. If more are added, the alert}{may need to be made less specific}	VAR		S: Stringhandle;	BEGIN		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		S := GetString(ID);		ParamText(S^^, '', '', '');		IF gSystem.systemVersion < $0700 THEN		{added v1.1}			PositionDialog('ALRT', 17089);		verdict := CautionAlert(17089, NIL);	{changed v1.1}		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		FlushEvents(EveryEvent, 0);		ValidRect(Prect);	END; {SimpleMessage}PROCEDURE HelpMessage (StrID: Integer);	VAR		HelpPtr: dialogPtr;		theItem, v: Integer;		S1, S2, S3, S4: Str255;	BEGIN		GetIndString(S1, StrID, 1);		GetIndString(S2, StrID, 2);		GetIndString(S3, StrID, 3);		GetIndString(S4, StrID, 4);		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		ParamText(S1, S2, S3, S4);		IF gSystem.systemVersion < $0700 THEN		{added v1.1}			PositionDialog('DLOG', 2000);		HelpPtr := GetNewDialog(2000, NIL, Pointer(-1));		ModalDialog(NIL, theItem);             { put dialog box up; get result }		DisposDialog(HelpPtr);               { get rid of dialog box         }  {ReStoreOffScreen(MainPtr^.PortRect,MyBitMap);}		FlushEvents(EveryEvent, 0);		ValidRect(Prect);	END; { of proc HelpMessage }PROCEDURE SyringeMessage;{v1.1 Changed to alert, and set the first two alert stages to simple beeps}	VAR		SyrPtr: dialogPtr;		theItem: Integer;	BEGIN		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		IF gSystem.systemVersion < $0700 THEN		{added v1.1}			PositionDialog('ALRT', 30130);		theItem := Alert(30130, NIL);		ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);		FlushEvents(EveryEvent, 0);		ValidRect(Prect);	END; { of proc SyringeMessage }PROCEDURE Pause (Message: Str255);	BEGIN		IF Button THEN			REPEAT			UNTIL NOT Button; {Gotoxy(5,5); Writeln(message);}		REPEAT		UNTIL Button	END;PROCEDURE SetItemState (Mndx, Indx: Integer; Flag: Boolean);{}{    purpose         if true, enables item Indx of menu Mndx; else disables}{    last update     22 Aug 86}{}	BEGIN		IF Flag THEN			EnableItem(MenuList[Mndx], Indx)		ELSE			DisableItem(MenuList[Mndx], Indx)	END; { of proc SetItemState }FUNCTION RandInt (Max: Integer): Integer;	BEGIN		randint := 1 + (abs(random) MOD max);	END; {randint}FUNCTION Odd (i: Integer): Boolean;	BEGIN		Odd := 2 * (i DIV 2) <> i	END;FUNCTION RandSwell (Indgene: Swelltype): SwellType;	VAR		r: 1..3;	BEGIN		CASE Indgene OF			Shrink: 				Randswell := Same;			Same: 				IF randint(2) = 1 THEN					Randswell := Shrink				ELSE					Randswell := Swell;			Swell: 				RandSwell := Same		END {Cases}	END; {RandSwell}PROCEDURE EraseInnerRect (box: Rect);	VAR		InnerRect: Rect;	BEGIN		WITH InnerRect DO			BEGIN				left := box.left + 1;				right := box.right - 1;				top := box.top + 1;				bottom := box.bottom - 1			END;		EraseRect(InnerRect)	END; {EraseInnerRect}PROCEDURE FrameOuterRect (box: Rect);	VAR		OuterRect: Rect;	BEGIN		WITH OuterRect DO			BEGIN				left := box.left - 1;				right := box.right + 1;				top := box.top - 1;				bottom := box.bottom + 1			END;		FrameRect(OuterRect)	END; {FrameOuterRect}PROCEDURE FrameInnerRect (box: Rect);	VAR		InnerRect: Rect;	BEGIN		WITH InnerRect DO			BEGIN				left := box.left + 1;				right := box.right - 1;				top := box.top + 1;				bottom := box.bottom - 1			END;		FrameRect(InnerRect)	END; {FrameInnerRect}PROCEDURE StoreOffScreen (box: Rect; VAR Snapshot: BitMap);	BEGIN		IF FrontWindow = MainPtr THEN			CopyBits(MainPtr^.PortBits, Snapshot, box, box, srcCopy, NIL);	END; {StoreOffScreen}PROCEDURE RestoreOffScreen (box: Rect; Snapshot: BitMap);	BEGIN {IF FrontWindow=MainPtr THEN}		CopyBits(Snapshot, MainPtr^.PortBits, box, box, srcCopy, NIL);		ValidRect(box);			{**v1.1 since we have redrawn it already, }{we can stop the update event which would cause the window to be redrawn twice}	END; {RestoreOffScreen}PROCEDURE CleanUp;{}{    purpose         to do whatever's needed before returning to Finder}{}	VAR		err: OSErr;	BEGIN		err := FSClose(Slides);		err := HDelete(volRefNum, dirID, fileName);	END; { of proc CleanUp }PROCEDURE MakeOffScreen (box: Rect; VAR Snapshot: BitMap; VAR Burst: Boolean);{From system 6 onwards we can use GWorlds instead of writing our own here - Alun}	VAR		bitsRowBytes, height: Integer;		ZeroRect: Rect;		tempPtr: Ptr;		SizeNeeded: LONGINT;	BEGIN		WITH box DO			BEGIN				height := bottom - top;				bitsRowBytes := (((right - left - 1) DIV 16) + 1) * 2;			END;		WITH ZeroRect DO			BEGIN				left := 0;				right := box.right - box.left;				top := 0;				bottom := height			END;		SizeNeeded := LONGINT(bitsRowBytes) * LONGINT(height);		IF (Memavail - SizeNeeded) < SafetyValve THEN			Burst := TRUE		ELSE			BEGIN				tempPtr := NewPtr(SizeNeeded);				IF MemError <> noErr THEN					BEGIN						Sysbeep(1);						ExitToShell;					END;   {No memory available}				Snapshot.baseaddr := tempPtr;				Snapshot.bounds := zerorect;				Snapshot.rowBytes := bitsRowBytes;				Burst := FALSE;			END;	END;{MakeOffScreen}PROCEDURE DrawInt (i: Integer);	PROCEDURE Drawi (i: Integer);		VAR			l, r: Integer;		BEGIN			IF i <= 9 THEN				drawchar(chr(ord('0') + i))			ELSE				BEGIN					l := i DIV 10;					r := i - 10 * l;					drawi(l);					drawi(r);				END;		END; {drawi}	BEGIN {drawint proper}		IF i < 0 THEN			BEGIN				drawchar('-');				i := abs(i);			END		ELSE			Drawchar('+');		drawi(i);	END; {drawint}PROCEDURE Grow (VAR Box: Rect; d: Integer);	BEGIN		WITH box DO			BEGIN				left := left - d;				right := right + d;				top := top - d;				bottom := bottom + d;			END;	END; {grow}PROCEDURE BoxesOnly;	VAR		j: Integer;	BEGIN		FOR j := 1 TO NBoxes DO			FrameRect(box[j]);		theMode := preliminary;	END; {BoxesOnly}{PROCEDURE DrawNum(n:Integer);}{VAR s,c:CHAR;}{BEGIN IF n<0 THEN s:='-' ELSE s:='+';}{n:=abs(n); c:=chr(n+48);}{DrawChar(s); DrawChar(c)}{END} {DrawNum;} {This is where frillsegment used to begin}PROCEDURE OwnEditMenu;	BEGIN		SetItemState(EM, 1, FALSE);		SetItemState(EM, 2, FALSE);		SetItemState(EM, 3, FALSE);		SetItemState(EM, 4, (Special > 0) AND ((TheMode = Highlighting) OR (TheMode = Albuming)));		SetItemState(EM, 5, FALSE);		SetItemState(EM, 6, FALSE);	END; {OwnEditMenu}FUNCTION DawkFilter (param: ParmBlkPtr): Boolean;	VAR		Wanted: Boolean;	BEGIN		Wanted := (param^.ioFlFndrInfo.fdCreator = 'DAWK') AND (param^.ioFlFndrInfo.fdType <> 'APPL') AND (param^.ioFlFndrInfo.fdType <> 'BIOC') AND (param^.ioFlFndrInfo.fdType <> 'FOSS');		DawkFilter := NOT Wanted	END;PROCEDURE SmallMenus;	VAR		Indx: Integer;	BEGIN		ClearMenuBar;		InsertMenu(MenuList[AM], 0);			 {This was commented out - Alun}		InsertMenu(SpecialBreedMenu, 0);		InsertMenu(MenuList[HM], 0);		DrawMenuBar;                   { draw updated menu bar to screen   }	END; {SmallMenus}PROCEDURE LargeMenus;	VAR		indx: Integer;	BEGIN		ClearMenuBar;		FOR Indx := 1 TO MenuCnt DO       { place menus in menu bar           }			InsertMenu(MenuList[Indx], 0);		OwnEditMenu;		DrawMenuBar;                   { draw updated menu bar to screen   }	END; {LargeMenus}PROCEDURE BigFuncBox (Box: Rect; VAR Outbox: Rect);	BEGIN		Outbox := box;		WITH Box DO			BEGIN				IF Bottom - Top > Right - Left THEN					BEGIN						Outbox.right := (Right + Left + Bottom - Top) DIV 2;						Outbox.left := outbox.right - (bottom - top)					END				ELSE					BEGIN						Outbox.bottom := (Top + Bottom + Right - Left) DIV 2;						Outbox.Top := Outbox.bottom - (right - left)					END			END;	END; {FuncBox}PROCEDURE SmallFuncBox (Box: Rect; VAR Outbox: Rect; BoxSize: Integer);	BEGIN		Outbox := box;		WITH Box DO			BEGIN				Outbox.Right := (Left + Right + BoxSize) DIV 2;				Outbox.left := Outbox.right - BoxSize;				Outbox.bottom := (top + bottom + Boxsize) DIV 2;				Outbox.top := Outbox.bottom - Boxsize			END;	END; {SmallFuncBox}PROCEDURE FuncBox (Box: Rect; VAR Outbox: Rect; BoxSize: Integer);	BEGIN		WITH Box DO			IF ((Right - Left) > BoxSize) OR ((Bottom - Top) > Boxsize) THEN				BigFuncBox(Box, Outbox)			ELSE				SmallFuncBox(Box, Outbox, Boxsize);		WITH Outbox DO			BEGIN				right := right + 1;				bottom := bottom + 1;			END;	END;PROCEDURE Poop (n: Integer);	VAR		j: Integer;	BEGIN {FOR j:=1 TO N DO Sysbeep(1)}	END; {poop}PROCEDURE StartDocuments (DocumentCount: Integer);{v1.1 The original procedure would fail if you double click on a colour biomorph file,}{because those files have the same creator signiture but different file formats.}{Added check of file format - Alun}	VAR		j, k, volume, PersFile: Integer;		theFile: AppFile;		errorCode: OSErr;		dirID, procID, bytesToRead: LongInt;	BEGIN		j := 0;		FOR k := 1 TO DocumentCount DO			BEGIN				GetAppFiles(k, theFile);				WITH theFile DO					IF (fType = 'APPL') | NOT ((fType = 'COLL') | (fType = 'BIOM') | (fType = 'FOSS')) THEN							{v1.1 added last three type tests}						SysBeep(1)					ELSE						BEGIN							errorCode := GetWDInfo(vRefNum, volume, dirID, procID);							errorCode := HOpen(volume, dirID, fName, fsRdPerm, persFile);							IF errorCode <> noErr THEN								SysBeep(1)							ELSE								BEGIN									WHILE NOT ((IsEOF(PersFile, SizeOfPerson)) OR (j >= MaxAlbum)) DO										BEGIN											j := succ(j);											bytesToRead := SizeOfPerson;											errorCode := FSRead(persFile, bytesToRead, @ThisMenagerie.Member[j]);											IF errorCode <> noErr THEN												j := j - 1;										END;									errorCode := FSClose(PersFile)								END						END			END;		ThisMenagerie.Size := j;	END; {StartDocuments}{   *********   event handling routines   *********** }END.