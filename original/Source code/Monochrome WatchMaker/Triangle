UNIT Triangle;INTERFACEUSES	Biomorphs;PROCEDURE AtLeast (VAR OutRect: Rect);PROCEDURE OwnCursor (theRect: Rect; fromBitMap: BitMap; VAR theCursor: Cursor);PROCEDURE MainTriangle;PROCEDURE PlotTriangle (MLoc: point; Localswitch: Boolean);PROCEDURE FlickerTriangle (MLoc: Point);IMPLEMENTATIONPROCEDURE Triangle (VAR r1, r2, r3: real; b: point; m: point);	VAR		x, y, k: real;		screenheight: LONGINT;	BEGIN		screenheight := screenbits.bounds.bottom - screenbits.bounds.top;		k := round(200 * screenheight / 340);		x := m.h - b.h;		y := (screenheight - m.v) - (screenheight - b.v);		r1 := y / k;		r3 := (x - y / 2) / k;		r2 := (k - x - y / 2) / k;	END; {triangle}PROCEDURE DrawTriangle (a, b, c: point);	BEGIN		Moveto(a.h, a.v);		LineTo(b.h, b.v);		LineTo(c.h, c.v);		LineTo(a.h, a.v);	END; {drawtriangle}PROCEDURE Concoct (r1, r2, r3: real; a, b, c: person; VAR new: person);	VAR		j, weight: Integer;	FUNCTION Force3 (r: real): Integer;		VAR			i: Integer;		BEGIN			i := round(r);			IF i > 2 THEN				i := 2;			IF i < 0 THEN				i := 0;			Force3 := i		END; {Force3}	FUNCTION Force2 (r: real): Integer;		VAR			i: Integer;		BEGIN			i := round(r);			IF i > 1 THEN				i := 1;			IF i < 0 THEN				i := 0;			Force2 := i		END; {Force2}	BEGIN		WITH new DO			BEGIN				SegNoGene := round(r1 * a.SegNoGene + r2 * b.SegNoGene + r3 * c.SegNoGene);				IF SegNoGene < 1 THEN					SegNoGene := 1;				SegDistGene := round(r1 * a.SegDistGene + r2 * b.SegDistGene + r3 * c.SegDistGene);				CompletenessGene := CompletenessType(Force2(r1 * Integer(a.CompletenessGene) + r2 * Integer(b.CompletenessGene) + r3 * Integer(c.CompletenessGene)));				SpokesGene := SpokesType(Force3(r1 * Integer(a.SpokesGene) + r2 * Integer(b.SpokesGene) + r3 * Integer(c.SpokesGene)));				FOR j := 1 TO 9 DO					gene[j] := round(r1 * a.gene[j] + r2 * b.gene[j] + r3 * c.gene[j]);				SizeWorry := SegNoGene * TwoToThe(gene[9]);				IF SizeWorry > WorryMax THEN					Gene[9] := Gene[9] - 1;				IF gene[9] < 1 THEN					gene[9] := 1;				tricklegene := round(r1 * a.tricklegene + r2 * b.tricklegene + r3 * c.tricklegene);				MutSizeGene := round(r1 * a.MutSizeGene + r2 * b.MutSizeGene + r3 * c.MutSizeGene);				MutProbGene := round(r1 * a.MutProbGene + r2 * b.MutProbGene + r3 * c.MutProbGene);				IF mutprobgene < 1 THEN					mutprobgene := 1;				IF mutprobgene > 100 THEN					mutprobgene := 100;				FOR j := 1 TO 10 DO					dgene[j] := swelltype(Force3(r1 * Integer(a.dgene[j]) + r2 * Integer(b.dgene[j]) + r3 * Integer(c.dgene[j])));			END	END; {concoct}PROCEDURE PlotTriangle (MLoc: point; Localswitch: Boolean);	VAR		margcentre, offset: Integer;		OffCentre: Point;	BEGIN		IF LocalSwitch THEN			GlobalToLocal(Mloc);		triangle(r1, r2, r3, b, MLoc);		concoct(r1, r2, r3, topan, leftan, rightan, child[special]);		zeromargin := TRUE;		DelayedDrawing := TRUE;		develop(child[special], Mloc);		WITH margin DO			margcentre := top + (bottom - top) DIV 2;		offset := margcentre - MLoc.v;		WITH Margin DO			BEGIN				Top := Top - Offset;				Bottom := Bottom - Offset			END;		WITH OffCentre DO			BEGIN				h := MLoc.h;				v := MLoc.v - offset;			END;		grow(margin, 2);		EraseRect(margin);		FrameRect(margin);		DrawPic(MyPic, offcentre, child[special]);{MakeGeneBox(child[special]);}	END; {PlotTriangle}PROCEDURE MainTriangle;	VAR		ScreenWidth, ScreenHeight: LONGINT;		Storeanimal: person;	BEGIN		AlreadyTriangling := FALSE;		IF special > 0 THEN			Storeanimal := child[special];		LastMouse.h := -1;		LastMouse.v := -1;		eraserect(Prect);		WITH Screenbits.Bounds DO			BEGIN				ScreenWidth := right - left;				ScreenHeight := bottom - top			END;		a.h := round(234 * ScreenWidth / 512);		a.v := round(51 * ScreenHeight / 342);		b.h := round(134 * ScreenWidth / 512);		b.v := round(250 * ScreenHeight / 342);		c.h := round(333 * ScreenWidth / 512);		c.v := round(250 * ScreenHeight / 342);		drawtriangle(a, b, c);		mous.v := 0;		mous.h := 0;		eraserect(Prect);		drawtriangle(a, b, c);		IF special = 0 THEN			special := 1;		PlotTriangle(a, FALSE);		PlotTriangle(b, FALSE);		PlotTriangle(c, FALSE);		IF special > 0 THEN			child[special] := storeanimal;	END; {maintriangle}PROCEDURE OwnCursor (theRect: Rect; fromBitMap: BitMap; VAR theCursor: Cursor);	VAR		Box, SmallRect: Rect;		aBitMap: BitMap;		myBits16: Bits16;		SizeNeeded: LONGINT;		CanDo: Boolean;		errString, helpString: Str255;	FUNCTION MakeBits16 (theBitMap: BitMap; VAR theBits16: Bits16): Boolean;		TYPE			BitsPtr = ^Bits16;		VAR			thePtr: BitsPtr;			thebase: LONGINT;		BEGIN			SizeNeeded := LONGINT(SizeOf(BitsPtr));			IF (Memavail - SizeNeeded) < SafetyValve THEN				BEGIN					GetIndString(errString, 128, 13);			{** v1.1 **}					GetIndString(helpString, 128, 14);					DisplayError(-108, errString, helpString, StopError);					ExitToShell;{was: MemoryMessage ( 4405 , ' in making Bits16' , Verdict ); exitToShell from proc}					MakeBits16 := FALSE				END			ELSE				BEGIN					thePtr := BitsPtr(NewPtr(SizeOf(BitsPtr)));					IF MemError <> noErr THEN						ExitToShell;					thePtr := BitsPtr(theBitMap.BaseAddr);					theBits16 := thePtr^;					DisposPtr(Ptr(thePtr));					MakeBits16 := TRUE;				END; {TRUE condition}		END; {Make Bits16}	FUNCTION BigEnough (VAR theRect: Rect): Boolean;		VAR			Width, Height: Integer;		BEGIN			WITH theRect DO				BEGIN					Width := Right - Left;					Height := Bottom - Top;				END;			BigEnough := (Width > 16) AND (Height > 16);		END; {LargerRect}	BEGIN		SetRect(Box, 0, 0, 16, 16);		WITH theRect DO			BEGIN				left := left + 2;				right := right - 2;				top := top + 2;				bottom := bottom - 2			END;		aBitMap.rowBytes := 2;		aBitMap.bounds := box;		SizeNeeded := LONGINT(SizeOf(Bits16));		IF (Memavail - SizeNeeded) < SafetyValve THEN			BEGIN				GetIndString(errString, 128, 14);		{** v1.1 **}				GetIndString(helpString, 128, 4);				DisplayError(-108, errString, helpString, StopError);				ExitToShell;{was: MemoryMessage(4405, 'CanÕt make biomorphic cursor', Verdict);}				CanDo := FALSE;			END		ELSE			BEGIN				CanDo := TRUE;				aBitMap.baseAddr := NewPtr(SizeOf(Bits16));				IF MemError <> noErr THEN					ExitToShell;     {No memory available}				CopyBits(fromBitMap, aBitMap, TheRect, box, srcCopy, NIL);			END;		IF CanDo AND MakeBits16(aBitMap, MyBits16) AND (BigEnough(theRect) OR (theMode = Triangling)) THEN			BEGIN				theCursor.data := MyBits16;				theCursor.mask := curslist[breedcursor]^^.mask;				theCursor.hotSpot.v := 8;				theCursor.hotSpot.h := 8;				DisposPtr(aBitMap.baseAddr);			END		ELSE			theCursor := curslist[crosscursor]^^;	END; {OwnCursor}FUNCTION DivisibleByEight (n: Integer): Boolean;	BEGIN		DivisibleByEight := 8 * (n DIV 8) = n	END;PROCEDURE AtLeast (VAR OutRect: Rect);	VAR		width, height: Integer;	BEGIN		InsetRect(OutRect, -3, -3);		WITH OutRect DO			BEGIN				WHILE NOT (DivisibleByEight(left)) DO					left := left - 1;				WHILE NOT (DivisibleByEight(right)) DO					right := right + 1			END	END;PROCEDURE MakeNiceBox (Inbox: Rect; VAR outbox: Rect);	VAR		width, height, MidWidth, MidHeight, Widthbytes: Integer;	BEGIN		OutBox := InBox;		WITH OutBox DO			BEGIN				height := bottom - top;{1+}				width := right - left;{1+}				IF width < height THEN					width := height				ELSE					height := width;    {WidthBytes:=width DIV 8;}{    WHILE odd(WidthBytes) DO WidthBytes:=WidthBytes+1;}{    Width:=WidthBytes*8;}				left := 8;				Right := left + Width;				Top := 8;				Bottom := Top + Height;				AtLeast(outbox);				right := right + 1;			END;	END; {MakeNiceBox}PROCEDURE CursSnap (ThisPic: Pic; box: Rect; offset: Integer; biomorph: person);	VAR		Midpoint: Point;		NiceBox: Rect;		Offcentre: Point;		Centre: Integer;		SavePort: GrafPtr;		SaveBitMap: Bitmap;	BEGIN {ClipRect(businessPart);}		GetPort(SavePort);		SaveBitMap := SavePort^.PortBits;		SetPortBits(AlbumBitMap[0]);		MakeNiceBox(box, NiceBox);		WITH NiceBox DO			BEGIN				MidPoint.v := top + (bottom - top) DIV 2;				MidPoint.h := left + (right - left) DIV 2;			END;		EraseRect(NiceBox); {offscreen}		Offcentre := MidPoint;		Offcentre.v := Offcentre.v - offset;		DrawPic(ThisPic, Offcentre, biomorph);		OwnCursor(Nicebox, AlbumBitMap[0], theCursor);		SetPort(SavePort);		SetPortBits(SaveBitMap);		ClipRect(MainPtr^.PortRect);	END; {CursSnap}PROCEDURE FlickerTriangle (MLoc: Point);	VAR		infant: person;		margcentre, offset: Integer;	BEGIN		triangle(r1, r2, r3, b, MLoc);		concoct(r1, r2, r3, topan, leftan, rightan, infant);		IF theMode <> triangling THEN			BEGIN				IF infant.gene[9] > 6 THEN					infant.gene[9] := 6;				IF infant.SegNoGene > 2 THEN					infant.SegNoGene := 2;			END;		DelayedDrawing := TRUE;		ZeroMargin := TRUE;		Develop(infant, MLoc);    {At this point Margin really does correctly frame the biomorph}		WITH margin DO			margcentre := top + (bottom - top) DIV 2;		offset := margcentre - MLoc.v;		CursSnap(MyPic, Margin, offset, infant);	END; {FlickerTriangle}END.