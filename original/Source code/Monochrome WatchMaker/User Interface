UNIT User_Interface;{******************************************************************}{*															v1.1 Sept 1993.																	*}{* 	Added Suspend/Resume events																									*}{*		Added command key handling																										*}{*		Split activate/deactivate event handling																					*}{*		New menu item -> hide windows in background																			*}{*		Save screen if hiding windows, otherwise don't - speed up context switching								*}{*		Enabled desk accessories																											*}{*		Added bad disk handling																												*}{*		Split up HandleMenu proc into several procedures - one per menu 												*}{*		Added named constants for menu items (so ordinary mortals like me can read this!)					*}{*		All file operations converted to Mac file manager calls																*}{*		DLOGs for DireMessages changed to Alerts, conforming to Apple's HIG										*}{*		Removed Repeat/Until loops around save changes alerts																*}{*		Removed many unused variables, and restricted USE of other units											*}{*		Added auto positioning of dialogs and alerts under System 6 (urgh). Added auto position to			*}{*				resources for System 7																									*}{*		Saving files in same folder as file with same name now removes old file, even if open (not			*}{*				sure of the wisdom of this, though)																					*}{*																																						*}{--------------------------------------------------------------------------------------------}{*																	TO DO																			*}{*		Check out other dialogs, some of them should be alerts	(done)													*}{*		Offscreen bitmaps:																													*}{*			1) Save only rect of dialog or alert																						*}{*			2) Don't save screen before switching out (makes response sluggish - Apple says don't do it)	*}{*			3) Change DoUpdate so that it draws normally if no offscreen saved										*}{*			4) Remove spurious calls to StoreOffScreen																			*}{*			5) Disentangle activate and update event handling																	*}{*		Restrict window size, and allow users to change size. Option: leave space for disk icons				*}{*		Add support for a least the required set of Apple Events 															*}{*																																						*}{******************************************************************}INTERFACEUSES	Album, Pedigree;PROCEDURE HandleEvent (theEvent: EventRecord);IMPLEMENTATIONPROCEDURE DoAbout;{}{    Purpose         bring up 'About...' box using a dialog box}{}	VAR		theItem: Integer;		AboutPtr: DialogPtr;	BEGIN		IF frontwindow = mainptr THEN			Storeoffscreen(MainPtr^.PortRect, MyBitMap);		SetCursor(CursList[CrossCursor]^^);      				{set to my cursor}  {ShowCursor; }                          { and turn it back on           }		IF gSystem.systemVersion < $0700 THEN			PositionDialog('DLOG', 11271);		AboutPtr := GetNewDialog(11271, NIL, Pointer(-1));    	{get dialog box}		ModalDialog(NIL, theItem);             					{put dialog box up; get result }		DisposDialog(AboutPtr);               						{get rid of dialog box }		SetCursor(Arrow);	END; { of proc DoAbout }PROCEDURE ToggleFlag (VAR Flag: Boolean; Mndx, Indx: Integer);{}{    purpose         checks or de-checks item Indx in menu Mndx}{    last update     20 Aug 86}{}	VAR		Ch: Char;	BEGIN		Flag := NOT Flag;                     { toggle flag (for you)         }		IF Flag THEN                               { if flag is True...            }			Ch := Chr(CheckMark)           {   then check item in menu     }		ELSE			Ch := Chr(NoMark);             {   else clear any checkmark    }		SetItemMark(MenuList[Mndx], Indx, Ch)   { put char by item in menu      }	END; { of proc ToggleFlag }PROCEDURE EnableMenus;	VAR		i: Integer;	BEGIN		FOR i := 1 TO MenuCnt DO			EnableItem(MenuList[i], 0);		OwnEditMenu;		DrawMenuBar;	END;PROCEDURE DisableMenus;	VAR		i: Integer;	BEGIN		FOR i := 2 TO MenuCnt DO			DisableItem(MenuList[i], 0);		EnableItem(MenuList[3], 0);		FOR i := 1 TO 6 DO			EnableItem(MenuList[3], i);		FOR i := 7 TO 10 DO			DisableItem(MenuList[3], i);		DrawMenuBar;	END;PROCEDURE DoDeskAcc (Item: Integer);{}{    purpose         start up desk accessory from Apple menu}{v1.1 DName was incorrectly declared as a STRING and some lines commented out. DAs now work correctly.}	VAR		SavePort: GrafPtr;		RefNum: Integer;		DName: Str255;	BEGIN		IF frontwindow = mainptr THEN			BEGIN				IF theMode = Albuming THEN					Danger := TRUE;				Storeoffscreen(MainPtr^.PortRect, MyBitMap);			END;		GetPort(SavePort);                    			{ save port before starting it  }		GetItem(MenuList[AM], Item, DName);		{ get name of desk accessory    }		refNum := OpenDeskAcc(DName);			{*This line was commented out! -Alun v1.1*}     										{ and start that sucker up!     }		SetPort(SavePort);                    			{ restore grafport and continue }		DAon := TRUE	END; { of proc DoDeskAcc }PROCEDURE DoFileMenuCommands (menuItem: Integer);{v1.1 same as before, I have just split the very long proc into readable pieces}	VAR		verdict, StoreNRows, StoreNCols: Integer;		err: OSErr;	BEGIN		StoreNRows := NRows;		StoreNCols := NCols;		CASE menuItem OF			LoadAlbumItem: 				BEGIN					NRows := AlbumNRows;					NCols := AlbumNCols;					SetUpBoxes;					LoadingFossils := FALSE;					DoLoad(TRUE);					NRows := StoreNRows;					NCols := StoreNCols;				END;			LoadFossilsItem: 				BEGIN					IF NOT FossilsExist THEN						ResetFossils					ELSE						BEGIN							DotheSave := FALSE;							DireMessage(kFossilsID, kResettingID, Verdict, true);							IF Verdict = 1 THEN								SaveSlides; {Yes}                            {returns with DoTheSave}							IF (Verdict = 1) AND (DoTheSave) THEN								ResetFossils;							IF Verdict = 2 THEN								ResetFossils {No}						END;					IF verdict <> 3 THEN {3=cancel}						BEGIN							Fossilizing := FALSE;  {Filetype := 'COLL';}							err := SetEOF(slides, 0);							LoadingFossils := TRUE;							ReadAnimals(ThisMenagerie); {Menagerie is dummy}                        {The next 3 lines are necessary for Spencer's manual but better out}                        (*ClosePlayBack;}{                        Fossilizing:=TRUE;}{                        DoBreed*)                        {Reset(slides);}{                        StartPlayBack;}						END; {Not cancelled}				END;{case 2}			SaveBiomorphItem: 				DoSave(1);			SaveFossilsItem: 				SaveSlides;			SaveAlbumItem: 				IF theMode = Moving THEN					DoSave(2)				ELSE					DoSave(3);			CloseAlbumItem: 				DoClose;			QuitItem: 				Finished := True;   { Quit command              }		END;{case}	END;{DoFileMenuCommands}PROCEDURE DoEditMenuCommands (item: Integer);	VAR		StoreNRows, StoreNCols: Integer;	BEGIN		StoreNRows := NRows;		StoreNCols := NCols;		IF Item <> CutItem THEN			ClipBoarding := FALSE;		IF (Item >= AddBiomItem) THEN			BEGIN				IF TheMode <> Albuming THEN					StoreBreedingScreen;				NRows := AlbumNRows;				NCols := AlbumNCols;				TheMode := Albuming;				SetUpBoxes			END;		CASE Item OF			UndoItem: 				IF NOT SystemEdit(0) THEN					Sysbeep(1);			2: 				;  {----------------}			CutItem: 				IF NOT SystemEdit(2) THEN					Sysbeep(1);			Copyitem: 				IF NOT SystemEdit(3) THEN					SendToClipBoard;			PasteItem: 				IF NOT SystemEdit(4) THEN					DoClear(FALSE);			ClearItem: 				IF NOT SystemEdit(5) THEN					DoClear(TRUE);			7: 				;  {----------------}			HighlightBiomItem: 				DoHighlight;			AddBiomItem: 				BEGIN					AddToAlbum(child[special]);				END;{****}                    {Range check fails on special, gives bomb, when album emptied}			ShowAlbumItem: 				IF Page > 1 THEN					Zoom				ELSE					BEGIN						UncurtainPage(CurrentPage);						TakeCare(CurrentPage);						IF OldSpecial = 0 THEN							BEGIN								OldSpecial := Special;								InvertRect(Box[special])							END;					END;		END; {Cases}		IF Item >= HighlightBiomItem THEN			BEGIN				NRows := StoreNRows;				NCols := StoreNCols;			END;	END;{DoEditMenuCommand}PROCEDURE DoSpecMenuCommands (item: Integer);	BEGIN		CASE Item OF			ClosePlaybackItem: 				BEGIN {Child[MidBox]:=FirstBiomorph;}					ClosePlayBack;				END;			BreedCurrentItem: 				BEGIN					FirstBiomorph := TheBiomorph;					ClosePlayBack;					Fossilizing := FALSE;					DoBreed				END;			QuitPlaybackItem: 				Finished := TRUE;		END;	END;{DoSpecMenuCommands}PROCEDURE DoOperationMenuCommands (item: Integer);	VAR		verdict: Integer;		err: OSErr;	BEGIN		ClipBoarding := FALSE;		CASE Item OF              { Operation Menu          }			BreedItem: 				BEGIN					NRows := BreedNRows;					NCols := BreedNCols;					SetUpBoxes;					NActiveBoxes := NBoxes;					DoBreed;				END;			DriftItem: 				BEGIN					EraseRect(Prect);					TheMode := Drifting;					DriftOne := 0;					NActiveBoxes := 0;				END;			EngineeringItem: 				BEGIN					DoEngineer				END;			HopeMonsterItem: 				BEGIN					DoSaltation;				END;			InitFossRecItem: 				BEGIN					IF NOT FossilsExist THEN						ResetFossils					ELSE						BEGIN							DotheSave := FALSE;							DireMessage(kFossilsID, kResettingID, Verdict, true);							IF Verdict = 1 THEN								SaveSlides; {Yes}                            {returns with DoTheSave}							IF (Verdict = 1) AND (DoTheSave) THEN								ResetFossils;							IF Verdict = 2 THEN								ResetFossils {No}						END;				END;			PlayFossilItem: 				BEGIN					err := SetFPos(Slides, fsFromStart, 0);		{v1.1  was reset(Slides);} 																											{Only play back history made this time}					StartPlayBack;  {Play Back Fossil Record}				END;			RecordFossilItem: 				Fossilizing := NOT Fossilizing;			TriangleItem: 				BEGIN					TheMode := triangling;					OldSpecial := 0;					MainTriangle				END;		END;	END;PROCEDURE DoBoxMenuCommands (item: Integer);	VAR		verdict: Integer;	BEGIN		ClipBoarding := FALSE;		CASE Item OF			MoreRowsItem: 				DoRowMore;			FewerRowsItem: 				DoRowLess;			MoreColumnsItem: 				DoColMore;			FewerColumnsItem: 				DoColLess;			ThickerPenItem: 				BEGIN					MyPenSize := MyPenSize + 1;					DoEngineer				END;			ThinnerPenItem: 				BEGIN					MyPenSize := MyPenSize - 1;					DoEngineer				END;			DriftSweepItem: 				BEGIN					SweepOn := NOT SweepOn;					CheckItem(MenuList[BM], Item, SweepOn);                        {EraseRect(PRect);}					DriftOne := 0;                        {TheMode:=Drifting}				END;			TriangleTopItem: 				BEGIN					IF theMode = Triangling THEN						BEGIN							SimpleMessage(14234, Verdict);							IF verdict = 1 THEN								BEGIN									Topan := child[special];									MainTriangle								END						END					ELSE						Topan := child[special]				END;			TriangleLeftItem: 				BEGIN					IF theMode = Triangling THEN						BEGIN							SimpleMessage(14234, Verdict);							IF verdict = 1 THEN								BEGIN									Leftan := child[special];									MainTriangle								END						END					ELSE						Leftan := child[special]				END;			TriangleRightItem: 				BEGIN					IF theMode = Triangling THEN						BEGIN							SimpleMessage(14234, Verdict);							IF verdict = 1 THEN								BEGIN									Rightan := child[special];									MainTriangle								END						END					ELSE						Rightan := child[special]				END;			11: 				; {line}			HideWindowItem:{Toggle hide windows}				BEGIN					hideInBackground := NOT hideInBackGround;		{TRUE = hide windows when switching out}					CheckItem(MenuList[BM], Item, hideInBackGround);				END;		END;		StoreOffScreen(MainPtr^.PortRect, MyBitMap);		BreedNRows := NRows;		BreedNCols := NCols;		BreedNBoxes := NBoxes;	END;PROCEDURE DoMutationMenuCommands (item: Integer);	BEGIN		ClipBoarding := FALSE;		CheckItem(MenuList[MM], Item, NOT Mut[Item]);		Mut[Item] := NOT Mut[Item];		SetItemState(MM, 2, Mut[1]);		IF NOT Mut[1] THEN			BEGIN				Mut[2] := FALSE;				CheckItem(MenuList[MM], 2, FALSE)			END	END;PROCEDURE DoPedigreeMenuCommands (item: Integer);	BEGIN		CASE Item OF			DisplayPedigreeItem: 				PhylogNew(Child[special]);			2: 				; {-------------------}			DrawOutItem: 				TheMode := Phyloging;			NoMirrorsItem: 				BEGIN					Rays := 1;					CheckItem(MenuList[PM], 4, TRUE);					CheckItem(MenuList[PM], 5, FALSE);					CheckItem(MenuList[PM], 6, FALSE);				END;			SingleMirrorItem: 				BEGIN					Rays := 2;					CheckItem(MenuList[PM], 5, TRUE);					CheckItem(MenuList[PM], 4, FALSE);					CheckItem(MenuList[PM], 6, FALSE);				END;			DoubleMirrorItem: 				BEGIN					Rays := 4;					CheckItem(MenuList[PM], 6, TRUE);					CheckItem(MenuList[PM], 4, FALSE);					CheckItem(MenuList[PM], 5, FALSE);				END;			7: 				;{-------------------}			MoveItem: 				TheMode := Moving;			DetachItem: 				TheMode := Detaching;			KillItem: 				TheMode := Killing;		END;	END;{DoPedigreeMenuCommands}PROCEDURE DoHelpMenuCommands (item: Integer);	BEGIN		IF ClipBoarding THEN			HelpMessage(7699)		ELSE			CASE Item OF				HelpCurrentItem: 					CASE theMode OF						Breeding: 							HelpMessage(2630);						albuming: 							HelpMessage(11506);						phyloging: 							HelpMessage(12587);						killing: 							HelpMessage(11150);						moving: 							HelpMessage(4241);						detaching: 							HelpMessage(16204);						randoming: 							HelpMessage(26732);						engineering: 							HelpMessage(8597);						drifting: 							HelpMessage(8947);						highlighting: 							HelpMessage(19866);						PlayingBack: 							HelpMessage(11238);						triangling: 							HelpMessage(17751);						sweeping: 							HelpMessage(8947);					END; {Cases}				HelpMiscItem: 					HelpMessage(21128);			END; {Help 2 cases}	END;{DoHelpMenuCommands}PROCEDURE HandleMenu (MenuInfo: LongInt);{####)}{}{{}{    purpose         decode MenuInfo and carry out command}{}	VAR		Menu: Integer;          { menu number that was selected     }		Item: Integer;	BEGIN		IF MenuInfo <> 0 THEN			BEGIN				PenNormal;                      				{ set the pen back to normal}				Menu := HiWord(MenuInfo);       		{ find which menu the command is in }				Item := LoWord(MenuInfo);       			{ get the command number}				CASE Menu OF					ApplMenu: 						BEGIN							IF Item = 1 THEN								DoAbout            	{ bring up "About..." window}							ELSE								DoDeskAcc(Item);   	{ start desk accessory}                     								{ and carry it out }						END;					FileMenu: 						DoFileMenuCommands(item);					EditMenu: 						DoEditMenuCommands(item);					SpecMenu: 						DoSpecMenuCommands(item);					OperMenu: 						DoOperationMenuCommands(item);					BoxMenu: 						DoBoxMenuCommands(item);					MutationMenu: 						DoMutationMenuCommands(item);					PedigreeMenu: 						DoPedigreeMenuCommands(item);					HelpMenu: 						DoHelpMenuCommands(item);					OTHERWISE						Sysbeep(1);				END;{case of Menu}				HiliteMenu(0);                          { reset menu bar            }			END;	END; {of proc HandleMenu}PROCEDURE DoUpdate (theEvent: EventRecord);{}{    purpose         handles window update event}{}	VAR		SavePort, theWindow: WindowPtr;	BEGIN		theWindow := WindowPtr(theEvent.Message);     { find which window     }		IF (theWindow = MainPtr) OR (theWindow = PlayBackPtr) THEN			BEGIN            { only update ours      }				SetCursor(CursList[watchCursor]^^);         { set cursor to watch   }				GetPort(SavePort);                          { save current grafport }				SetPort(theWindow);                         { set as current port   }				BeginUpdate(theWindow);                     { signal start of update}				IF theWindow = MainPtr THEN					ReStoreOffScreen(MainPtr^.PortRect, MyBitMap);  { and here's the update stuff! }				IF theWindow = PlayBackPtr THEN					BEGIN						PlayBackRect := PlayBackPtr^.PortRect;						EraseRect(PlayBackRect);						DrawGrowIcon(PlayBackPtr);                   { draw grow icon  }						DrawControls(PlayBackPtr);						WITH PlayBackRect DO							BEGIN								right := right - Scrollbarwidth - 1;								bottom := bottom - Scrollbarwidth - 1;							END;						IF theMode = PlayingBack THEN							Snapshot(MyPic, PlayBackRect, theBiomorph);					END;  { now, back to our program...}				EndUpdate(theWindow);                       { signal end of update  }				SetPort(SavePort);                          { restore grafport      }				SetCursor(Arrow)                            { restore cursor        }			END; {MainPtr}	END; { of proc DoUpdate }PROCEDURE HandleClick (WPtr: WindowPtr; MLoc: Point);{}{    purpose         handle mouse click within window}{}	VAR		j, chosen: Integer;		MP: point;		ErrCode: OSErr;		Ticker: LongInt;		OnlyChild: Boolean;		SaveFull: Full;	BEGIN		IF (WPtr = MainPtr) OR (WPtr = PlayBackPtr) THEN     { if this is our window...  }			BEGIN				IF WPtr <> frontw THEN             { and it's not in front...  }					BEGIN						SelectWindow(WPtr);               { ...then make it active    }						frontw := MainPtr;						reStoreOffScreen(MainPtr^.PortRect, MyBitMap);             {DoUpdate(theEvent);}						enablemenus;					END				ELSE IF TheMode = triangling THEN					PlotTriangle(MLoc, TRUE)				ELSE IF TheMode = breeding THEN					BEGIN						SetCursor(CursList[watchCursor]^^);						evolve(MLoc);						SetCursor(CursList[crossCursor]^^)					END				ELSE IF TheMode = randoming THEN					DoSaltation				ELSE IF TheMode = PlayingBack THEN					BEGIN						GlobalToLocal(MLoc);						IF PtInRect(MLoc, MyControl^^.contrlRect) THEN							BEGIN								DoPlayBack(MLoc)							END					END				ELSE IF (TheMode = Phyloging) THEN					BEGIN						RunningFull := SpecialFull;						GetMouse(MP);						IF MouseInBox(MP, RunningFull) THEN							DrawOutFrom(RunningFull);					END;				IF TheMode = Moving THEN					BEGIN						RunningFull := SpecialFull;						GetMouse(MP);						IF MouseInBox(MP, RunningFull) THEN							FollowMouse(RunningFull)					END;				IF TheMode = Detaching THEN					BEGIN						RunningFull := SpecialFull;						GetMouse(MP);						IF MouseInBox(MP, RunningFull) THEN							BEGIN								IF IsAnAdam(RunningFull) THEN									SysBeep(1)								ELSE									Detach(RunningFull)							END					END;				IF TheMode = Killing THEN					BEGIN						RunningFull := SpecialFull;						GetMouse(MP);						IF MouseInBox(MP, RunningFull) THEN							Shoot(RunningFull);					END;				IF TheMode = engineering THEN					BEGIN						Ticker := TickCount;						IF FirstTime THEN							SetCursor(CursList[watchCursor]^^);						Manipulation(MLoc);						IF FirstTime THEN							BEGIN								FirstTime := FALSE;								REPEAT								UNTIL TickCount - Ticker > GetDblTime;							END;						IF button THEN							ErrCode := PostEvent(MouseDown, 0)					END				ELSE IF TheMode = highlighting THEN					emphasize(MLoc);				IF (TheMode = Albuming) AND (NOT Zoomed) THEN					emphasize(MLoc);				Zoomed := FALSE;			END;	END; { of proc HandleClick }PROCEDURE HandleGrow (WPtr: WindowPtr; MLoc: Point);{}{    purpose         handle mouse click in grow box}{}	TYPE		GrowRec = RECORD				CASE Integer OF					0: (							Result: LongInt					);					1: (							Height, Width: Integer					)			END;	VAR		GrowInfo: GrowRec;	BEGIN		IF WPtr = PlayBackPtr THEN			WITH GrowInfo DO  { if it's our window    }				BEGIN					InvalRect(WPtr^.portRect);                   {   set up for update   }					Result := GrowWindow(WPtr, MLoc, GrowArea);   {   get amt of growth   }					SizeWindow(WPtr, Width, Height, True);         {   resize window       }					WITH PlayBackPtr^.PortRect DO						BEGIN							MoveControl(MyControl, right - (ScrollBarWidth - 1), top - 1);							SizeControl(MyControl, ScrollBarWidth, (bottom + 1) - (top - 1) - (ScrollBarWidth - 1))						END;{    PlayBackRect:=WPtr^.PortRect;}{    WITH PlayBackRect DO}{        BEGIN right:=right-Scrollbarwidth-1;}{        bottom:=bottom-Scrollbarwidth-1;}{        MidPoint.h:=(right-left) DIV 2;}{        MidPoint.v:=(bottom-top) DIV 2}{        END;}    {InvalRect(MainPtr^.PortRect);}				END;	END; { of proc HandleGrow }PROCEDURE DoActivate (theEvent: EventRecord);{}{    purpose         handles window activation event}{}	VAR		theWindow: WindowPtr;	BEGIN		WITH theEvent DO			BEGIN				theWindow := WindowPtr(Message);            { get the window        }				SetPort(theWindow);                       {   make it the port    }				frontw := theWindow;                  {   know it's in front  }				SelectWindow(theWindow);              { -- in place of the previous}                                             { -- line.   AG              }				IF theWindow = MainPtr THEN					ReStoreOffScreen(MainPtr^.PortRect, MyBitMap)				ELSE					BEGIN						DrawGrowIcon(theWindow);					{v1.1 to ensure activating icon}						HiliteControl(myControl, 0);					{activate scrollbar}					END;				InvalRect(theWindow^.PortRect);				Enablemenus;				DAon := FALSE;                      { it must be our window }			END	END;PROCEDURE DoDeactivate (theEvent: EventRecord);	VAR		theWindow: WindowPtr;	BEGIN		WITH theEvent DO			BEGIN				theWindow := WindowPtr(Message);            { get the window        }				IF theWindow = PlaybackPtr THEN					BEGIN						child[special] := FirstBiomorph;						HiliteControl(myControl, 255);	{deactivate scrollbar}					END				ELSE					Storeoffscreen(MainPtr^.PortRect, MyBitMap);				SetPort(ScreenPort);                      { else reassign port    }			END;                              {   update menu bar     }	END;PROCEDURE DoSuspend (theEvent: EventRecord);{We have to do everything necessary (deactivate windows, copy local}{scrap to global, etc) before being switched out}{Set the flag to say we are in the background													}	BEGIN		IF frontw = PlaybackPtr THEN			BEGIN				child[special] := FirstBiomorph;				HiliteControl(myControl, 255);	{deactivate scrollbar}			END;		IF hideInBackGround THEN			BEGIN				HideWindow(PlaybackPtr);				Storeoffscreen(MainPtr^.PortRect, MyBitMap);				HideWindow(MainPtr)			END;		InitCursor;						{Set arrow cursor for other programs}		DAOn := True;		RememberMode := theMode;	END;PROCEDURE DoResume (theEvent: EventRecord);{Activate the front window}	BEGIN		IF hideInBackground THEN			BEGIN				ShowWindow(MainPtr);				IF frontw = playbackPtr THEN					ShowWindow(PlaybackPtr)				ELSE					ReStoreOffScreen(MainPtr^.PortRect, MyBitMap)			END;{Enablemenus;}		DAon := FALSE;		SetCursor(theCursor);		theMode := RememberMode;	END;PROCEDURE DoDiskEvent (macEvent: EventRecord); (* The disk event					*)	VAR		corner: Point; 	(* Location for Dialog box			*)		ignore: Integer;	BEGIN		IF (HiWord(macEvent.message) <> noErr) THEN			BEGIN						(* Some sort of error occurred.		*)						(*   Check if user wants to format	*)						(*   the disk.						*)				SetPt(corner, 112, 80);						(* ??? Can dialog box be centered	*)						(*   There doesn't appear to be a	*)						(*   DLOG resource for this one.	*)						(*   Location (112,80) is the value	*)						(*   used by Finder 6.1. 			*)				ignore := DIBadMount(corner, macEvent.message);			END;	END;PROCEDURE HandleGoAway (WPtr: WindowPtr; MLoc: Point);{}{    purpose         handle mouse click in go-away box}{}	VAR		WPeek: WindowPeek;           { for looking at windows    }	BEGIN		IF WPtr = frontw THEN{Indow}			BEGIN          { if it's the active window }				WPeek := WindowPeek(WPtr);              { peek at the window        }				IF TrackGoAway(WPtr, MLoc) THEN					BEGIN    {   and the box is clicked  }						IF WPeek^.WindowKind = PascalKind THEN       {     if it's our window    }							BEGIN								child[special] := FirstBiomorph;								ClosePlayBack;							END						ELSE							BEGIN								DAon := FALSE;								Sysbeep(1);								CloseDeskAcc(WPeek^.WindowKind);{       else close DeskAcc  }								enablemenus;                   {   and re-enable menus     }								Sysbeep(1);								REPEAT								UNTIL NOT button;								REPEAT								UNTIL button;							END;					END			END		ELSE			SelectWindow(WPtr)                   { else make it active       }	END; { of proc HandleGoAway }PROCEDURE DoKeypress (KeyCh: Char);{If the user presses a key, we go into evolving the biomorph until the mouse is pressed.}	BEGIN		min := 30000;{TargetEvolve(target);}	END; { of proc DoKeypress }PROCEDURE KeyDownEvents (theEvent: EventRecord);{ A key was pressed.  Do something with incoming character.}	VAR		ch: CHAR;	BEGIN		WITH theEvent DO			BEGIN				ch := CHR(BitAnd(message, charCodeMask));    		{Get character}				IF BitAnd(modifiers, Cmdkey) <> 0 THEN     		{If command key pressed}					HandleMenu(MenuKey(ch))       						{  then execute command}				ELSE					DoKeyPress(ch)											{else use character}			END {with}	END; {KeyDownEvents}PROCEDURE DoOtherEvent (macEvent: EventRecord);{Things like network events.  We don't do anything with these, this is a place-holder for future enhancements}	BEGIN	END;PROCEDURE DoMouseDown (theEvent: EventRecord);{}{    purpose         identify where mouse was clicked and handle it}{}	VAR		Location: Integer;		theWindow: WindowPtr;		MLoc: Point;		WLoc: Integer;	BEGIN		MLoc := theEvent.Where;              { get mouse position            }		WLoc := FindWindow(MLoc, theWindow);   { get window, loc in window     }		CASE WLoc OF                          { handle window locations       }			InMenuBar: 				HandleMenu(MenuSelect(MLoc));     { in the menu       }			InContent: 				HandleClick(theWindow, MLoc);      { inside the window }			IngoAway: 				HandleGoAway(theWindow, MLoc);     { in the go away box}			InGrow: 				HandleGrow(theWindow, MLoc);       { in the grow box   }			InDrag: 				BEGIN					DragWindow(theWindow, MLoc, DragArea); { in the drag bar}					WITH PlayBackPtr^.PortRect DO						BEGIN							MoveControl(MyControl, right - (ScrollBarWidth - 1), top - 1);							SizeControl(MyControl, ScrollBarWidth, (bottom + 1) - (top - 1) - (ScrollBarWidth - 1))						END;				END;			InSysWindow: 				BEGIN					SystemClick(theEvent, theWindow);  { in a DA window    }                  { if frontwindow=mainptr then enablemenus;}{                   front}				END;		END	END; { of proc DoMouseDown }PROCEDURE HandleEvent (theEvent: EventRecord);{}{    purpose         decodes event and handles it}{* v1.1 Sept 1993.  Added handling of suspend/resume events - Alun *}{}	CONST		MouseMovedEvt = $FA;		{ Mouse moved event code		}		SuspendResumeEvt = $01;		{ Suspend/Resume event code	}		ResumeEvtMask = $1;			{ Supend or Resume selector	}		ConvertScrapMask = $2;		{ Scrap conversion flag			}	BEGIN		CASE theEvent.What OF			mouseDown: 				DoMouseDown(theEvent);      		{ mouse button pushed   }			MouseUp: 				FirstTime := TRUE;			keyDown,								{ Key was pressed		}			keyUp, autoKey: 				KeyDownEvents(theEvent);			{ key pressed down      }			diskEvt: 				DoDiskEvent(theEvent);				{ Disk insertion Event	}			updateEvt: 				DoUpdate(theEvent);         				{ window need updating  }			activateEvt:				{ Activate or Deactivate a window	}								{   Check the modifiers field to		}								{   determine which one it is			}				IF BitAnd(theEvent.modifiers, activeFlag) <> 0 THEN					DoActivate(theEvent)				ELSE					DoDeactivate(theEvent);						{* MULTIFINDER EVENTS *}			app4Evt: 				CASE BAND(BSR(theEvent.message, 24), $FF) OF								{ Event type is stored in the			}								{   high byte of the event message	}								{   Typecast to unsigned long so		}								{   we won't get sign extension		}								{   when the bits are shifted			}					MouseMovedEvt: 						;									{ Since we adjust the cursor shape }									{   before handling an event, we 	}									{   can just idle here. 				}{DoIdle(theEvent);	 We could do things like update cursor shape in a DoIdle proc, which is preferable,}{but this is done earlier at the moment. Alun}					SuspendResumeEvt: 		{ Context switch		}						IF BAND(theEvent.message, ResumeEvtMask) <> 0 THEN							DoResume(theEvent)						ELSE							DoSuspend(theEvent);				END;			OTHERWISE						{ Some other event	}				DoOtherEvent(theEvent);		END	END; { of proc HandleEvent }END.